// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool_objects_Projectile
#include <lime/utils/ObjectPool_objects_Projectile.h>
#endif
#ifndef INCLUDED_map_Map
#include <map/Map.h>
#endif
#ifndef INCLUDED_map_Square
#include <map/Square.h>
#endif
#ifndef INCLUDED_network_NetworkHandler
#include <network/NetworkHandler.h>
#endif
#ifndef INCLUDED_objects_GameObject
#include <objects/GameObject.h>
#endif
#ifndef INCLUDED_objects_ObjectLibrary
#include <objects/ObjectLibrary.h>
#endif
#ifndef INCLUDED_objects_ObjectProperties
#include <objects/ObjectProperties.h>
#endif
#ifndef INCLUDED_objects_Player
#include <objects/Player.h>
#endif
#ifndef INCLUDED_objects_Projectile
#include <objects/Projectile.h>
#endif
#ifndef INCLUDED_objects_ProjectileProperties
#include <objects/ProjectileProperties.h>
#endif
#ifndef INCLUDED_objects_TextureData
#include <objects/TextureData.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_util_BloodComposition
#include <util/BloodComposition.h>
#endif
#ifndef INCLUDED_util_MathUtil
#include <util/MathUtil.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e39d53222c569c3d_19_new,"objects.Projectile","new",0x5afebdd5,"objects.Projectile.new","objects/Projectile.hx",19,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_73_addTo,"objects.Projectile","addTo",0xa99cbab1,"objects.Projectile.addTo","objects/Projectile.hx",73,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_79_removeFromMap,"objects.Projectile","removeFromMap",0x12d46923,"objects.Projectile.removeFromMap","objects/Projectile.hx",79,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_89_update,"objects.Projectile","update",0xa782afb4,"objects.Projectile.update","objects/Projectile.hx",89,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_161_reset,"objects.Projectile","reset",0x74213e84,"objects.Projectile.reset","objects/Projectile.hx",161,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_199_setDamages,"objects.Projectile","setDamages",0xe343d0cd,"objects.Projectile.setDamages","objects/Projectile.hx",199,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_205_moveTo,"objects.Projectile","moveTo",0xed29fc97,"objects.Projectile.moveTo","objects/Projectile.hx",205,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_212_getHit,"objects.Projectile","getHit",0xc39ba908,"objects.Projectile.getHit","objects/Projectile.hx",212,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_258_positionAt,"objects.Projectile","positionAt",0xfdadf127,"objects.Projectile.positionAt","objects/Projectile.hx",258,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_321_getDirectionAngle,"objects.Projectile","getDirectionAngle",0x542b2c7f,"objects.Projectile.getDirectionAngle","objects/Projectile.hx",321,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_20_boot,"objects.Projectile","boot",0x3c005d1d,"objects.Projectile.boot","objects/Projectile.hx",20,0xd573e69a)
HX_LOCAL_STACK_FRAME(_hx_pos_e39d53222c569c3d_21_boot,"objects.Projectile","boot",0x3c005d1d,"objects.Projectile.boot","objects/Projectile.hx",21,0xd573e69a)
namespace objects{

void Projectile_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_e39d53222c569c3d_19_new)
HXLINE(  44)		this->phase = ((Float)0.0);
HXLINE(  43)		this->bIdMod4Flip = 0;
HXLINE(  42)		this->bIdMod2Flip = 0;
HXLINE(  41)		this->prevDirAngle = ((Float)0.0);
HXLINE(  40)		this->cosAngle = ((Float)0.0);
HXLINE(  39)		this->sinAngle = ((Float)0.0);
HXLINE(  38)		this->angle = ((Float)0.0);
HXLINE(  37)		this->startTime = 0;
HXLINE(  36)		this->startY = ((Float)0.0);
HXLINE(  35)		this->startX = ((Float)0.0);
HXLINE(  34)		this->sound = HX_("",00,00,00,00);
HXLINE(  33)		this->trueDamage = 0;
HXLINE(  32)		this->magicDamage = 0;
HXLINE(  31)		this->physicalDamage = 0;
HXLINE(  30)		this->damagesPlayers = false;
HXLINE(  29)		this->damagesEnemies = false;
HXLINE(  28)		this->bulletType = 0;
HXLINE(  27)		this->containerType = 0;
HXLINE(  26)		this->bulletId = 0;
HXLINE(  69)		super::__construct(null(),HX_("Projectile",09,8a,3c,bb));
HXLINE(  70)		this->staticPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            	}

Dynamic Projectile_obj::__CreateEmpty() { return new Projectile_obj; }

void *Projectile_obj::_hx_vtable = 0;

Dynamic Projectile_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Projectile_obj > _hx_result = new Projectile_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Projectile_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0cff6b45) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0cff6b45;
	} else {
		return inClassId==(int)0x79d588dd;
	}
}

bool Projectile_obj::addTo( ::map::Map map,float x,float y){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_73_addTo)
HXLINE(  74)		this->startX = ( (Float)(x) );
HXLINE(  75)		this->startY = ( (Float)(y) );
HXLINE(  76)		return this->super::addTo(map,x,y);
            	}


void Projectile_obj::removeFromMap(){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_79_removeFromMap)
HXLINE(  80)		this->super::removeFromMap();
HXLINE(  81)		::objects::Projectile_obj::objBullIdToObjId->remove(((this->bulletId << 24) | this->ownerId));
HXLINE(  82)		::Global_obj::projPool->release(::hx::ObjectPtr<OBJ_>(this));
HXLINE(  83)		if (::hx::IsNotNull( this->multiHitDict )) {
HXLINE(  84)			this->multiHitDict->clear();
HXLINE(  85)			this->multiHitDict = null();
            		}
            	}


bool Projectile_obj::update(int time,short dt){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_89_update)
HXLINE(  90)		 ::objects::Player player = null();
HXLINE(  91)		bool isPlayer = false;
HXLINE(  92)		bool isTargetAnEnemy = false;
HXLINE(  93)		bool sendMessage = false;
HXLINE(  94)		bool dead = false;
HXLINE(  95)		int elapsed = (time - this->startTime);
HXLINE(  96)		if ((elapsed > this->projProps->lifetime)) {
HXLINE(  97)			return false;
            		}
HXLINE(  99)		 ::openfl::geom::Point p = this->positionAt(elapsed);
HXLINE( 100)		bool _hx_tmp;
HXDLIN( 100)		if (this->moveTo(( (float)(p->x) ),( (float)(p->y) ))) {
HXLINE( 100)			if (::hx::IsNotNull( this->curSquare )) {
HXLINE( 100)				_hx_tmp = (this->curSquare->tileType == 255);
            			}
            			else {
HXLINE( 100)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 100)			_hx_tmp = true;
            		}
HXDLIN( 100)		if (_hx_tmp) {
HXLINE( 106)			return false;
            		}
HXLINE( 109)		bool _hx_tmp1;
HXDLIN( 109)		bool _hx_tmp2;
HXDLIN( 109)		 ::map::Square tmp = this->curSquare;
HXDLIN( 109)		 ::objects::GameObject _hx_tmp3;
HXDLIN( 109)		if (::hx::IsNotNull( tmp )) {
HXLINE( 109)			_hx_tmp3 = tmp->obj;
            		}
            		else {
HXLINE( 109)			_hx_tmp3 = null();
            		}
HXDLIN( 109)		if (::hx::IsNotNull( _hx_tmp3 )) {
HXLINE( 110)			if (this->curSquare->obj->props->isEnemy) {
HXLINE( 109)				_hx_tmp2 = !(this->damagesEnemies);
            			}
            			else {
HXLINE( 109)				_hx_tmp2 = true;
            			}
            		}
            		else {
HXLINE( 109)			_hx_tmp2 = false;
            		}
HXDLIN( 109)		if (_hx_tmp2) {
HXLINE( 111)			if (!(this->curSquare->obj->props->enemyOccupySquare)) {
HXLINE( 109)				_hx_tmp1 = this->curSquare->obj->props->occupySquare;
            			}
            			else {
HXLINE( 109)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 109)			_hx_tmp1 = false;
            		}
HXDLIN( 109)		if (_hx_tmp1) {
HXLINE( 117)			return false;
            		}
HXLINE( 120)		 ::objects::GameObject target = this->getHit(( (float)(p->x) ),( (float)(p->y) ));
HXLINE( 121)		if (::hx::IsNotNull( target )) {
HXLINE( 122)			player = this->map->player;
HXLINE( 123)			isPlayer = ::hx::IsNotNull( player );
HXLINE( 124)			isTargetAnEnemy = target->props->isEnemy;
HXLINE( 125)			if (isPlayer) {
HXLINE( 125)				if (!(this->damagesPlayers)) {
HXLINE( 125)					if (isTargetAnEnemy) {
HXLINE( 125)						sendMessage = (this->ownerId == player->objectId);
            					}
            					else {
HXLINE( 125)						sendMessage = false;
            					}
            				}
            				else {
HXLINE( 125)					sendMessage = true;
            				}
            			}
            			else {
HXLINE( 125)				sendMessage = false;
            			}
HXLINE( 126)			if (sendMessage) {
HXLINE( 127)				int physDmg = ::objects::GameObject_obj::physicalDamage(this->physicalDamage,target->defense,target->condition);
HXLINE( 128)				int magicDmg = ::objects::GameObject_obj::magicDamage(this->magicDamage,target->resistance,target->condition);
HXLINE( 129)				int trueDmg = ::objects::GameObject_obj::trueDamage(this->trueDamage,target->condition);
HXLINE( 131)				if (::hx::IsInstanceEq( target,player )) {
HXLINE( 132)					::network::NetworkHandler_obj::playerHit(this->bulletId,this->ownerId);
HXLINE( 133)					if ((physDmg > 0)) {
HXLINE( 134)						int _hx_tmp4 = this->containerType;
HXDLIN( 134)						int _hx_tmp5 = ::Std_obj::_hx_int((( (Float)(physDmg) ) * player->hitMult));
HXDLIN( 134)						target->damage(_hx_tmp4,_hx_tmp5,this->projProps->effects,false,::hx::ObjectPtr<OBJ_>(this),11542560);
            					}
HXLINE( 135)					if ((magicDmg > 0)) {
HXLINE( 136)						int _hx_tmp6 = this->containerType;
HXDLIN( 136)						int _hx_tmp7 = ::Std_obj::_hx_int((( (Float)(magicDmg) ) * player->hitMult));
HXDLIN( 136)						target->damage(_hx_tmp6,_hx_tmp7,this->projProps->effects,false,::hx::ObjectPtr<OBJ_>(this),7214509);
            					}
HXLINE( 137)					if ((trueDmg > 0)) {
HXLINE( 138)						int _hx_tmp8 = this->containerType;
HXDLIN( 138)						int _hx_tmp9 = ::Std_obj::_hx_int((( (Float)(trueDmg) ) * player->hitMult));
HXDLIN( 138)						target->damage(_hx_tmp8,_hx_tmp9,this->projProps->effects,false,::hx::ObjectPtr<OBJ_>(this),12763842);
            					}
            				}
            				else {
HXLINE( 139)					if (target->props->isEnemy) {
HXLINE( 140)						dead = (target->hp <= ((physDmg + magicDmg) + trueDmg));
HXLINE( 141)						::network::NetworkHandler_obj::enemyHit(time,this->bulletId,target->objectId,dead);
HXLINE( 142)						if ((physDmg > 0)) {
HXLINE( 143)							target->damage(this->containerType,physDmg,this->projProps->effects,dead,::hx::ObjectPtr<OBJ_>(this),11542560);
            						}
HXLINE( 144)						if ((magicDmg > 0)) {
HXLINE( 145)							target->damage(this->containerType,magicDmg,this->projProps->effects,dead,::hx::ObjectPtr<OBJ_>(this),7214509);
            						}
HXLINE( 146)						if ((trueDmg > 0)) {
HXLINE( 147)							target->damage(this->containerType,trueDmg,this->projProps->effects,dead,::hx::ObjectPtr<OBJ_>(this),12763842);
            						}
            					}
            				}
            			}
HXLINE( 152)			if (this->projProps->multiHit) {
HXLINE( 153)				this->multiHitDict->set(target->objectId,true);
            			}
            			else {
HXLINE( 155)				return false;
            			}
            		}
HXLINE( 158)		return true;
            	}


void Projectile_obj::reset(int containerType,int bulletType,int ownerId,int bulletId,float angle,int startTime){
            	HX_GC_STACKFRAME(&_hx_pos_e39d53222c569c3d_161_reset)
HXLINE( 162)		this->map = null();
HXLINE( 163)		this->curSquare = null();
HXLINE( 164)		this->objectId = -1;
HXLINE( 165)		this->mapX = (this->mapY = ( (float)(0) ));
HXLINE( 166)		this->containerType = containerType;
HXLINE( 167)		this->bulletType = bulletType;
HXLINE( 168)		this->ownerId = ownerId;
HXLINE( 169)		this->bulletId = bulletId;
HXLINE( 170)		int _hx_tmp;
HXDLIN( 170)		if (((this->bulletId & 1) == 0)) {
HXLINE( 170)			_hx_tmp = 1;
            		}
            		else {
HXLINE( 170)			_hx_tmp = -1;
            		}
HXDLIN( 170)		this->bIdMod2Flip = _hx_tmp;
HXLINE( 171)		int _hx_tmp1;
HXDLIN( 171)		if (((this->bulletId & 3) < 2)) {
HXLINE( 171)			_hx_tmp1 = 1;
            		}
            		else {
HXLINE( 171)			_hx_tmp1 = -1;
            		}
HXDLIN( 171)		this->bIdMod4Flip = _hx_tmp1;
HXLINE( 172)		Float _hx_tmp2;
HXDLIN( 172)		if (((this->bulletId & 1) == 0)) {
HXLINE( 172)			_hx_tmp2 = ( (Float)(0) );
            		}
            		else {
HXLINE( 172)			_hx_tmp2 = ( (Float)(( (float)(((Float)3.141592653589793)) )) );
            		}
HXDLIN( 172)		this->phase = _hx_tmp2;
HXLINE( 173)		this->angle = ( (Float)(::hx::Mod(angle,(( (float)(((Float)3.141592653589793)) ) * ( (float)(2) )))) );
HXLINE( 174)		this->sinAngle = ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(( (float)(this->angle) )) ) * ((Float)10430.3783504704534))) & 65535)]) );
HXLINE( 175)		this->cosAngle = ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round(((( (float)(this->angle) ) + ((Float)1.57079632679489656)) * ((Float)10430.3783504704534))) & 65535)]) );
HXLINE( 176)		this->startTime = startTime;
HXLINE( 177)		int objId = ((int)2130706432 | ::objects::Projectile_obj::nextFakeObjectId++);
HXDLIN( 177)		::objects::Projectile_obj::objBullIdToObjId->set(((this->bulletId << 24) | this->ownerId),objId);
HXDLIN( 177)		this->objectId = objId;
HXLINE( 178)		this->containerProps = ( ( ::objects::ObjectProperties)(::objects::ObjectLibrary_obj::propsLibrary->get(this->containerType)) );
HXLINE( 179)		this->projProps = ( ( ::objects::ProjectileProperties)(this->containerProps->projectiles->get(bulletType)) );
HXLINE( 180)		this->props = ::objects::ObjectLibrary_obj::getPropsFromId(this->projProps->objectId);
HXLINE( 181)		 ::objects::TextureData textureData = ( ( ::objects::TextureData)(::objects::ObjectLibrary_obj::typeToTextureData->get(this->props->objType)) );
HXLINE( 182)		this->texture = textureData->getTexture(this->objectId);
HXLINE( 183)		this->uValue = textureData->uValue;
HXLINE( 184)		this->vValue = textureData->vValue;
HXLINE( 185)		this->width = textureData->width;
HXLINE( 186)		this->height = textureData->height;
HXLINE( 187)		this->colors = ::util::BloodComposition_obj::getColors(this->texture);
HXLINE( 188)		this->damagesPlayers = this->containerProps->isEnemy;
HXLINE( 189)		this->damagesEnemies = !(this->damagesPlayers);
HXLINE( 190)		this->sound = this->containerProps->oldSound;
HXLINE( 191)		 ::haxe::ds::IntMap _hx_tmp3;
HXDLIN( 191)		if (this->projProps->multiHit) {
HXLINE( 191)			_hx_tmp3 =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            		}
            		else {
HXLINE( 191)			_hx_tmp3 = null();
            		}
HXDLIN( 191)		this->multiHitDict = _hx_tmp3;
HXLINE( 192)		if ((this->projProps->size >= 0)) {
HXLINE( 193)			this->size = ( (float)((( (Float)(this->projProps->size) ) / ( (Float)(100) ))) );
            		}
            		else {
HXLINE( 195)			this->size = ( (float)((( (Float)(::objects::ObjectLibrary_obj::getSizeFromType(this->containerType)) ) / ( (Float)(100) ))) );
            		}
HXLINE( 196)		this->physicalDamage = (this->magicDamage = (this->trueDamage = 0));
            	}


HX_DEFINE_DYNAMIC_FUNC6(Projectile_obj,reset,(void))

void Projectile_obj::setDamages(int physicalDmg,int magicDmg,int trueDmg){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_199_setDamages)
HXLINE( 200)		this->physicalDamage = physicalDmg;
HXLINE( 201)		this->magicDamage = magicDmg;
HXLINE( 202)		this->trueDamage = trueDmg;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Projectile_obj,setDamages,(void))

bool Projectile_obj::moveTo(float x,float y){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_205_moveTo)
HXLINE( 206)		this->mapX = x;
HXLINE( 207)		this->mapY = y;
HXLINE( 208)		 ::map::Map _hx_tmp = this->map;
HXDLIN( 208)		int _hx_tmp1 = ::Std_obj::_hx_int(( (Float)(x) ));
HXDLIN( 208)		this->curSquare = _hx_tmp->lookupSquare(( (unsigned short)(_hx_tmp1) ),( (unsigned short)(::Std_obj::_hx_int(( (Float)(y) ))) ));
HXLINE( 209)		return ::hx::IsNotNull( this->curSquare );
            	}


 ::objects::GameObject Projectile_obj::getHit(float pX,float pY){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_212_getHit)
HXLINE( 213)		Float distSqr = ((Float)0.0);
HXLINE( 214)		float minDistSqr = ( (float)(((Float)3.4028235E+38)) );
HXLINE( 215)		 ::objects::GameObject target = null();
HXLINE( 217)		int i = 0;
HXLINE( 218)		if (this->damagesEnemies) {
HXLINE( 219)			while((i < this->map->gameObjectsLen)){
HXLINE( 220)				 ::objects::GameObject go = this->map->gameObjects->__unsafe_get(i).StaticCast<  ::objects::GameObject >();
HXLINE( 221)				if (!(go->props->isEnemy)) {
HXLINE( 222)					i = (i + 1);
HXLINE( 223)					continue;
            				}
HXLINE( 226)				Float dX = (( (Float)(pX) ) - ( (Float)(go->mapX) ));
HXDLIN( 226)				Float dY = (( (Float)(pY) ) - ( (Float)(go->mapY) ));
HXDLIN( 226)				distSqr = ((dX * dX) + (dY * dY));
HXLINE( 227)				bool _hx_tmp;
HXDLIN( 227)				bool _hx_tmp1;
HXDLIN( 227)				if ((distSqr < ((Float)0.33))) {
HXLINE( 227)					_hx_tmp1 = (distSqr < minDistSqr);
            				}
            				else {
HXLINE( 227)					_hx_tmp1 = false;
            				}
HXDLIN( 227)				if (_hx_tmp1) {
HXLINE( 227)					if (this->projProps->multiHit) {
HXLINE( 227)						_hx_tmp = !(this->multiHitDict->exists(go->objectId));
            					}
            					else {
HXLINE( 227)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 227)					_hx_tmp = false;
            				}
HXDLIN( 227)				if (_hx_tmp) {
HXLINE( 228)					minDistSqr = ( (float)(distSqr) );
HXLINE( 229)					target = go;
            				}
HXLINE( 231)				i = (i + 1);
            			}
            		}
            		else {
HXLINE( 233)			if (this->damagesPlayers) {
HXLINE( 234)				while((i < this->map->gameObjectsLen)){
HXLINE( 235)					 ::objects::GameObject go1 = this->map->gameObjects->__unsafe_get(i).StaticCast<  ::objects::GameObject >();
HXLINE( 236)					if (!(go1->props->isPlayer)) {
HXLINE( 237)						i = (i + 1);
HXLINE( 238)						continue;
            					}
HXLINE( 240)					 ::objects::Player player = ( ( ::objects::Player)(go1) );
HXLINE( 241)					Float dX1 = (( (Float)(pX) ) - ( (Float)(player->mapX) ));
HXDLIN( 241)					Float dY1 = (( (Float)(pY) ) - ( (Float)(player->mapY) ));
HXDLIN( 241)					distSqr = ((dX1 * dX1) + (dY1 * dY1));
HXLINE( 242)					bool _hx_tmp2;
HXDLIN( 242)					if ((distSqr < ((Float)0.33))) {
HXLINE( 242)						if (this->projProps->multiHit) {
HXLINE( 242)							_hx_tmp2 = !(this->multiHitDict->exists(player->objectId));
            						}
            						else {
HXLINE( 242)							_hx_tmp2 = true;
            						}
            					}
            					else {
HXLINE( 242)						_hx_tmp2 = false;
            					}
HXDLIN( 242)					if (_hx_tmp2) {
HXLINE( 243)						if ((player->objectId == this->map->player->objectId)) {
HXLINE( 244)							return player;
            						}
HXLINE( 246)						if ((distSqr < minDistSqr)) {
HXLINE( 247)							minDistSqr = ( (float)(distSqr) );
HXLINE( 248)							target = ::hx::TCast<  ::objects::GameObject >::cast(player);
            						}
            					}
HXLINE( 251)					i = (i + 1);
            				}
            			}
            		}
HXLINE( 255)		return target;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Projectile_obj,getHit,return )

 ::openfl::geom::Point Projectile_obj::positionAt(int elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_e39d53222c569c3d_258_positionAt)
HXLINE( 261)		Float theta = ((Float)0.0);
HXLINE( 262)		Float t = ((Float)0.0);
HXLINE( 263)		Float x = ((Float)0.0);
HXLINE( 264)		Float y = ((Float)0.0);
HXLINE( 265)		Float halfway = ((Float)0.0);
HXLINE( 266)		Float deflection = ((Float)0.0);
HXLINE( 267)		 ::openfl::geom::Point p =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,this->startX,this->startY);
HXLINE( 268)		Float dist = ((Float)0.0);
HXDLIN( 268)		Float baseSpeed = this->projProps->speed;
HXLINE( 269)		bool _hx_tmp;
HXDLIN( 269)		if ((this->projProps->acceleration != 0)) {
HXLINE( 269)			_hx_tmp = (elapsed < this->projProps->accelerationDelay);
            		}
            		else {
HXLINE( 269)			_hx_tmp = true;
            		}
HXDLIN( 269)		if (_hx_tmp) {
HXLINE( 270)			dist = (( (Float)(elapsed) ) * baseSpeed);
            		}
            		else {
HXLINE( 272)			int timeTillMaxSpeed = 0;
HXLINE( 273)			int timeClamped = 0;
HXDLIN( 273)			Float clampedSpeed = ((Float)0.0);
HXLINE( 274)			if ((this->projProps->speedClamp != -1)) {
HXLINE( 275)				clampedSpeed = (( (Float)(this->projProps->speedClamp) ) / ((Float)10000.0));
HXLINE( 277)				timeTillMaxSpeed = ::Std_obj::_hx_int((::Math_obj::abs(( (Float)((this->projProps->speedClamp - this->projProps->realSpeed)) )) / (::Math_obj::abs(this->projProps->acceleration) * ((Float)10000.0))));
HXLINE( 278)				timeTillMaxSpeed = ::Std_obj::_hx_int(::Math_obj::min(( (Float)((elapsed - this->projProps->accelerationDelay)) ),( (Float)(timeTillMaxSpeed) )));
HXLINE( 279)				if ((((elapsed - this->projProps->accelerationDelay) - timeTillMaxSpeed) > 0)) {
HXLINE( 280)					timeClamped = ((elapsed - this->projProps->accelerationDelay) - timeTillMaxSpeed);
            				}
            			}
            			else {
HXLINE( 282)				timeTillMaxSpeed = (this->projProps->lifetime - this->projProps->accelerationDelay);
            			}
HXLINE( 283)			dist = ((((( (Float)(this->projProps->accelerationDelay) ) * baseSpeed) + (( (Float)(timeTillMaxSpeed) ) * baseSpeed)) + ((( (Float)((timeTillMaxSpeed * timeTillMaxSpeed)) ) / ((Float)2000.0)) * (this->projProps->acceleration / ((Float)1000.0)))) + (( (Float)(timeClamped) ) * clampedSpeed));
            		}
HXLINE( 289)		if (this->projProps->wavy) {
HXLINE( 292)			theta = (this->angle + (((Float)0.0490873852123405174) * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(( (float)((this->phase + ((((Float)18.8495559215387587) * ( (Float)(elapsed) )) / ( (Float)(1000) )))) )) ) * ((Float)10430.3783504704534))) & 65535)]) )));
HXLINE( 293)			p->x = (p->x + (dist * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round(((theta + ((Float)1.57079632679489656)) * ((Float)10430.3783504704534))) & 65535)]) )));
HXLINE( 294)			p->y = (p->y + (dist * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((theta * ((Float)10430.3783504704534))) & 65535)]) )));
            		}
            		else {
HXLINE( 295)			if (this->projProps->parametric) {
HXLINE( 296)				t = (((( (Float)(elapsed) ) / ( (Float)(this->projProps->lifetime) )) * ( (Float)(2) )) * ( (Float)(( (float)(((Float)3.141592653589793)) )) ));
HXLINE( 297)				x = ( (Float)((::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((t * ((Float)10430.3783504704534))) & 65535)] * ( (float)(this->bIdMod2Flip) ))) );
HXLINE( 298)				y = ( (Float)((::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round(((( (Float)(2) ) * t) * ((Float)10430.3783504704534))) & 65535)] * ( (float)(this->bIdMod4Flip) ))) );
HXLINE( 299)				p->x = (p->x + (((x * this->cosAngle) - (y * this->sinAngle)) * this->projProps->magnitude));
HXLINE( 300)				p->y = (p->y + (((x * this->sinAngle) + (y * this->cosAngle)) * this->projProps->magnitude));
            			}
            			else {
HXLINE( 302)				if (this->projProps->boomerang) {
HXLINE( 304)					halfway = (( (Float)(this->projProps->lifetime) ) * (this->projProps->speed / ( (Float)(2) )));
HXLINE( 305)					if ((dist > halfway)) {
HXLINE( 306)						dist = (halfway - (dist - halfway));
            					}
            				}
HXLINE( 308)				p->x = (p->x + (dist * this->cosAngle));
HXLINE( 309)				p->y = (p->y + (dist * this->sinAngle));
HXLINE( 310)				if ((this->projProps->amplitude != 0)) {
HXLINE( 311)					deflection = (this->projProps->amplitude * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(( (float)((this->phase + ((((( (Float)(elapsed) ) / ( (Float)(this->projProps->lifetime) )) * this->projProps->frequency) * ( (Float)(2) )) * ( (Float)(( (float)(((Float)3.141592653589793)) )) )))) )) ) * ((Float)10430.3783504704534))) & 65535)]) ));
HXLINE( 313)					p->x = (p->x + (deflection * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round(((( (float)((this->angle + ((Float)1.57079632679489656))) ) + ((Float)1.57079632679489656)) * ((Float)10430.3783504704534))) & 65535)]) )));
HXLINE( 314)					p->y = (p->y + (deflection * ( (Float)(::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(( (float)((this->angle + ((Float)1.57079632679489656))) )) ) * ((Float)10430.3783504704534))) & 65535)]) )));
            				}
            			}
            		}
HXLINE( 318)		return p;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Projectile_obj,positionAt,return )

Float Projectile_obj::getDirectionAngle(int time){
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_321_getDirectionAngle)
HXLINE( 323)		 ::openfl::geom::Point futurePos = this->positionAt(((time - this->startTime) + 16));
HXLINE( 325)		Float xDelta = (futurePos->x - ( (Float)(this->mapX) ));
HXLINE( 326)		Float yDelta = (futurePos->y - ( (Float)(this->mapY) ));
HXLINE( 327)		bool _hx_tmp;
HXDLIN( 327)		if ((xDelta == 0)) {
HXLINE( 327)			_hx_tmp = (yDelta == 0);
            		}
            		else {
HXLINE( 327)			_hx_tmp = false;
            		}
HXDLIN( 327)		if (_hx_tmp) {
HXLINE( 328)			return this->prevDirAngle;
            		}
HXLINE( 330)		Float angle = ::Math_obj::atan2(yDelta,xDelta);
HXLINE( 331)		this->prevDirAngle = angle;
HXLINE( 332)		return angle;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Projectile_obj,getDirectionAngle,return )

 ::haxe::ds::IntMap Projectile_obj::objBullIdToObjId;

int Projectile_obj::nextFakeObjectId;


::hx::ObjectPtr< Projectile_obj > Projectile_obj::__new() {
	::hx::ObjectPtr< Projectile_obj > __this = new Projectile_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< Projectile_obj > Projectile_obj::__alloc(::hx::Ctx *_hx_ctx) {
	Projectile_obj *__this = (Projectile_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Projectile_obj), true, "objects.Projectile"));
	*(void **)__this = Projectile_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Projectile_obj::Projectile_obj()
{
}

void Projectile_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Projectile);
	HX_MARK_MEMBER_NAME(containerProps,"containerProps");
	HX_MARK_MEMBER_NAME(projProps,"projProps");
	HX_MARK_MEMBER_NAME(texture,"texture");
	HX_MARK_MEMBER_NAME(bulletId,"bulletId");
	HX_MARK_MEMBER_NAME(containerType,"containerType");
	HX_MARK_MEMBER_NAME(bulletType,"bulletType");
	HX_MARK_MEMBER_NAME(damagesEnemies,"damagesEnemies");
	HX_MARK_MEMBER_NAME(damagesPlayers,"damagesPlayers");
	HX_MARK_MEMBER_NAME(physicalDamage,"physicalDamage");
	HX_MARK_MEMBER_NAME(magicDamage,"magicDamage");
	HX_MARK_MEMBER_NAME(trueDamage,"trueDamage");
	HX_MARK_MEMBER_NAME(sound,"sound");
	HX_MARK_MEMBER_NAME(startX,"startX");
	HX_MARK_MEMBER_NAME(startY,"startY");
	HX_MARK_MEMBER_NAME(startTime,"startTime");
	HX_MARK_MEMBER_NAME(angle,"angle");
	HX_MARK_MEMBER_NAME(sinAngle,"sinAngle");
	HX_MARK_MEMBER_NAME(cosAngle,"cosAngle");
	HX_MARK_MEMBER_NAME(prevDirAngle,"prevDirAngle");
	HX_MARK_MEMBER_NAME(bIdMod2Flip,"bIdMod2Flip");
	HX_MARK_MEMBER_NAME(bIdMod4Flip,"bIdMod4Flip");
	HX_MARK_MEMBER_NAME(phase,"phase");
	HX_MARK_MEMBER_NAME(colors,"colors");
	HX_MARK_MEMBER_NAME(multiHitDict,"multiHitDict");
	HX_MARK_MEMBER_NAME(staticPoint,"staticPoint");
	 ::objects::GameObject_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Projectile_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(containerProps,"containerProps");
	HX_VISIT_MEMBER_NAME(projProps,"projProps");
	HX_VISIT_MEMBER_NAME(texture,"texture");
	HX_VISIT_MEMBER_NAME(bulletId,"bulletId");
	HX_VISIT_MEMBER_NAME(containerType,"containerType");
	HX_VISIT_MEMBER_NAME(bulletType,"bulletType");
	HX_VISIT_MEMBER_NAME(damagesEnemies,"damagesEnemies");
	HX_VISIT_MEMBER_NAME(damagesPlayers,"damagesPlayers");
	HX_VISIT_MEMBER_NAME(physicalDamage,"physicalDamage");
	HX_VISIT_MEMBER_NAME(magicDamage,"magicDamage");
	HX_VISIT_MEMBER_NAME(trueDamage,"trueDamage");
	HX_VISIT_MEMBER_NAME(sound,"sound");
	HX_VISIT_MEMBER_NAME(startX,"startX");
	HX_VISIT_MEMBER_NAME(startY,"startY");
	HX_VISIT_MEMBER_NAME(startTime,"startTime");
	HX_VISIT_MEMBER_NAME(angle,"angle");
	HX_VISIT_MEMBER_NAME(sinAngle,"sinAngle");
	HX_VISIT_MEMBER_NAME(cosAngle,"cosAngle");
	HX_VISIT_MEMBER_NAME(prevDirAngle,"prevDirAngle");
	HX_VISIT_MEMBER_NAME(bIdMod2Flip,"bIdMod2Flip");
	HX_VISIT_MEMBER_NAME(bIdMod4Flip,"bIdMod4Flip");
	HX_VISIT_MEMBER_NAME(phase,"phase");
	HX_VISIT_MEMBER_NAME(colors,"colors");
	HX_VISIT_MEMBER_NAME(multiHitDict,"multiHitDict");
	HX_VISIT_MEMBER_NAME(staticPoint,"staticPoint");
	 ::objects::GameObject_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Projectile_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"sound") ) { return ::hx::Val( sound ); }
		if (HX_FIELD_EQ(inName,"angle") ) { return ::hx::Val( angle ); }
		if (HX_FIELD_EQ(inName,"phase") ) { return ::hx::Val( phase ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"startX") ) { return ::hx::Val( startX ); }
		if (HX_FIELD_EQ(inName,"startY") ) { return ::hx::Val( startY ); }
		if (HX_FIELD_EQ(inName,"colors") ) { return ::hx::Val( colors ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"getHit") ) { return ::hx::Val( getHit_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { return ::hx::Val( texture ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"bulletId") ) { return ::hx::Val( bulletId ); }
		if (HX_FIELD_EQ(inName,"sinAngle") ) { return ::hx::Val( sinAngle ); }
		if (HX_FIELD_EQ(inName,"cosAngle") ) { return ::hx::Val( cosAngle ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"projProps") ) { return ::hx::Val( projProps ); }
		if (HX_FIELD_EQ(inName,"startTime") ) { return ::hx::Val( startTime ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bulletType") ) { return ::hx::Val( bulletType ); }
		if (HX_FIELD_EQ(inName,"trueDamage") ) { return ::hx::Val( trueDamage ); }
		if (HX_FIELD_EQ(inName,"setDamages") ) { return ::hx::Val( setDamages_dyn() ); }
		if (HX_FIELD_EQ(inName,"positionAt") ) { return ::hx::Val( positionAt_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"magicDamage") ) { return ::hx::Val( magicDamage ); }
		if (HX_FIELD_EQ(inName,"bIdMod2Flip") ) { return ::hx::Val( bIdMod2Flip ); }
		if (HX_FIELD_EQ(inName,"bIdMod4Flip") ) { return ::hx::Val( bIdMod4Flip ); }
		if (HX_FIELD_EQ(inName,"staticPoint") ) { return ::hx::Val( staticPoint ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"prevDirAngle") ) { return ::hx::Val( prevDirAngle ); }
		if (HX_FIELD_EQ(inName,"multiHitDict") ) { return ::hx::Val( multiHitDict ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"containerType") ) { return ::hx::Val( containerType ); }
		if (HX_FIELD_EQ(inName,"removeFromMap") ) { return ::hx::Val( removeFromMap_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"containerProps") ) { return ::hx::Val( containerProps ); }
		if (HX_FIELD_EQ(inName,"damagesEnemies") ) { return ::hx::Val( damagesEnemies ); }
		if (HX_FIELD_EQ(inName,"damagesPlayers") ) { return ::hx::Val( damagesPlayers ); }
		if (HX_FIELD_EQ(inName,"physicalDamage") ) { return ::hx::Val( physicalDamage ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getDirectionAngle") ) { return ::hx::Val( getDirectionAngle_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Projectile_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 16:
		if (HX_FIELD_EQ(inName,"objBullIdToObjId") ) { outValue = ( objBullIdToObjId ); return true; }
		if (HX_FIELD_EQ(inName,"nextFakeObjectId") ) { outValue = ( nextFakeObjectId ); return true; }
	}
	return false;
}

::hx::Val Projectile_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"sound") ) { sound=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle") ) { angle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"phase") ) { phase=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"startX") ) { startX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"startY") ) { startY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colors") ) { colors=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { texture=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"bulletId") ) { bulletId=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sinAngle") ) { sinAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"cosAngle") ) { cosAngle=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"projProps") ) { projProps=inValue.Cast<  ::objects::ProjectileProperties >(); return inValue; }
		if (HX_FIELD_EQ(inName,"startTime") ) { startTime=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"bulletType") ) { bulletType=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"trueDamage") ) { trueDamage=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"magicDamage") ) { magicDamage=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bIdMod2Flip") ) { bIdMod2Flip=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bIdMod4Flip") ) { bIdMod4Flip=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"staticPoint") ) { staticPoint=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"prevDirAngle") ) { prevDirAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"multiHitDict") ) { multiHitDict=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"containerType") ) { containerType=inValue.Cast< int >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"containerProps") ) { containerProps=inValue.Cast<  ::objects::ObjectProperties >(); return inValue; }
		if (HX_FIELD_EQ(inName,"damagesEnemies") ) { damagesEnemies=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"damagesPlayers") ) { damagesPlayers=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"physicalDamage") ) { physicalDamage=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Projectile_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 16:
		if (HX_FIELD_EQ(inName,"objBullIdToObjId") ) { objBullIdToObjId=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		if (HX_FIELD_EQ(inName,"nextFakeObjectId") ) { nextFakeObjectId=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Projectile_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("containerProps",6f,36,d4,79));
	outFields->push(HX_("projProps",93,d6,74,87));
	outFields->push(HX_("texture",db,c8,e0,9e));
	outFields->push(HX_("bulletId",bd,66,8b,87));
	outFields->push(HX_("containerType",9b,c8,bf,7b));
	outFields->push(HX_("bulletType",1c,fa,95,15));
	outFields->push(HX_("damagesEnemies",e2,eb,a9,35));
	outFields->push(HX_("damagesPlayers",2e,8d,b0,ec));
	outFields->push(HX_("physicalDamage",e6,95,f7,74));
	outFields->push(HX_("magicDamage",7c,15,03,77));
	outFields->push(HX_("trueDamage",5d,1a,be,ef));
	outFields->push(HX_("sound",cf,8c,cc,80));
	outFields->push(HX_("startX",b6,61,fa,05));
	outFields->push(HX_("startY",b7,61,fa,05));
	outFields->push(HX_("startTime",8f,45,f0,05));
	outFields->push(HX_("angle",d3,43,e2,22));
	outFields->push(HX_("sinAngle",9b,5d,48,71));
	outFields->push(HX_("cosAngle",0c,d2,6a,d7));
	outFields->push(HX_("prevDirAngle",59,45,e6,c9));
	outFields->push(HX_("bIdMod2Flip",fa,67,f9,c0));
	outFields->push(HX_("bIdMod4Flip",fc,90,c6,e7));
	outFields->push(HX_("phase",3b,28,e9,c1));
	outFields->push(HX_("colors",b0,c5,86,c6));
	outFields->push(HX_("multiHitDict",f0,bf,e7,b3));
	outFields->push(HX_("staticPoint",c2,90,5c,db));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Projectile_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::objects::ObjectProperties */ ,(int)offsetof(Projectile_obj,containerProps),HX_("containerProps",6f,36,d4,79)},
	{::hx::fsObject /*  ::objects::ProjectileProperties */ ,(int)offsetof(Projectile_obj,projProps),HX_("projProps",93,d6,74,87)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(Projectile_obj,texture),HX_("texture",db,c8,e0,9e)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,bulletId),HX_("bulletId",bd,66,8b,87)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,containerType),HX_("containerType",9b,c8,bf,7b)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,bulletType),HX_("bulletType",1c,fa,95,15)},
	{::hx::fsBool,(int)offsetof(Projectile_obj,damagesEnemies),HX_("damagesEnemies",e2,eb,a9,35)},
	{::hx::fsBool,(int)offsetof(Projectile_obj,damagesPlayers),HX_("damagesPlayers",2e,8d,b0,ec)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,physicalDamage),HX_("physicalDamage",e6,95,f7,74)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,magicDamage),HX_("magicDamage",7c,15,03,77)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,trueDamage),HX_("trueDamage",5d,1a,be,ef)},
	{::hx::fsString,(int)offsetof(Projectile_obj,sound),HX_("sound",cf,8c,cc,80)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,startX),HX_("startX",b6,61,fa,05)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,startY),HX_("startY",b7,61,fa,05)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,startTime),HX_("startTime",8f,45,f0,05)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,angle),HX_("angle",d3,43,e2,22)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,sinAngle),HX_("sinAngle",9b,5d,48,71)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,cosAngle),HX_("cosAngle",0c,d2,6a,d7)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,prevDirAngle),HX_("prevDirAngle",59,45,e6,c9)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,bIdMod2Flip),HX_("bIdMod2Flip",fa,67,f9,c0)},
	{::hx::fsInt,(int)offsetof(Projectile_obj,bIdMod4Flip),HX_("bIdMod4Flip",fc,90,c6,e7)},
	{::hx::fsFloat,(int)offsetof(Projectile_obj,phase),HX_("phase",3b,28,e9,c1)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(Projectile_obj,colors),HX_("colors",b0,c5,86,c6)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(Projectile_obj,multiHitDict),HX_("multiHitDict",f0,bf,e7,b3)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(Projectile_obj,staticPoint),HX_("staticPoint",c2,90,5c,db)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Projectile_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(void *) &Projectile_obj::objBullIdToObjId,HX_("objBullIdToObjId",92,bd,49,ca)},
	{::hx::fsInt,(void *) &Projectile_obj::nextFakeObjectId,HX_("nextFakeObjectId",c2,b2,4a,fe)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Projectile_obj_sMemberFields[] = {
	HX_("containerProps",6f,36,d4,79),
	HX_("projProps",93,d6,74,87),
	HX_("texture",db,c8,e0,9e),
	HX_("bulletId",bd,66,8b,87),
	HX_("containerType",9b,c8,bf,7b),
	HX_("bulletType",1c,fa,95,15),
	HX_("damagesEnemies",e2,eb,a9,35),
	HX_("damagesPlayers",2e,8d,b0,ec),
	HX_("physicalDamage",e6,95,f7,74),
	HX_("magicDamage",7c,15,03,77),
	HX_("trueDamage",5d,1a,be,ef),
	HX_("sound",cf,8c,cc,80),
	HX_("startX",b6,61,fa,05),
	HX_("startY",b7,61,fa,05),
	HX_("startTime",8f,45,f0,05),
	HX_("angle",d3,43,e2,22),
	HX_("sinAngle",9b,5d,48,71),
	HX_("cosAngle",0c,d2,6a,d7),
	HX_("prevDirAngle",59,45,e6,c9),
	HX_("bIdMod2Flip",fa,67,f9,c0),
	HX_("bIdMod4Flip",fc,90,c6,e7),
	HX_("phase",3b,28,e9,c1),
	HX_("colors",b0,c5,86,c6),
	HX_("multiHitDict",f0,bf,e7,b3),
	HX_("staticPoint",c2,90,5c,db),
	HX_("removeFromMap",6e,37,b8,30),
	HX_("update",09,86,05,87),
	HX_("reset",cf,49,c8,e6),
	HX_("setDamages",a2,f5,f8,5c),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("getHit",5d,7f,1e,a3),
	HX_("positionAt",fc,15,63,77),
	HX_("getDirectionAngle",4a,7c,1b,5a),
	::String(null()) };

static void Projectile_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Projectile_obj::objBullIdToObjId,"objBullIdToObjId");
	HX_MARK_MEMBER_NAME(Projectile_obj::nextFakeObjectId,"nextFakeObjectId");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Projectile_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Projectile_obj::objBullIdToObjId,"objBullIdToObjId");
	HX_VISIT_MEMBER_NAME(Projectile_obj::nextFakeObjectId,"nextFakeObjectId");
};

#endif

::hx::Class Projectile_obj::__mClass;

static ::String Projectile_obj_sStaticFields[] = {
	HX_("objBullIdToObjId",92,bd,49,ca),
	HX_("nextFakeObjectId",c2,b2,4a,fe),
	::String(null())
};

void Projectile_obj::__register()
{
	Projectile_obj _hx_dummy;
	Projectile_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.Projectile",63,2f,54,ac);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Projectile_obj::__GetStatic;
	__mClass->mSetStaticField = &Projectile_obj::__SetStatic;
	__mClass->mMarkFunc = Projectile_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Projectile_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Projectile_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Projectile_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Projectile_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Projectile_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Projectile_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Projectile_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_e39d53222c569c3d_20_boot)
HXDLIN(  20)		objBullIdToObjId =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_STACKFRAME(&_hx_pos_e39d53222c569c3d_21_boot)
HXDLIN(  21)		nextFakeObjectId = 0;
            	}
}

} // end namespace objects
