// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_objects_TextureData
#include <objects/TextureData.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_util_AnimatedChar
#include <util/AnimatedChar.h>
#endif
#ifndef INCLUDED_util_AnimatedChars
#include <util/AnimatedChars.h>
#endif
#ifndef INCLUDED_util_AssetLibrary
#include <util/AssetLibrary.h>
#endif
#ifndef INCLUDED_util_MaskedImage
#include <util/MaskedImage.h>
#endif
#ifndef INCLUDED_util_Rect
#include <util/Rect.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a07dcf344300cb23_14_new,"objects.TextureData","new",0xd532685d,"objects.TextureData.new","objects/TextureData.hx",14,0x2b2d3174)
HX_LOCAL_STACK_FRAME(_hx_pos_a07dcf344300cb23_50_getTexture,"objects.TextureData","getTexture",0xd94f6088,"objects.TextureData.getTexture","objects/TextureData.hx",50,0x2b2d3174)
HX_LOCAL_STACK_FRAME(_hx_pos_a07dcf344300cb23_59_getRect,"objects.TextureData","getRect",0xe800d757,"objects.TextureData.getRect","objects/TextureData.hx",59,0x2b2d3174)
HX_LOCAL_STACK_FRAME(_hx_pos_a07dcf344300cb23_68_getTextureData,"objects.TextureData","getTextureData",0x203ac6d2,"objects.TextureData.getTextureData","objects/TextureData.hx",68,0x2b2d3174)
HX_LOCAL_STACK_FRAME(_hx_pos_a07dcf344300cb23_77_getAltTextureData,"objects.TextureData","getAltTextureData",0x506d89ef,"objects.TextureData.getAltTextureData","objects/TextureData.hx",77,0x2b2d3174)
HX_LOCAL_STACK_FRAME(_hx_pos_a07dcf344300cb23_84_parse,"objects.TextureData","parse",0x7907e170,"objects.TextureData.parse","objects/TextureData.hx",84,0x2b2d3174)
namespace objects{

void TextureData_obj::__construct( ::Xml objectXML,::hx::Null< bool >  __o_forceTex){
            		bool forceTex = __o_forceTex.Default(false);
            	HX_STACKFRAME(&_hx_pos_a07dcf344300cb23_14_new)
HXLINE(  28)		this->maskHeight = ( (float)(((Float)0.0)) );
HXLINE(  27)		this->maskWidth = ( (float)(((Float)0.0)) );
HXLINE(  26)		this->maskVValue = ( (float)(((Float)0.0)) );
HXLINE(  25)		this->maskUValue = ( (float)(((Float)0.0)) );
HXLINE(  24)		this->height = ( (float)(((Float)0.0)) );
HXLINE(  23)		this->width = ( (float)(((Float)0.0)) );
HXLINE(  22)		this->vValue = ( (float)(((Float)0.0)) );
HXLINE(  21)		this->uValue = ( (float)(((Float)0.0)) );
HXLINE(  20)		this->rect = null();
HXLINE(  19)		this->altTextures = null();
HXLINE(  18)		this->randomTextureData = null();
HXLINE(  17)		this->animatedChar = null();
HXLINE(  16)		this->mask = null();
HXLINE(  15)		this->texture = null();
HXLINE(  31)		if (forceTex) {
HXLINE(  32)			this->parse(objectXML,HX_("Texture",bb,f0,31,6c));
HXLINE(  33)			return;
            		}
HXLINE(  36)		if (( (bool)(objectXML->elementsNamed(HX_("Texture",bb,f0,31,6c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  37)			this->parse(( ( ::Xml)(objectXML->elementsNamed(HX_("Texture",bb,f0,31,6c))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),HX_("Texture",bb,f0,31,6c));
            		}
            		else {
HXLINE(  38)			if (( (bool)(objectXML->elementsNamed(HX_("AnimatedTexture",58,70,fc,07))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  39)				this->parse(( ( ::Xml)(objectXML->elementsNamed(HX_("AnimatedTexture",58,70,fc,07))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),HX_("AnimatedTexture",58,70,fc,07));
            			}
            			else {
HXLINE(  40)				if (( (bool)(objectXML->elementsNamed(HX_("RandomTexture",f8,b4,32,fb))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  41)					this->parse(( ( ::Xml)(objectXML->elementsNamed(HX_("RandomTexture",f8,b4,32,fb))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),HX_("RandomTexture",f8,b4,32,fb));
            				}
            			}
            		}
HXLINE(  43)		{
HXLINE(  43)			 ::Dynamic altTexture = objectXML->elementsNamed(HX_("AltTexture",d2,62,ce,27));
HXDLIN(  43)			while(( (bool)(altTexture->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  44)				this->parse(( ( ::Xml)(altTexture->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),HX_("AltTexture",d2,62,ce,27));
            			}
            		}
HXLINE(  46)		if (( (bool)(objectXML->elementsNamed(HX_("Mask",0c,6d,2f,33))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  47)			this->parse(( ( ::Xml)(objectXML->elementsNamed(HX_("Mask",0c,6d,2f,33))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),HX_("Mask",0c,6d,2f,33));
            		}
            	}

Dynamic TextureData_obj::__CreateEmpty() { return new TextureData_obj; }

void *TextureData_obj::_hx_vtable = 0;

Dynamic TextureData_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TextureData_obj > _hx_result = new TextureData_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool TextureData_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0c07bdf9;
}

 ::openfl::display::BitmapData TextureData_obj::getTexture(::hx::Null< int >  __o_id){
            		int id = __o_id.Default(0);
            	HX_STACKFRAME(&_hx_pos_a07dcf344300cb23_50_getTexture)
HXLINE(  51)		if (::hx::IsNull( this->randomTextureData )) {
HXLINE(  52)			return this->texture;
            		}
HXLINE(  55)		int _hx_tmp;
HXDLIN(  55)		if ((id == -1)) {
HXLINE(  55)			_hx_tmp = ::Math_obj::floor((::Math_obj::random() * ( (Float)(this->randomTextureData->length) )));
            		}
            		else {
HXLINE(  55)			_hx_tmp = ::hx::Mod(id,this->randomTextureData->length);
            		}
HXLINE(  54)		return this->randomTextureData->__get(_hx_tmp).StaticCast<  ::objects::TextureData >()->texture;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TextureData_obj,getTexture,return )

 ::util::Rect TextureData_obj::getRect(::hx::Null< int >  __o_id){
            		int id = __o_id.Default(0);
            	HX_STACKFRAME(&_hx_pos_a07dcf344300cb23_59_getRect)
HXLINE(  60)		if (::hx::IsNull( this->randomTextureData )) {
HXLINE(  61)			return this->rect;
            		}
HXLINE(  64)		int _hx_tmp;
HXDLIN(  64)		if ((id == -1)) {
HXLINE(  64)			_hx_tmp = ::Math_obj::floor((::Math_obj::random() * ( (Float)(this->randomTextureData->length) )));
            		}
            		else {
HXLINE(  64)			_hx_tmp = ::hx::Mod(id,this->randomTextureData->length);
            		}
HXLINE(  63)		return this->randomTextureData->__get(_hx_tmp).StaticCast<  ::objects::TextureData >()->rect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(TextureData_obj,getRect,return )

 ::objects::TextureData TextureData_obj::getTextureData(::hx::Null< int >  __o_id){
            		int id = __o_id.Default(-1);
            	HX_STACKFRAME(&_hx_pos_a07dcf344300cb23_68_getTextureData)
HXLINE(  69)		if (::hx::IsNull( this->randomTextureData )) {
HXLINE(  70)			return ::hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE(  73)		int _hx_tmp;
HXDLIN(  73)		if ((id == -1)) {
HXLINE(  73)			_hx_tmp = ::Math_obj::floor((::Math_obj::random() * ( (Float)(this->randomTextureData->length) )));
            		}
            		else {
HXLINE(  73)			_hx_tmp = ::hx::Mod(id,this->randomTextureData->length);
            		}
HXLINE(  72)		return this->randomTextureData->__get(_hx_tmp).StaticCast<  ::objects::TextureData >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(TextureData_obj,getTextureData,return )

 ::objects::TextureData TextureData_obj::getAltTextureData(int id){
            	HX_STACKFRAME(&_hx_pos_a07dcf344300cb23_77_getAltTextureData)
HXLINE(  78)		if (::hx::IsNull( this->altTextures )) {
HXLINE(  79)			return null();
            		}
HXLINE(  81)		return ( ( ::objects::TextureData)(this->altTextures->get(id)) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(TextureData_obj,getAltTextureData,return )

void TextureData_obj::parse( ::Xml xml,::String type){
            	HX_GC_STACKFRAME(&_hx_pos_a07dcf344300cb23_84_parse)
HXLINE(  85)		 ::util::MaskedImage image = null();
HXLINE(  86)		::String _hx_switch_0 = type;
            		if (  (_hx_switch_0==HX_("AltTexture",d2,62,ce,27)) ){
HXLINE( 132)			if (::hx::IsNull( this->altTextures )) {
HXLINE( 133)				this->altTextures =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            			}
HXLINE( 135)			 ::haxe::ds::IntMap _hx_tmp = this->altTextures;
HXDLIN( 135)			 ::Dynamic _hx_tmp1 = ::Std_obj::parseInt(xml->get(HX_("id",db,5b,00,00)));
HXDLIN( 135)			_hx_tmp->set(( (int)(_hx_tmp1) ), ::objects::TextureData_obj::__alloc( HX_CTX ,xml,null()));
HXLINE( 131)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("AnimatedTexture",58,70,fc,07)) ){
HXLINE( 120)			::String _hx_tmp2;
HXDLIN( 120)			if (( (bool)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 120)				 ::Xml _this = ( ( ::Xml)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 120)				bool _hx_tmp3;
HXDLIN( 120)				if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)					_hx_tmp3 = (_this->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 120)					_hx_tmp3 = false;
            				}
HXDLIN( 120)				if (_hx_tmp3) {
HXLINE( 120)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            				}
HXDLIN( 120)				 ::Xml _this1 = _this->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 120)				bool _hx_tmp4;
HXDLIN( 120)				if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)					_hx_tmp4 = (_this1->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 120)					_hx_tmp4 = true;
            				}
HXDLIN( 120)				if (_hx_tmp4) {
HXLINE( 120)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            				}
HXDLIN( 120)				_hx_tmp2 = _this1->nodeValue;
            			}
            			else {
HXLINE( 120)				_hx_tmp2 = HX_("",00,00,00,00);
            			}
HXDLIN( 120)			int _hx_tmp5;
HXDLIN( 120)			if (( (bool)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 120)				 ::Xml _this2 = ( ( ::Xml)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 120)				bool _hx_tmp6;
HXDLIN( 120)				if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)					_hx_tmp6 = (_this2->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 120)					_hx_tmp6 = false;
            				}
HXDLIN( 120)				if (_hx_tmp6) {
HXLINE( 120)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            				}
HXDLIN( 120)				 ::Xml _this3 = _this2->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 120)				bool _hx_tmp7;
HXDLIN( 120)				if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)					_hx_tmp7 = (_this3->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 120)					_hx_tmp7 = true;
            				}
HXDLIN( 120)				if (_hx_tmp7) {
HXLINE( 120)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            				}
HXDLIN( 120)				_hx_tmp5 = ( (int)(::Std_obj::parseInt(_this3->nodeValue)) );
            			}
            			else {
HXLINE( 120)				_hx_tmp5 = 0;
            			}
HXDLIN( 120)			this->animatedChar = ::util::AnimatedChars_obj::getAnimatedChar(_hx_tmp2,_hx_tmp5);
HXLINE( 121)			if (::hx::IsNotNull( this->animatedChar )) {
HXLINE( 122)				image = this->animatedChar->imageFromAngle(( (Float)(0) ),0,( (Float)(0) ));
HXLINE( 123)				this->texture = image->image;
HXLINE( 124)				this->mask = image->mask;
            			}
HXLINE( 119)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("Mask",0c,6d,2f,33)) ){
HXLINE( 104)			int index;
HXDLIN( 104)			if (( (bool)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 104)				 ::Xml _this4 = ( ( ::Xml)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 104)				bool index1;
HXDLIN( 104)				if ((_this4->nodeType != ::Xml_obj::Document)) {
HXLINE( 104)					index1 = (_this4->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 104)					index1 = false;
            				}
HXDLIN( 104)				if (index1) {
HXLINE( 104)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this4->nodeType)));
            				}
HXDLIN( 104)				 ::Xml _this5 = _this4->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 104)				bool index2;
HXDLIN( 104)				if ((_this5->nodeType != ::Xml_obj::Document)) {
HXLINE( 104)					index2 = (_this5->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 104)					index2 = true;
            				}
HXDLIN( 104)				if (index2) {
HXLINE( 104)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this5->nodeType)));
            				}
HXDLIN( 104)				index = ( (int)(::Std_obj::parseInt(_this5->nodeValue)) );
            			}
            			else {
HXLINE( 104)				index = 0;
            			}
HXLINE( 105)			::String sheet;
HXDLIN( 105)			if (( (bool)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 105)				 ::Xml _this6 = ( ( ::Xml)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 105)				bool sheet1;
HXDLIN( 105)				if ((_this6->nodeType != ::Xml_obj::Document)) {
HXLINE( 105)					sheet1 = (_this6->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 105)					sheet1 = false;
            				}
HXDLIN( 105)				if (sheet1) {
HXLINE( 105)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this6->nodeType)));
            				}
HXDLIN( 105)				 ::Xml _this7 = _this6->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 105)				bool sheet2;
HXDLIN( 105)				if ((_this7->nodeType != ::Xml_obj::Document)) {
HXLINE( 105)					sheet2 = (_this7->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 105)					sheet2 = true;
            				}
HXDLIN( 105)				if (sheet2) {
HXLINE( 105)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this7->nodeType)));
            				}
HXDLIN( 105)				sheet = _this7->nodeValue;
            			}
            			else {
HXLINE( 105)				sheet = HX_("",00,00,00,00);
            			}
HXLINE( 106)			this->mask = ::util::AssetLibrary_obj::getImageFromSet(sheet,index);
HXLINE( 107)			this->rect = ::util::AssetLibrary_obj::getRectFromSet(sheet,index);
HXLINE( 108)			if ((sheet == HX_("ground",87,22,28,1c))) {
HXLINE( 109)				this->uValue = ( (float)(((this->rect->x + 2) / ( (Float)(1024) ))) );
HXLINE( 110)				this->vValue = ( (float)(((this->rect->y + 2) / ( (Float)(1024) ))) );
HXLINE( 111)				this->width = ( (float)((this->rect->width / ( (Float)(1024) ))) );
HXLINE( 112)				this->height = ( (float)((this->rect->height / ( (Float)(1024) ))) );
            			}
            			else {
HXLINE( 114)				this->uValue = ( (float)((this->rect->x / ( (Float)(1024) ))) );
HXLINE( 115)				this->vValue = ( (float)((this->rect->y / ( (Float)(1024) ))) );
HXLINE( 116)				this->width = ( (float)((this->rect->width / ( (Float)(1024) ))) );
HXLINE( 117)				this->height = ( (float)((this->rect->height / ( (Float)(1024) ))) );
            			}
HXLINE( 103)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("RandomTexture",f8,b4,32,fb)) ){
HXLINE( 128)			this->randomTextureData = ::Array_obj< ::Dynamic>::__new();
HXLINE( 129)			{
HXLINE( 129)				 ::Dynamic childXML = xml->elementsNamed(HX_("Texture",bb,f0,31,6c));
HXDLIN( 129)				while(( (bool)(childXML->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 129)					 ::Xml childXML1 = ( ( ::Xml)(childXML->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 130)					::Array< ::Dynamic> _hx_tmp8 = this->randomTextureData;
HXDLIN( 130)					_hx_tmp8->push( ::objects::TextureData_obj::__alloc( HX_CTX ,childXML1,true));
            				}
            			}
HXLINE( 127)			goto _hx_goto_6;
            		}
            		if (  (_hx_switch_0==HX_("Texture",bb,f0,31,6c)) ){
HXLINE(  88)			int index3;
HXDLIN(  88)			if (( (bool)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  88)				 ::Xml _this8 = ( ( ::Xml)(xml->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  88)				bool index4;
HXDLIN(  88)				if ((_this8->nodeType != ::Xml_obj::Document)) {
HXLINE(  88)					index4 = (_this8->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE(  88)					index4 = false;
            				}
HXDLIN(  88)				if (index4) {
HXLINE(  88)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this8->nodeType)));
            				}
HXDLIN(  88)				 ::Xml _this9 = _this8->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  88)				bool index5;
HXDLIN(  88)				if ((_this9->nodeType != ::Xml_obj::Document)) {
HXLINE(  88)					index5 = (_this9->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE(  88)					index5 = true;
            				}
HXDLIN(  88)				if (index5) {
HXLINE(  88)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this9->nodeType)));
            				}
HXDLIN(  88)				index3 = ( (int)(::Std_obj::parseInt(_this9->nodeValue)) );
            			}
            			else {
HXLINE(  88)				index3 = 0;
            			}
HXLINE(  89)			::String sheet3;
HXDLIN(  89)			if (( (bool)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  89)				 ::Xml _this10 = ( ( ::Xml)(xml->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  89)				bool sheet4;
HXDLIN(  89)				if ((_this10->nodeType != ::Xml_obj::Document)) {
HXLINE(  89)					sheet4 = (_this10->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE(  89)					sheet4 = false;
            				}
HXDLIN(  89)				if (sheet4) {
HXLINE(  89)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this10->nodeType)));
            				}
HXDLIN(  89)				 ::Xml _this11 = _this10->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  89)				bool sheet5;
HXDLIN(  89)				if ((_this11->nodeType != ::Xml_obj::Document)) {
HXLINE(  89)					sheet5 = (_this11->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE(  89)					sheet5 = true;
            				}
HXDLIN(  89)				if (sheet5) {
HXLINE(  89)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this11->nodeType)));
            				}
HXDLIN(  89)				sheet3 = _this11->nodeValue;
            			}
            			else {
HXLINE(  89)				sheet3 = HX_("",00,00,00,00);
            			}
HXLINE(  90)			this->texture = ::util::AssetLibrary_obj::getImageFromSet(sheet3,index3);
HXLINE(  91)			this->rect = ::util::AssetLibrary_obj::getRectFromSet(sheet3,index3);
HXLINE(  92)			if ((sheet3 == HX_("ground",87,22,28,1c))) {
HXLINE(  93)				this->uValue = ( (float)(((this->rect->x + 2) / ( (Float)(1024) ))) );
HXLINE(  94)				this->vValue = ( (float)(((this->rect->y + 2) / ( (Float)(1024) ))) );
HXLINE(  95)				this->width = ( (float)((this->rect->width / ( (Float)(1024) ))) );
HXLINE(  96)				this->height = ( (float)((this->rect->height / ( (Float)(1024) ))) );
            			}
            			else {
HXLINE(  98)				this->uValue = ( (float)((this->rect->x / ( (Float)(1024) ))) );
HXLINE(  99)				this->vValue = ( (float)((this->rect->y / ( (Float)(1024) ))) );
HXLINE( 100)				this->width = ( (float)((this->rect->width / ( (Float)(1024) ))) );
HXLINE( 101)				this->height = ( (float)((this->rect->height / ( (Float)(1024) ))) );
            			}
HXLINE(  87)			goto _hx_goto_6;
            		}
            		_hx_goto_6:;
            	}


HX_DEFINE_DYNAMIC_FUNC2(TextureData_obj,parse,(void))


::hx::ObjectPtr< TextureData_obj > TextureData_obj::__new( ::Xml objectXML,::hx::Null< bool >  __o_forceTex) {
	::hx::ObjectPtr< TextureData_obj > __this = new TextureData_obj();
	__this->__construct(objectXML,__o_forceTex);
	return __this;
}

::hx::ObjectPtr< TextureData_obj > TextureData_obj::__alloc(::hx::Ctx *_hx_ctx, ::Xml objectXML,::hx::Null< bool >  __o_forceTex) {
	TextureData_obj *__this = (TextureData_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TextureData_obj), true, "objects.TextureData"));
	*(void **)__this = TextureData_obj::_hx_vtable;
	__this->__construct(objectXML,__o_forceTex);
	return __this;
}

TextureData_obj::TextureData_obj()
{
}

void TextureData_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TextureData);
	HX_MARK_MEMBER_NAME(texture,"texture");
	HX_MARK_MEMBER_NAME(mask,"mask");
	HX_MARK_MEMBER_NAME(animatedChar,"animatedChar");
	HX_MARK_MEMBER_NAME(randomTextureData,"randomTextureData");
	HX_MARK_MEMBER_NAME(altTextures,"altTextures");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(uValue,"uValue");
	HX_MARK_MEMBER_NAME(vValue,"vValue");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(maskUValue,"maskUValue");
	HX_MARK_MEMBER_NAME(maskVValue,"maskVValue");
	HX_MARK_MEMBER_NAME(maskWidth,"maskWidth");
	HX_MARK_MEMBER_NAME(maskHeight,"maskHeight");
	HX_MARK_END_CLASS();
}

void TextureData_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(texture,"texture");
	HX_VISIT_MEMBER_NAME(mask,"mask");
	HX_VISIT_MEMBER_NAME(animatedChar,"animatedChar");
	HX_VISIT_MEMBER_NAME(randomTextureData,"randomTextureData");
	HX_VISIT_MEMBER_NAME(altTextures,"altTextures");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(uValue,"uValue");
	HX_VISIT_MEMBER_NAME(vValue,"vValue");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(maskUValue,"maskUValue");
	HX_VISIT_MEMBER_NAME(maskVValue,"maskVValue");
	HX_VISIT_MEMBER_NAME(maskWidth,"maskWidth");
	HX_VISIT_MEMBER_NAME(maskHeight,"maskHeight");
}

::hx::Val TextureData_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"mask") ) { return ::hx::Val( mask ); }
		if (HX_FIELD_EQ(inName,"rect") ) { return ::hx::Val( rect ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"uValue") ) { return ::hx::Val( uValue ); }
		if (HX_FIELD_EQ(inName,"vValue") ) { return ::hx::Val( vValue ); }
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { return ::hx::Val( texture ); }
		if (HX_FIELD_EQ(inName,"getRect") ) { return ::hx::Val( getRect_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"maskWidth") ) { return ::hx::Val( maskWidth ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"maskUValue") ) { return ::hx::Val( maskUValue ); }
		if (HX_FIELD_EQ(inName,"maskVValue") ) { return ::hx::Val( maskVValue ); }
		if (HX_FIELD_EQ(inName,"maskHeight") ) { return ::hx::Val( maskHeight ); }
		if (HX_FIELD_EQ(inName,"getTexture") ) { return ::hx::Val( getTexture_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"altTextures") ) { return ::hx::Val( altTextures ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animatedChar") ) { return ::hx::Val( animatedChar ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getTextureData") ) { return ::hx::Val( getTextureData_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"randomTextureData") ) { return ::hx::Val( randomTextureData ); }
		if (HX_FIELD_EQ(inName,"getAltTextureData") ) { return ::hx::Val( getAltTextureData_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TextureData_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"mask") ) { mask=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::util::Rect >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"uValue") ) { uValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vValue") ) { vValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { texture=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"maskWidth") ) { maskWidth=inValue.Cast< float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"maskUValue") ) { maskUValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskVValue") ) { maskVValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskHeight") ) { maskHeight=inValue.Cast< float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"altTextures") ) { altTextures=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animatedChar") ) { animatedChar=inValue.Cast<  ::util::AnimatedChar >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"randomTextureData") ) { randomTextureData=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TextureData_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("texture",db,c8,e0,9e));
	outFields->push(HX_("mask",ec,40,56,48));
	outFields->push(HX_("animatedChar",19,8b,fc,9e));
	outFields->push(HX_("randomTextureData",62,53,b3,f3));
	outFields->push(HX_("altTextures",81,7d,95,c8));
	outFields->push(HX_("rect",24,4d,a7,4b));
	outFields->push(HX_("uValue",bc,26,a7,8c));
	outFields->push(HX_("vValue",1b,83,02,f3));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("maskUValue",c8,54,8b,a1));
	outFields->push(HX_("maskVValue",27,b1,e6,07));
	outFields->push(HX_("maskWidth",7a,0d,cb,50));
	outFields->push(HX_("maskHeight",f3,35,30,17));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TextureData_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(TextureData_obj,texture),HX_("texture",db,c8,e0,9e)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(TextureData_obj,mask),HX_("mask",ec,40,56,48)},
	{::hx::fsObject /*  ::util::AnimatedChar */ ,(int)offsetof(TextureData_obj,animatedChar),HX_("animatedChar",19,8b,fc,9e)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(TextureData_obj,randomTextureData),HX_("randomTextureData",62,53,b3,f3)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(TextureData_obj,altTextures),HX_("altTextures",81,7d,95,c8)},
	{::hx::fsObject /*  ::util::Rect */ ,(int)offsetof(TextureData_obj,rect),HX_("rect",24,4d,a7,4b)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,uValue),HX_("uValue",bc,26,a7,8c)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,vValue),HX_("vValue",1b,83,02,f3)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,maskUValue),HX_("maskUValue",c8,54,8b,a1)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,maskVValue),HX_("maskVValue",27,b1,e6,07)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,maskWidth),HX_("maskWidth",7a,0d,cb,50)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(TextureData_obj,maskHeight),HX_("maskHeight",f3,35,30,17)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *TextureData_obj_sStaticStorageInfo = 0;
#endif

static ::String TextureData_obj_sMemberFields[] = {
	HX_("texture",db,c8,e0,9e),
	HX_("mask",ec,40,56,48),
	HX_("animatedChar",19,8b,fc,9e),
	HX_("randomTextureData",62,53,b3,f3),
	HX_("altTextures",81,7d,95,c8),
	HX_("rect",24,4d,a7,4b),
	HX_("uValue",bc,26,a7,8c),
	HX_("vValue",1b,83,02,f3),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("maskUValue",c8,54,8b,a1),
	HX_("maskVValue",27,b1,e6,07),
	HX_("maskWidth",7a,0d,cb,50),
	HX_("maskHeight",f3,35,30,17),
	HX_("getTexture",e5,4e,42,ee),
	HX_("getRect",da,fc,29,1e),
	HX_("getTextureData",af,a7,80,80),
	HX_("getAltTextureData",32,d1,27,4b),
	HX_("parse",33,90,55,bd),
	::String(null()) };

::hx::Class TextureData_obj::__mClass;

void TextureData_obj::__register()
{
	TextureData_obj _hx_dummy;
	TextureData_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.TextureData",eb,f5,ad,e0);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TextureData_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TextureData_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TextureData_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TextureData_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace objects
