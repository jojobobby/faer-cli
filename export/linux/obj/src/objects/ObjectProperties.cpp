// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_objects_ObjectProperties
#include <objects/ObjectProperties.h>
#endif
#ifndef INCLUDED_objects_ProjectileProperties
#include <objects/ProjectileProperties.h>
#endif
#ifndef INCLUDED_objects_ScepterProperties
#include <objects/ScepterProperties.h>
#endif
#ifndef INCLUDED_objects_ShowEffectProperties
#include <objects/ShowEffectProperties.h>
#endif
#ifndef INCLUDED_objects_TextureData
#include <objects/TextureData.h>
#endif
#ifndef INCLUDED_objects_WhileMovingProperties
#include <objects/WhileMovingProperties.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c2019774d6191b44_7_new,"objects.ObjectProperties","new",0x1d89db7e,"objects.ObjectProperties.new","objects/ObjectProperties.hx",7,0xfce94251)
HX_LOCAL_STACK_FRAME(_hx_pos_c2019774d6191b44_150_getSize,"objects.ObjectProperties","getSize",0xbd734295,"objects.ObjectProperties.getSize","objects/ObjectProperties.hx",150,0xfce94251)
namespace objects{

void ObjectProperties_obj::__construct( ::Xml objectXML){
            	HX_GC_STACKFRAME(&_hx_pos_c2019774d6191b44_7_new)
HXLINE(  45)		this->showEffects = null();
HXLINE(  44)		this->floatSine = false;
HXLINE(  43)		this->floatHeight = ((Float)0.0);
HXLINE(  42)		this->floatTime = 0;
HXLINE(  41)		this->floating = false;
HXLINE(  40)		this->rotation = ((Float)0.0);
HXLINE(  39)		this->angleCorrection = ((Float)0.0);
HXLINE(  36)		this->oldSound = HX_("",00,00,00,00);
HXLINE(  35)		this->whileMoving = null();
HXLINE(  34)		this->sizeStep = 5;
HXLINE(  33)		this->maxSize = 100;
HXLINE(  32)		this->minSize = 100;
HXLINE(  31)		this->portrait = null();
HXLINE(  30)		this->sounds = null();
HXLINE(  29)		this->shadowColor = 0;
HXLINE(  28)		this->bloodColor = 16711680;
HXLINE(  27)		this->bloodProb = ((Float)0.0);
HXLINE(  26)		this->dontFaceAttacks = false;
HXLINE(  25)		this->showName = false;
HXLINE(  24)		this->color = 16777215;
HXLINE(  23)		this->flying = false;
HXLINE(  22)		this->baseZ = ((Float)0.0);
HXLINE(  21)		this->protectFromSink = false;
HXLINE(  20)		this->protectFromGroundDamage = false;
HXLINE(  19)		this->noMiniMap = false;
HXLINE(  18)		this->staticObj = false;
HXLINE(  17)		this->enemyOccupySquare = false;
HXLINE(  16)		this->fullOccupy = false;
HXLINE(  15)		this->occupySquare = false;
HXLINE(  14)		this->drawUnder = false;
HXLINE(  13)		this->drawOnGround = false;
HXLINE(  12)		this->isEnemy = false;
HXLINE(  11)		this->isPlayer = false;
HXLINE(  10)		this->displayId = HX_("",00,00,00,00);
HXLINE(   9)		this->objId = HX_("",00,00,00,00);
HXLINE(   8)		this->objType = 0;
HXLINE(  48)		int bulletType = 0;
HXLINE(  49)		this->projectiles =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  50)		if (::hx::IsNull( objectXML )) {
HXLINE(  51)			return;
            		}
HXLINE(  53)		this->objType = ( (int)(::Std_obj::parseInt(objectXML->get(HX_("type",ba,f2,08,4d)))) );
HXLINE(  54)		this->objId = objectXML->get(HX_("id",db,5b,00,00));
HXLINE(  55)		this->displayId = this->objId;
HXLINE(  56)		if (( (bool)(objectXML->elementsNamed(HX_("DisplayId",9d,de,ad,63))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  57)			 ::Xml _this = ( ( ::Xml)(objectXML->elementsNamed(HX_("DisplayId",9d,de,ad,63))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  57)			bool _hx_tmp;
HXDLIN(  57)			if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE(  57)				_hx_tmp = (_this->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE(  57)				_hx_tmp = false;
            			}
HXDLIN(  57)			if (_hx_tmp) {
HXLINE(  57)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            			}
HXDLIN(  57)			 ::Xml _this1 = _this->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  57)			bool _hx_tmp1;
HXDLIN(  57)			if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE(  57)				_hx_tmp1 = (_this1->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE(  57)				_hx_tmp1 = true;
            			}
HXDLIN(  57)			if (_hx_tmp1) {
HXLINE(  57)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            			}
HXDLIN(  57)			this->displayId = _this1->nodeValue;
            		}
HXLINE(  59)		this->isPlayer = ( (bool)(objectXML->elementsNamed(HX_("Player",81,5f,4d,6c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  60)		this->isEnemy = ( (bool)(objectXML->elementsNamed(HX_("Enemy",28,82,a8,03))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  61)		this->drawOnGround = ( (bool)(objectXML->elementsNamed(HX_("DrawOnGround",4a,f1,da,99))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  62)		bool _hx_tmp2;
HXDLIN(  62)		if (!(this->drawOnGround)) {
HXLINE(  62)			_hx_tmp2 = ( (bool)(objectXML->elementsNamed(HX_("DrawUnder",54,a6,c1,10))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
            		}
            		else {
HXLINE(  62)			_hx_tmp2 = true;
            		}
HXDLIN(  62)		if (_hx_tmp2) {
HXLINE(  63)			this->drawUnder = true;
            		}
HXLINE(  65)		this->occupySquare = ( (bool)(objectXML->elementsNamed(HX_("OccupySquare",6c,2a,75,20))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  66)		this->fullOccupy = ( (bool)(objectXML->elementsNamed(HX_("FullOccupy",5e,3b,ae,81))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  67)		this->enemyOccupySquare = ( (bool)(objectXML->elementsNamed(HX_("EnemyOccupySquare",94,48,ec,a5))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  68)		this->staticObj = ( (bool)(objectXML->elementsNamed(HX_("Static",ce,50,90,3a))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  69)		this->noMiniMap = ( (bool)(objectXML->elementsNamed(HX_("NoMiniMap",e4,0d,91,2b))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  70)		this->protectFromGroundDamage = ( (bool)(objectXML->elementsNamed(HX_("ProtectFromGroundDamage",ef,f5,90,52))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  71)		this->protectFromSink = ( (bool)(objectXML->elementsNamed(HX_("ProtectFromSink",ec,84,c6,96))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  72)		this->flying = ( (bool)(objectXML->elementsNamed(HX_("Flying",6f,c6,8c,7c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  73)		this->showName = ( (bool)(objectXML->elementsNamed(HX_("ShowName",08,f2,37,8a))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  74)		this->dontFaceAttacks = ( (bool)(objectXML->elementsNamed(HX_("DontFaceAttacks",5d,0b,fa,f7))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  75)		this->floating = ( (bool)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) );
HXLINE(  76)		if (this->floating) {
HXLINE(  77)			bool _hx_tmp3;
HXDLIN(  77)			if (( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->exists(HX_("sine",4d,96,53,4c))) {
HXLINE(  77)				_hx_tmp3 = false;
            			}
            			else {
HXLINE(  77)				_hx_tmp3 = (( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->get(HX_("sine",4d,96,53,4c)) == HX_("true",4e,a7,03,4d));
            			}
HXDLIN(  77)			this->floatSine = _hx_tmp3;
HXLINE(  82)			int _hx_tmp4;
HXDLIN(  82)			if (( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->exists(HX_("time",0d,cc,fc,4c))) {
HXLINE(  82)				_hx_tmp4 = 500;
            			}
            			else {
HXLINE(  82)				_hx_tmp4 = ( (int)(::Std_obj::parseInt(( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->get(HX_("time",0d,cc,fc,4c)))) );
            			}
HXDLIN(  82)			this->floatTime = _hx_tmp4;
HXLINE(  83)			Float _hx_tmp5;
HXDLIN(  83)			if (( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->exists(HX_("height",e7,07,4c,02))) {
HXLINE(  83)				_hx_tmp5 = ((Float)0.5);
            			}
            			else {
HXLINE(  83)				_hx_tmp5 = ::Std_obj::parseFloat(( ( ::Xml)(objectXML->elementsNamed(HX_("Float",7c,35,c4,95))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->get(HX_("height",e7,07,4c,02)));
            			}
HXDLIN(  83)			this->floatHeight = _hx_tmp5;
            		}
HXLINE(  88)		if (( (bool)(objectXML->elementsNamed(HX_("Z",5a,00,00,00))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  89)			 ::Xml _this2 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Z",5a,00,00,00))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  89)			bool _hx_tmp6;
HXDLIN(  89)			if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE(  89)				_hx_tmp6 = (_this2->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE(  89)				_hx_tmp6 = false;
            			}
HXDLIN(  89)			if (_hx_tmp6) {
HXLINE(  89)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            			}
HXDLIN(  89)			 ::Xml _this3 = _this2->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  89)			bool _hx_tmp7;
HXDLIN(  89)			if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE(  89)				_hx_tmp7 = (_this3->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE(  89)				_hx_tmp7 = true;
            			}
HXDLIN(  89)			if (_hx_tmp7) {
HXLINE(  89)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            			}
HXDLIN(  89)			this->baseZ = ::Std_obj::parseFloat(_this3->nodeValue);
            		}
HXLINE(  91)		if (( (bool)(objectXML->elementsNamed(HX_("Color",43,e1,89,dd))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  92)			 ::Xml _this4 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Color",43,e1,89,dd))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  92)			bool _hx_tmp8;
HXDLIN(  92)			if ((_this4->nodeType != ::Xml_obj::Document)) {
HXLINE(  92)				_hx_tmp8 = (_this4->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE(  92)				_hx_tmp8 = false;
            			}
HXDLIN(  92)			if (_hx_tmp8) {
HXLINE(  92)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this4->nodeType)));
            			}
HXDLIN(  92)			 ::Xml _this5 = _this4->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  92)			bool _hx_tmp9;
HXDLIN(  92)			if ((_this5->nodeType != ::Xml_obj::Document)) {
HXLINE(  92)				_hx_tmp9 = (_this5->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE(  92)				_hx_tmp9 = true;
            			}
HXDLIN(  92)			if (_hx_tmp9) {
HXLINE(  92)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this5->nodeType)));
            			}
HXDLIN(  92)			this->color = ( (int)(::Std_obj::parseInt(_this5->nodeValue)) );
            		}
HXLINE(  94)		if (( (bool)(objectXML->elementsNamed(HX_("Size",e1,cc,2c,37))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  95)			 ::Xml _this6 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Size",e1,cc,2c,37))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  95)			bool _hx_tmp10;
HXDLIN(  95)			if ((_this6->nodeType != ::Xml_obj::Document)) {
HXLINE(  95)				_hx_tmp10 = (_this6->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE(  95)				_hx_tmp10 = false;
            			}
HXDLIN(  95)			if (_hx_tmp10) {
HXLINE(  95)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this6->nodeType)));
            			}
HXDLIN(  95)			 ::Xml _this7 = _this6->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  95)			bool _hx_tmp11;
HXDLIN(  95)			if ((_this7->nodeType != ::Xml_obj::Document)) {
HXLINE(  95)				_hx_tmp11 = (_this7->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE(  95)				_hx_tmp11 = true;
            			}
HXDLIN(  95)			if (_hx_tmp11) {
HXLINE(  95)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this7->nodeType)));
            			}
HXDLIN(  95)			this->minSize = (this->maxSize = ( (int)(::Std_obj::parseInt(_this7->nodeValue)) ));
            		}
            		else {
HXLINE(  97)			if (( (bool)(objectXML->elementsNamed(HX_("MinSize",53,37,ae,0a))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE(  98)				 ::Xml _this8 = ( ( ::Xml)(objectXML->elementsNamed(HX_("MinSize",53,37,ae,0a))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN(  98)				bool _hx_tmp12;
HXDLIN(  98)				if ((_this8->nodeType != ::Xml_obj::Document)) {
HXLINE(  98)					_hx_tmp12 = (_this8->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE(  98)					_hx_tmp12 = false;
            				}
HXDLIN(  98)				if (_hx_tmp12) {
HXLINE(  98)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this8->nodeType)));
            				}
HXDLIN(  98)				 ::Xml _this9 = _this8->children->__get(0).StaticCast<  ::Xml >();
HXDLIN(  98)				bool _hx_tmp13;
HXDLIN(  98)				if ((_this9->nodeType != ::Xml_obj::Document)) {
HXLINE(  98)					_hx_tmp13 = (_this9->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE(  98)					_hx_tmp13 = true;
            				}
HXDLIN(  98)				if (_hx_tmp13) {
HXLINE(  98)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this9->nodeType)));
            				}
HXDLIN(  98)				this->minSize = ( (int)(::Std_obj::parseInt(_this9->nodeValue)) );
            			}
HXLINE( 100)			if (( (bool)(objectXML->elementsNamed(HX_("MaxSize",65,21,d5,99))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 101)				 ::Xml _this10 = ( ( ::Xml)(objectXML->elementsNamed(HX_("MaxSize",65,21,d5,99))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 101)				bool _hx_tmp14;
HXDLIN( 101)				if ((_this10->nodeType != ::Xml_obj::Document)) {
HXLINE( 101)					_hx_tmp14 = (_this10->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 101)					_hx_tmp14 = false;
            				}
HXDLIN( 101)				if (_hx_tmp14) {
HXLINE( 101)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this10->nodeType)));
            				}
HXDLIN( 101)				 ::Xml _this11 = _this10->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 101)				bool _hx_tmp15;
HXDLIN( 101)				if ((_this11->nodeType != ::Xml_obj::Document)) {
HXLINE( 101)					_hx_tmp15 = (_this11->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 101)					_hx_tmp15 = true;
            				}
HXDLIN( 101)				if (_hx_tmp15) {
HXLINE( 101)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this11->nodeType)));
            				}
HXDLIN( 101)				this->maxSize = ( (int)(::Std_obj::parseInt(_this11->nodeValue)) );
            			}
HXLINE( 103)			if (( (bool)(objectXML->elementsNamed(HX_("SizeStep",cd,64,e0,bf))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 104)				 ::Xml _this12 = ( ( ::Xml)(objectXML->elementsNamed(HX_("SizeStep",cd,64,e0,bf))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 104)				bool _hx_tmp16;
HXDLIN( 104)				if ((_this12->nodeType != ::Xml_obj::Document)) {
HXLINE( 104)					_hx_tmp16 = (_this12->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 104)					_hx_tmp16 = false;
            				}
HXDLIN( 104)				if (_hx_tmp16) {
HXLINE( 104)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this12->nodeType)));
            				}
HXDLIN( 104)				 ::Xml _this13 = _this12->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 104)				bool _hx_tmp17;
HXDLIN( 104)				if ((_this13->nodeType != ::Xml_obj::Document)) {
HXLINE( 104)					_hx_tmp17 = (_this13->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 104)					_hx_tmp17 = true;
            				}
HXDLIN( 104)				if (_hx_tmp17) {
HXLINE( 104)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this13->nodeType)));
            				}
HXDLIN( 104)				this->sizeStep = ( (int)(::Std_obj::parseInt(_this13->nodeValue)) );
            			}
            		}
HXLINE( 107)		::String _hx_tmp18;
HXDLIN( 107)		if (( (bool)(objectXML->elementsNamed(HX_("OldSound",c8,62,49,41))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 108)			 ::Xml _this14 = ( ( ::Xml)(objectXML->elementsNamed(HX_("OldSound",c8,62,49,41))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 108)			bool _hx_tmp19;
HXDLIN( 108)			if ((_this14->nodeType != ::Xml_obj::Document)) {
HXLINE( 108)				_hx_tmp19 = (_this14->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 108)				_hx_tmp19 = false;
            			}
HXDLIN( 108)			if (_hx_tmp19) {
HXLINE( 108)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this14->nodeType)));
            			}
HXDLIN( 108)			 ::Xml _this15 = _this14->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 108)			bool _hx_tmp20;
HXDLIN( 108)			if ((_this15->nodeType != ::Xml_obj::Document)) {
HXLINE( 108)				_hx_tmp20 = (_this15->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 108)				_hx_tmp20 = true;
            			}
HXDLIN( 108)			if (_hx_tmp20) {
HXLINE( 108)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this15->nodeType)));
            			}
HXLINE( 107)			_hx_tmp18 = _this15->nodeValue;
            		}
            		else {
HXLINE( 107)			_hx_tmp18 = null();
            		}
HXDLIN( 107)		this->oldSound = _hx_tmp18;
HXLINE( 112)		{
HXLINE( 112)			 ::Dynamic xml = objectXML->elementsNamed(HX_("Projectile",09,8a,3c,bb));
HXDLIN( 112)			while(( (bool)(xml->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 112)				 ::Xml xml1 = ( ( ::Xml)(xml->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 113)				bulletType = ( (int)(::Std_obj::parseInt(xml1->get(HX_("id",db,5b,00,00)))) );
HXLINE( 114)				 ::haxe::ds::IntMap _hx_tmp21 = this->projectiles;
HXDLIN( 114)				_hx_tmp21->set(bulletType, ::objects::ProjectileProperties_obj::__alloc( HX_CTX ,xml1));
            			}
            		}
HXLINE( 117)		if (( (bool)(objectXML->elementsNamed(HX_("Scepter",a6,13,a3,82))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 118)			this->scepterProps =  ::objects::ScepterProperties_obj::__alloc( HX_CTX ,( ( ::Xml)(objectXML->elementsNamed(HX_("Scepter",a6,13,a3,82))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ));
            		}
HXLINE( 120)		this->showEffects = ::Array_obj< ::Dynamic>::__new();
HXLINE( 121)		{
HXLINE( 121)			 ::Dynamic xml2 = objectXML->elementsNamed(HX_("ShowEffect",8e,03,c9,c0));
HXDLIN( 121)			while(( (bool)(xml2->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 121)				 ::Xml xml3 = ( ( ::Xml)(xml2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 122)				::Array< ::Dynamic> _hx_tmp22 = this->showEffects;
HXDLIN( 122)				_hx_tmp22->push( ::objects::ShowEffectProperties_obj::__alloc( HX_CTX ,xml3));
            			}
            		}
HXLINE( 124)		Float _hx_tmp23;
HXDLIN( 124)		if (( (bool)(objectXML->elementsNamed(HX_("AngleCorrection",31,b9,35,96))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 125)			 ::Xml _this16 = ( ( ::Xml)(objectXML->elementsNamed(HX_("AngleCorrection",31,b9,35,96))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 125)			bool _hx_tmp24;
HXDLIN( 125)			if ((_this16->nodeType != ::Xml_obj::Document)) {
HXLINE( 125)				_hx_tmp24 = (_this16->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 125)				_hx_tmp24 = false;
            			}
HXDLIN( 125)			if (_hx_tmp24) {
HXLINE( 125)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this16->nodeType)));
            			}
HXDLIN( 125)			 ::Xml _this17 = _this16->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 125)			bool _hx_tmp25;
HXDLIN( 125)			if ((_this17->nodeType != ::Xml_obj::Document)) {
HXLINE( 125)				_hx_tmp25 = (_this17->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 125)				_hx_tmp25 = true;
            			}
HXDLIN( 125)			if (_hx_tmp25) {
HXLINE( 125)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this17->nodeType)));
            			}
HXLINE( 124)			_hx_tmp23 = (::Std_obj::parseFloat(_this17->nodeValue) * ((Float)0.785398163397448279));
            		}
            		else {
HXLINE( 124)			_hx_tmp23 = ( (Float)(0) );
            		}
HXDLIN( 124)		this->angleCorrection = _hx_tmp23;
HXLINE( 126)		Float _hx_tmp26;
HXDLIN( 126)		if (( (bool)(objectXML->elementsNamed(HX_("Rotation",5e,f9,37,e2))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 126)			 ::Xml _this18 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Rotation",5e,f9,37,e2))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 126)			bool _hx_tmp27;
HXDLIN( 126)			if ((_this18->nodeType != ::Xml_obj::Document)) {
HXLINE( 126)				_hx_tmp27 = (_this18->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 126)				_hx_tmp27 = false;
            			}
HXDLIN( 126)			if (_hx_tmp27) {
HXLINE( 126)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this18->nodeType)));
            			}
HXDLIN( 126)			 ::Xml _this19 = _this18->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 126)			bool _hx_tmp28;
HXDLIN( 126)			if ((_this19->nodeType != ::Xml_obj::Document)) {
HXLINE( 126)				_hx_tmp28 = (_this19->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 126)				_hx_tmp28 = true;
            			}
HXDLIN( 126)			if (_hx_tmp28) {
HXLINE( 126)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this19->nodeType)));
            			}
HXDLIN( 126)			_hx_tmp26 = ::Std_obj::parseFloat(_this19->nodeValue);
            		}
            		else {
HXLINE( 126)			_hx_tmp26 = ( (Float)(0) );
            		}
HXDLIN( 126)		this->rotation = _hx_tmp26;
HXLINE( 128)		{
HXLINE( 128)			 ::Dynamic xml4 = objectXML->elementsNamed(HX_("BloodProb",4f,b8,3a,b6));
HXDLIN( 128)			while(( (bool)(xml4->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 128)				xml4->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 129)				 ::Xml _this20 = ( ( ::Xml)(objectXML->elementsNamed(HX_("BloodProb",4f,b8,3a,b6))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 129)				bool _hx_tmp29;
HXDLIN( 129)				if ((_this20->nodeType != ::Xml_obj::Document)) {
HXLINE( 129)					_hx_tmp29 = (_this20->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 129)					_hx_tmp29 = false;
            				}
HXDLIN( 129)				if (_hx_tmp29) {
HXLINE( 129)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this20->nodeType)));
            				}
HXDLIN( 129)				 ::Xml _this21 = _this20->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 129)				bool _hx_tmp30;
HXDLIN( 129)				if ((_this21->nodeType != ::Xml_obj::Document)) {
HXLINE( 129)					_hx_tmp30 = (_this21->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 129)					_hx_tmp30 = true;
            				}
HXDLIN( 129)				if (_hx_tmp30) {
HXLINE( 129)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this21->nodeType)));
            				}
HXDLIN( 129)				this->bloodProb = ::Std_obj::parseFloat(_this21->nodeValue);
            			}
            		}
HXLINE( 131)		{
HXLINE( 131)			 ::Dynamic xml5 = objectXML->elementsNamed(HX_("BloodColor",69,23,f3,3e));
HXDLIN( 131)			while(( (bool)(xml5->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 131)				xml5->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 132)				 ::Xml _this22 = ( ( ::Xml)(objectXML->elementsNamed(HX_("BloodColor",69,23,f3,3e))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 132)				bool _hx_tmp31;
HXDLIN( 132)				if ((_this22->nodeType != ::Xml_obj::Document)) {
HXLINE( 132)					_hx_tmp31 = (_this22->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 132)					_hx_tmp31 = false;
            				}
HXDLIN( 132)				if (_hx_tmp31) {
HXLINE( 132)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this22->nodeType)));
            				}
HXDLIN( 132)				 ::Xml _this23 = _this22->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 132)				bool _hx_tmp32;
HXDLIN( 132)				if ((_this23->nodeType != ::Xml_obj::Document)) {
HXLINE( 132)					_hx_tmp32 = (_this23->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 132)					_hx_tmp32 = true;
            				}
HXDLIN( 132)				if (_hx_tmp32) {
HXLINE( 132)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this23->nodeType)));
            				}
HXDLIN( 132)				this->bloodColor = ( (int)(::Std_obj::parseInt(_this23->nodeValue)) );
            			}
            		}
HXLINE( 134)		{
HXLINE( 134)			 ::Dynamic xml6 = objectXML->elementsNamed(HX_("ShadowColor",43,25,5b,a5));
HXDLIN( 134)			while(( (bool)(xml6->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 134)				xml6->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 135)				 ::Xml _this24 = ( ( ::Xml)(objectXML->elementsNamed(HX_("ShadowColor",43,25,5b,a5))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 135)				bool _hx_tmp33;
HXDLIN( 135)				if ((_this24->nodeType != ::Xml_obj::Document)) {
HXLINE( 135)					_hx_tmp33 = (_this24->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 135)					_hx_tmp33 = false;
            				}
HXDLIN( 135)				if (_hx_tmp33) {
HXLINE( 135)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this24->nodeType)));
            				}
HXDLIN( 135)				 ::Xml _this25 = _this24->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 135)				bool _hx_tmp34;
HXDLIN( 135)				if ((_this25->nodeType != ::Xml_obj::Document)) {
HXLINE( 135)					_hx_tmp34 = (_this25->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 135)					_hx_tmp34 = true;
            				}
HXDLIN( 135)				if (_hx_tmp34) {
HXLINE( 135)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this25->nodeType)));
            				}
HXDLIN( 135)				this->shadowColor = ( (int)(::Std_obj::parseInt(_this25->nodeValue)) );
            			}
            		}
HXLINE( 137)		{
HXLINE( 137)			 ::Dynamic soundXML = objectXML->elementsNamed(HX_("Sound",af,fc,f9,13));
HXDLIN( 137)			while(( (bool)(soundXML->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 137)				 ::Xml soundXML1 = ( ( ::Xml)(soundXML->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 138)				if (::hx::IsNull( this->sounds )) {
HXLINE( 139)					this->sounds =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
            				}
HXLINE( 140)				 ::haxe::ds::IntMap _hx_tmp35 = this->sounds;
HXDLIN( 140)				 ::Dynamic _hx_tmp36 = ::Std_obj::parseInt(soundXML1->get(HX_("id",db,5b,00,00)));
HXDLIN( 140)				bool _hx_tmp37;
HXDLIN( 140)				if ((soundXML1->nodeType != ::Xml_obj::Document)) {
HXLINE( 140)					_hx_tmp37 = (soundXML1->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 140)					_hx_tmp37 = false;
            				}
HXDLIN( 140)				if (_hx_tmp37) {
HXLINE( 140)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(soundXML1->nodeType)));
            				}
HXDLIN( 140)				 ::Xml _this26 = soundXML1->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 140)				bool _hx_tmp38;
HXDLIN( 140)				if ((_this26->nodeType != ::Xml_obj::Document)) {
HXLINE( 140)					_hx_tmp38 = (_this26->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 140)					_hx_tmp38 = true;
            				}
HXDLIN( 140)				if (_hx_tmp38) {
HXLINE( 140)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this26->nodeType)));
            				}
HXDLIN( 140)				_hx_tmp35->set(( (int)(_hx_tmp36) ),_this26->nodeValue);
            			}
            		}
HXLINE( 143)		{
HXLINE( 143)			 ::Dynamic xml7 = objectXML->elementsNamed(HX_("Portrait",7b,dd,60,92));
HXDLIN( 143)			while(( (bool)(xml7->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 143)				xml7->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 144)				this->portrait =  ::objects::TextureData_obj::__alloc( HX_CTX ,( ( ::Xml)(objectXML->elementsNamed(HX_("Portrait",7b,dd,60,92))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ),null());
            			}
            		}
HXLINE( 146)		{
HXLINE( 146)			 ::Dynamic xml8 = objectXML->elementsNamed(HX_("WhileMoving",ff,9c,5f,f9));
HXDLIN( 146)			while(( (bool)(xml8->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 146)				xml8->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 147)				this->whileMoving =  ::objects::WhileMovingProperties_obj::__alloc( HX_CTX ,( ( ::Xml)(objectXML->elementsNamed(HX_("WhileMoving",ff,9c,5f,f9))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) ));
            			}
            		}
            	}

Dynamic ObjectProperties_obj::__CreateEmpty() { return new ObjectProperties_obj; }

void *ObjectProperties_obj::_hx_vtable = 0;

Dynamic ObjectProperties_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ObjectProperties_obj > _hx_result = new ObjectProperties_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool ObjectProperties_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x46a7b586;
}

int ObjectProperties_obj::getSize(){
            	HX_STACKFRAME(&_hx_pos_c2019774d6191b44_150_getSize)
HXLINE( 151)		if ((this->minSize == this->maxSize)) {
HXLINE( 152)			return ::Std_obj::_hx_int((( (Float)(this->minSize) ) * ((Float)1.25)));
            		}
HXLINE( 155)		return ::Std_obj::_hx_int((( (Float)((this->minSize + (::Math_obj::round((::Math_obj::random() * ( (Float)(::Math_obj::round((( (Float)((this->maxSize - this->minSize)) ) / ( (Float)(this->sizeStep) )))) ))) * this->sizeStep))) ) * ((Float)1.25)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ObjectProperties_obj,getSize,return )


::hx::ObjectPtr< ObjectProperties_obj > ObjectProperties_obj::__new( ::Xml objectXML) {
	::hx::ObjectPtr< ObjectProperties_obj > __this = new ObjectProperties_obj();
	__this->__construct(objectXML);
	return __this;
}

::hx::ObjectPtr< ObjectProperties_obj > ObjectProperties_obj::__alloc(::hx::Ctx *_hx_ctx, ::Xml objectXML) {
	ObjectProperties_obj *__this = (ObjectProperties_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ObjectProperties_obj), true, "objects.ObjectProperties"));
	*(void **)__this = ObjectProperties_obj::_hx_vtable;
	__this->__construct(objectXML);
	return __this;
}

ObjectProperties_obj::ObjectProperties_obj()
{
}

void ObjectProperties_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ObjectProperties);
	HX_MARK_MEMBER_NAME(objType,"objType");
	HX_MARK_MEMBER_NAME(objId,"objId");
	HX_MARK_MEMBER_NAME(displayId,"displayId");
	HX_MARK_MEMBER_NAME(isPlayer,"isPlayer");
	HX_MARK_MEMBER_NAME(isEnemy,"isEnemy");
	HX_MARK_MEMBER_NAME(drawOnGround,"drawOnGround");
	HX_MARK_MEMBER_NAME(drawUnder,"drawUnder");
	HX_MARK_MEMBER_NAME(occupySquare,"occupySquare");
	HX_MARK_MEMBER_NAME(fullOccupy,"fullOccupy");
	HX_MARK_MEMBER_NAME(enemyOccupySquare,"enemyOccupySquare");
	HX_MARK_MEMBER_NAME(staticObj,"staticObj");
	HX_MARK_MEMBER_NAME(noMiniMap,"noMiniMap");
	HX_MARK_MEMBER_NAME(protectFromGroundDamage,"protectFromGroundDamage");
	HX_MARK_MEMBER_NAME(protectFromSink,"protectFromSink");
	HX_MARK_MEMBER_NAME(baseZ,"baseZ");
	HX_MARK_MEMBER_NAME(flying,"flying");
	HX_MARK_MEMBER_NAME(color,"color");
	HX_MARK_MEMBER_NAME(showName,"showName");
	HX_MARK_MEMBER_NAME(dontFaceAttacks,"dontFaceAttacks");
	HX_MARK_MEMBER_NAME(bloodProb,"bloodProb");
	HX_MARK_MEMBER_NAME(bloodColor,"bloodColor");
	HX_MARK_MEMBER_NAME(shadowColor,"shadowColor");
	HX_MARK_MEMBER_NAME(sounds,"sounds");
	HX_MARK_MEMBER_NAME(portrait,"portrait");
	HX_MARK_MEMBER_NAME(minSize,"minSize");
	HX_MARK_MEMBER_NAME(maxSize,"maxSize");
	HX_MARK_MEMBER_NAME(sizeStep,"sizeStep");
	HX_MARK_MEMBER_NAME(whileMoving,"whileMoving");
	HX_MARK_MEMBER_NAME(oldSound,"oldSound");
	HX_MARK_MEMBER_NAME(projectiles,"projectiles");
	HX_MARK_MEMBER_NAME(scepterProps,"scepterProps");
	HX_MARK_MEMBER_NAME(angleCorrection,"angleCorrection");
	HX_MARK_MEMBER_NAME(rotation,"rotation");
	HX_MARK_MEMBER_NAME(floating,"floating");
	HX_MARK_MEMBER_NAME(floatTime,"floatTime");
	HX_MARK_MEMBER_NAME(floatHeight,"floatHeight");
	HX_MARK_MEMBER_NAME(floatSine,"floatSine");
	HX_MARK_MEMBER_NAME(showEffects,"showEffects");
	HX_MARK_END_CLASS();
}

void ObjectProperties_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(objType,"objType");
	HX_VISIT_MEMBER_NAME(objId,"objId");
	HX_VISIT_MEMBER_NAME(displayId,"displayId");
	HX_VISIT_MEMBER_NAME(isPlayer,"isPlayer");
	HX_VISIT_MEMBER_NAME(isEnemy,"isEnemy");
	HX_VISIT_MEMBER_NAME(drawOnGround,"drawOnGround");
	HX_VISIT_MEMBER_NAME(drawUnder,"drawUnder");
	HX_VISIT_MEMBER_NAME(occupySquare,"occupySquare");
	HX_VISIT_MEMBER_NAME(fullOccupy,"fullOccupy");
	HX_VISIT_MEMBER_NAME(enemyOccupySquare,"enemyOccupySquare");
	HX_VISIT_MEMBER_NAME(staticObj,"staticObj");
	HX_VISIT_MEMBER_NAME(noMiniMap,"noMiniMap");
	HX_VISIT_MEMBER_NAME(protectFromGroundDamage,"protectFromGroundDamage");
	HX_VISIT_MEMBER_NAME(protectFromSink,"protectFromSink");
	HX_VISIT_MEMBER_NAME(baseZ,"baseZ");
	HX_VISIT_MEMBER_NAME(flying,"flying");
	HX_VISIT_MEMBER_NAME(color,"color");
	HX_VISIT_MEMBER_NAME(showName,"showName");
	HX_VISIT_MEMBER_NAME(dontFaceAttacks,"dontFaceAttacks");
	HX_VISIT_MEMBER_NAME(bloodProb,"bloodProb");
	HX_VISIT_MEMBER_NAME(bloodColor,"bloodColor");
	HX_VISIT_MEMBER_NAME(shadowColor,"shadowColor");
	HX_VISIT_MEMBER_NAME(sounds,"sounds");
	HX_VISIT_MEMBER_NAME(portrait,"portrait");
	HX_VISIT_MEMBER_NAME(minSize,"minSize");
	HX_VISIT_MEMBER_NAME(maxSize,"maxSize");
	HX_VISIT_MEMBER_NAME(sizeStep,"sizeStep");
	HX_VISIT_MEMBER_NAME(whileMoving,"whileMoving");
	HX_VISIT_MEMBER_NAME(oldSound,"oldSound");
	HX_VISIT_MEMBER_NAME(projectiles,"projectiles");
	HX_VISIT_MEMBER_NAME(scepterProps,"scepterProps");
	HX_VISIT_MEMBER_NAME(angleCorrection,"angleCorrection");
	HX_VISIT_MEMBER_NAME(rotation,"rotation");
	HX_VISIT_MEMBER_NAME(floating,"floating");
	HX_VISIT_MEMBER_NAME(floatTime,"floatTime");
	HX_VISIT_MEMBER_NAME(floatHeight,"floatHeight");
	HX_VISIT_MEMBER_NAME(floatSine,"floatSine");
	HX_VISIT_MEMBER_NAME(showEffects,"showEffects");
}

::hx::Val ObjectProperties_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"objId") ) { return ::hx::Val( objId ); }
		if (HX_FIELD_EQ(inName,"baseZ") ) { return ::hx::Val( baseZ ); }
		if (HX_FIELD_EQ(inName,"color") ) { return ::hx::Val( color ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"flying") ) { return ::hx::Val( flying ); }
		if (HX_FIELD_EQ(inName,"sounds") ) { return ::hx::Val( sounds ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"objType") ) { return ::hx::Val( objType ); }
		if (HX_FIELD_EQ(inName,"isEnemy") ) { return ::hx::Val( isEnemy ); }
		if (HX_FIELD_EQ(inName,"minSize") ) { return ::hx::Val( minSize ); }
		if (HX_FIELD_EQ(inName,"maxSize") ) { return ::hx::Val( maxSize ); }
		if (HX_FIELD_EQ(inName,"getSize") ) { return ::hx::Val( getSize_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isPlayer") ) { return ::hx::Val( isPlayer ); }
		if (HX_FIELD_EQ(inName,"showName") ) { return ::hx::Val( showName ); }
		if (HX_FIELD_EQ(inName,"portrait") ) { return ::hx::Val( portrait ); }
		if (HX_FIELD_EQ(inName,"sizeStep") ) { return ::hx::Val( sizeStep ); }
		if (HX_FIELD_EQ(inName,"oldSound") ) { return ::hx::Val( oldSound ); }
		if (HX_FIELD_EQ(inName,"rotation") ) { return ::hx::Val( rotation ); }
		if (HX_FIELD_EQ(inName,"floating") ) { return ::hx::Val( floating ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"displayId") ) { return ::hx::Val( displayId ); }
		if (HX_FIELD_EQ(inName,"drawUnder") ) { return ::hx::Val( drawUnder ); }
		if (HX_FIELD_EQ(inName,"staticObj") ) { return ::hx::Val( staticObj ); }
		if (HX_FIELD_EQ(inName,"noMiniMap") ) { return ::hx::Val( noMiniMap ); }
		if (HX_FIELD_EQ(inName,"bloodProb") ) { return ::hx::Val( bloodProb ); }
		if (HX_FIELD_EQ(inName,"floatTime") ) { return ::hx::Val( floatTime ); }
		if (HX_FIELD_EQ(inName,"floatSine") ) { return ::hx::Val( floatSine ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fullOccupy") ) { return ::hx::Val( fullOccupy ); }
		if (HX_FIELD_EQ(inName,"bloodColor") ) { return ::hx::Val( bloodColor ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"shadowColor") ) { return ::hx::Val( shadowColor ); }
		if (HX_FIELD_EQ(inName,"whileMoving") ) { return ::hx::Val( whileMoving ); }
		if (HX_FIELD_EQ(inName,"projectiles") ) { return ::hx::Val( projectiles ); }
		if (HX_FIELD_EQ(inName,"floatHeight") ) { return ::hx::Val( floatHeight ); }
		if (HX_FIELD_EQ(inName,"showEffects") ) { return ::hx::Val( showEffects ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"drawOnGround") ) { return ::hx::Val( drawOnGround ); }
		if (HX_FIELD_EQ(inName,"occupySquare") ) { return ::hx::Val( occupySquare ); }
		if (HX_FIELD_EQ(inName,"scepterProps") ) { return ::hx::Val( scepterProps ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"protectFromSink") ) { return ::hx::Val( protectFromSink ); }
		if (HX_FIELD_EQ(inName,"dontFaceAttacks") ) { return ::hx::Val( dontFaceAttacks ); }
		if (HX_FIELD_EQ(inName,"angleCorrection") ) { return ::hx::Val( angleCorrection ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"enemyOccupySquare") ) { return ::hx::Val( enemyOccupySquare ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"protectFromGroundDamage") ) { return ::hx::Val( protectFromGroundDamage ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ObjectProperties_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"objId") ) { objId=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"baseZ") ) { baseZ=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color") ) { color=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"flying") ) { flying=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sounds") ) { sounds=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"objType") ) { objType=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isEnemy") ) { isEnemy=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minSize") ) { minSize=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxSize") ) { maxSize=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isPlayer") ) { isPlayer=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"showName") ) { showName=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"portrait") ) { portrait=inValue.Cast<  ::objects::TextureData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sizeStep") ) { sizeStep=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"oldSound") ) { oldSound=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rotation") ) { rotation=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floating") ) { floating=inValue.Cast< bool >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"displayId") ) { displayId=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawUnder") ) { drawUnder=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"staticObj") ) { staticObj=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"noMiniMap") ) { noMiniMap=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bloodProb") ) { bloodProb=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floatTime") ) { floatTime=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floatSine") ) { floatSine=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"fullOccupy") ) { fullOccupy=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bloodColor") ) { bloodColor=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"shadowColor") ) { shadowColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"whileMoving") ) { whileMoving=inValue.Cast<  ::objects::WhileMovingProperties >(); return inValue; }
		if (HX_FIELD_EQ(inName,"projectiles") ) { projectiles=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floatHeight") ) { floatHeight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"showEffects") ) { showEffects=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"drawOnGround") ) { drawOnGround=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"occupySquare") ) { occupySquare=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scepterProps") ) { scepterProps=inValue.Cast<  ::objects::ScepterProperties >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"protectFromSink") ) { protectFromSink=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dontFaceAttacks") ) { dontFaceAttacks=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angleCorrection") ) { angleCorrection=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"enemyOccupySquare") ) { enemyOccupySquare=inValue.Cast< bool >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"protectFromGroundDamage") ) { protectFromGroundDamage=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ObjectProperties_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("objType",51,76,23,77));
	outFields->push(HX_("objId",b2,fb,91,2a));
	outFields->push(HX_("displayId",bd,fe,da,c1));
	outFields->push(HX_("isPlayer",eb,86,22,90));
	outFields->push(HX_("isEnemy",fe,b5,00,0d));
	outFields->push(HX_("drawOnGround",2a,a5,c8,d1));
	outFields->push(HX_("drawUnder",74,c6,ee,6e));
	outFields->push(HX_("occupySquare",4c,de,62,58));
	outFields->push(HX_("fullOccupy",3e,37,fd,8a));
	outFields->push(HX_("enemyOccupySquare",b4,88,66,04));
	outFields->push(HX_("staticObj",e9,0b,15,87));
	outFields->push(HX_("noMiniMap",04,2e,be,89));
	outFields->push(HX_("protectFromGroundDamage",0f,0e,ea,58));
	outFields->push(HX_("protectFromSink",0c,7d,3a,36));
	outFields->push(HX_("baseZ",29,27,ba,ad));
	outFields->push(HX_("flying",4f,52,f8,47));
	outFields->push(HX_("color",63,71,5c,4a));
	outFields->push(HX_("showName",e8,35,86,b0));
	outFields->push(HX_("dontFaceAttacks",7d,03,6e,97));
	outFields->push(HX_("bloodProb",6f,d8,67,14));
	outFields->push(HX_("bloodColor",49,1f,42,48));
	outFields->push(HX_("shadowColor",63,8d,28,c1));
	outFields->push(HX_("sounds",c4,a8,2e,32));
	outFields->push(HX_("portrait",5b,21,af,b8));
	outFields->push(HX_("minSize",73,0f,5d,3d));
	outFields->push(HX_("maxSize",85,f9,83,cc));
	outFields->push(HX_("sizeStep",ad,a8,2e,e6));
	outFields->push(HX_("whileMoving",1f,05,2d,15));
	outFields->push(HX_("oldSound",a8,a6,97,67));
	outFields->push(HX_("projectiles",6a,a6,89,35));
	outFields->push(HX_("scepterProps",ca,fd,40,c9));
	outFields->push(HX_("angleCorrection",51,b1,a9,35));
	outFields->push(HX_("rotation",3e,3d,86,08));
	outFields->push(HX_("floating",c6,b0,9f,dd));
	outFields->push(HX_("floatTime",c9,bb,35,00));
	outFields->push(HX_("floatHeight",a3,5e,6d,a9));
	outFields->push(HX_("floatSine",09,86,8c,ff));
	outFields->push(HX_("showEffects",45,81,e7,0a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ObjectProperties_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,objType),HX_("objType",51,76,23,77)},
	{::hx::fsString,(int)offsetof(ObjectProperties_obj,objId),HX_("objId",b2,fb,91,2a)},
	{::hx::fsString,(int)offsetof(ObjectProperties_obj,displayId),HX_("displayId",bd,fe,da,c1)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,isPlayer),HX_("isPlayer",eb,86,22,90)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,isEnemy),HX_("isEnemy",fe,b5,00,0d)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,drawOnGround),HX_("drawOnGround",2a,a5,c8,d1)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,drawUnder),HX_("drawUnder",74,c6,ee,6e)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,occupySquare),HX_("occupySquare",4c,de,62,58)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,fullOccupy),HX_("fullOccupy",3e,37,fd,8a)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,enemyOccupySquare),HX_("enemyOccupySquare",b4,88,66,04)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,staticObj),HX_("staticObj",e9,0b,15,87)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,noMiniMap),HX_("noMiniMap",04,2e,be,89)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,protectFromGroundDamage),HX_("protectFromGroundDamage",0f,0e,ea,58)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,protectFromSink),HX_("protectFromSink",0c,7d,3a,36)},
	{::hx::fsFloat,(int)offsetof(ObjectProperties_obj,baseZ),HX_("baseZ",29,27,ba,ad)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,flying),HX_("flying",4f,52,f8,47)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,color),HX_("color",63,71,5c,4a)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,showName),HX_("showName",e8,35,86,b0)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,dontFaceAttacks),HX_("dontFaceAttacks",7d,03,6e,97)},
	{::hx::fsFloat,(int)offsetof(ObjectProperties_obj,bloodProb),HX_("bloodProb",6f,d8,67,14)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,bloodColor),HX_("bloodColor",49,1f,42,48)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,shadowColor),HX_("shadowColor",63,8d,28,c1)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(ObjectProperties_obj,sounds),HX_("sounds",c4,a8,2e,32)},
	{::hx::fsObject /*  ::objects::TextureData */ ,(int)offsetof(ObjectProperties_obj,portrait),HX_("portrait",5b,21,af,b8)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,minSize),HX_("minSize",73,0f,5d,3d)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,maxSize),HX_("maxSize",85,f9,83,cc)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,sizeStep),HX_("sizeStep",ad,a8,2e,e6)},
	{::hx::fsObject /*  ::objects::WhileMovingProperties */ ,(int)offsetof(ObjectProperties_obj,whileMoving),HX_("whileMoving",1f,05,2d,15)},
	{::hx::fsString,(int)offsetof(ObjectProperties_obj,oldSound),HX_("oldSound",a8,a6,97,67)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(ObjectProperties_obj,projectiles),HX_("projectiles",6a,a6,89,35)},
	{::hx::fsObject /*  ::objects::ScepterProperties */ ,(int)offsetof(ObjectProperties_obj,scepterProps),HX_("scepterProps",ca,fd,40,c9)},
	{::hx::fsFloat,(int)offsetof(ObjectProperties_obj,angleCorrection),HX_("angleCorrection",51,b1,a9,35)},
	{::hx::fsFloat,(int)offsetof(ObjectProperties_obj,rotation),HX_("rotation",3e,3d,86,08)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,floating),HX_("floating",c6,b0,9f,dd)},
	{::hx::fsInt,(int)offsetof(ObjectProperties_obj,floatTime),HX_("floatTime",c9,bb,35,00)},
	{::hx::fsFloat,(int)offsetof(ObjectProperties_obj,floatHeight),HX_("floatHeight",a3,5e,6d,a9)},
	{::hx::fsBool,(int)offsetof(ObjectProperties_obj,floatSine),HX_("floatSine",09,86,8c,ff)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ObjectProperties_obj,showEffects),HX_("showEffects",45,81,e7,0a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ObjectProperties_obj_sStaticStorageInfo = 0;
#endif

static ::String ObjectProperties_obj_sMemberFields[] = {
	HX_("objType",51,76,23,77),
	HX_("objId",b2,fb,91,2a),
	HX_("displayId",bd,fe,da,c1),
	HX_("isPlayer",eb,86,22,90),
	HX_("isEnemy",fe,b5,00,0d),
	HX_("drawOnGround",2a,a5,c8,d1),
	HX_("drawUnder",74,c6,ee,6e),
	HX_("occupySquare",4c,de,62,58),
	HX_("fullOccupy",3e,37,fd,8a),
	HX_("enemyOccupySquare",b4,88,66,04),
	HX_("staticObj",e9,0b,15,87),
	HX_("noMiniMap",04,2e,be,89),
	HX_("protectFromGroundDamage",0f,0e,ea,58),
	HX_("protectFromSink",0c,7d,3a,36),
	HX_("baseZ",29,27,ba,ad),
	HX_("flying",4f,52,f8,47),
	HX_("color",63,71,5c,4a),
	HX_("showName",e8,35,86,b0),
	HX_("dontFaceAttacks",7d,03,6e,97),
	HX_("bloodProb",6f,d8,67,14),
	HX_("bloodColor",49,1f,42,48),
	HX_("shadowColor",63,8d,28,c1),
	HX_("sounds",c4,a8,2e,32),
	HX_("portrait",5b,21,af,b8),
	HX_("minSize",73,0f,5d,3d),
	HX_("maxSize",85,f9,83,cc),
	HX_("sizeStep",ad,a8,2e,e6),
	HX_("whileMoving",1f,05,2d,15),
	HX_("oldSound",a8,a6,97,67),
	HX_("projectiles",6a,a6,89,35),
	HX_("scepterProps",ca,fd,40,c9),
	HX_("angleCorrection",51,b1,a9,35),
	HX_("rotation",3e,3d,86,08),
	HX_("floating",c6,b0,9f,dd),
	HX_("floatTime",c9,bb,35,00),
	HX_("floatHeight",a3,5e,6d,a9),
	HX_("floatSine",09,86,8c,ff),
	HX_("showEffects",45,81,e7,0a),
	HX_("getSize",77,50,d6,1e),
	::String(null()) };

::hx::Class ObjectProperties_obj::__mClass;

void ObjectProperties_obj::__register()
{
	ObjectProperties_obj _hx_dummy;
	ObjectProperties_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.ObjectProperties",8c,04,e3,1a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ObjectProperties_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ObjectProperties_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ObjectProperties_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ObjectProperties_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace objects
