// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_game_GameSprite
#include <game/GameSprite.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_lime_system_System
#include <lime/system/System.h>
#endif
#ifndef INCLUDED_map_CharacterStatusText
#include <map/CharacterStatusText.h>
#endif
#ifndef INCLUDED_map_Map
#include <map/Map.h>
#endif
#ifndef INCLUDED_map_Square
#include <map/Square.h>
#endif
#ifndef INCLUDED_network_NetworkHandler
#include <network/NetworkHandler.h>
#endif
#ifndef INCLUDED_objects_GameObject
#include <objects/GameObject.h>
#endif
#ifndef INCLUDED_objects_ObjectLibrary
#include <objects/ObjectLibrary.h>
#endif
#ifndef INCLUDED_objects_ObjectProperties
#include <objects/ObjectProperties.h>
#endif
#ifndef INCLUDED_objects_Player
#include <objects/Player.h>
#endif
#ifndef INCLUDED_objects_Projectile
#include <objects/Projectile.h>
#endif
#ifndef INCLUDED_objects_TextureData
#include <objects/TextureData.h>
#endif
#ifndef INCLUDED_objects_animation_Animations
#include <objects/animation/Animations.h>
#endif
#ifndef INCLUDED_objects_animation_AnimationsData
#include <objects/animation/AnimationsData.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Vector3D
#include <openfl/geom/Vector3D.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif
#ifndef INCLUDED_sound_SoundEffectLibrary
#include <sound/SoundEffectLibrary.h>
#endif
#ifndef INCLUDED_ui_SimpleText
#include <ui/SimpleText.h>
#endif
#ifndef INCLUDED_util_AnimatedChar
#include <util/AnimatedChar.h>
#endif
#ifndef INCLUDED_util_BitmapUtil
#include <util/BitmapUtil.h>
#endif
#ifndef INCLUDED_util_BloodComposition
#include <util/BloodComposition.h>
#endif
#ifndef INCLUDED_util_MathUtil
#include <util/MathUtil.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_33_new,"objects.GameObject","new",0xa76df43d,"objects.GameObject.new","objects/GameObject.hx",33,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_211_dispose,"objects.GameObject","dispose",0x3d4256fc,"objects.GameObject.dispose","objects/GameObject.hx",211,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_225_addTo,"objects.GameObject","addTo",0x59145b19,"objects.GameObject.addTo","objects/GameObject.hx",225,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_246_removeFromMap,"objects.GameObject","removeFromMap",0x24feb18b,"objects.GameObject.removeFromMap","objects/GameObject.hx",246,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_259_update,"objects.GameObject","update",0x80b76a4c,"objects.GameObject.update","objects/GameObject.hx",259,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_296_setObjectId,"objects.GameObject","setObjectId",0x2069bf19,"objects.GameObject.setObjectId","objects/GameObject.hx",296,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_313_setAltTexture,"objects.GameObject","setAltTexture",0xc6dc1711,"objects.GameObject.setAltTexture","objects/GameObject.hx",313,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_339_playSound,"objects.GameObject","playSound",0xed8ea1d8,"objects.GameObject.playSound","objects/GameObject.hx",339,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_383_getColor,"objects.GameObject","getColor",0xdf593bf0,"objects.GameObject.getColor","objects/GameObject.hx",383,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_392_distTo,"objects.GameObject","distTo",0xb6d0bac4,"objects.GameObject.distTo","objects/GameObject.hx",392,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_398_moveTo,"objects.GameObject","moveTo",0xc65eb72f,"objects.GameObject.moveTo","objects/GameObject.hx",398,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_413_onGoto,"objects.GameObject","onGoto",0xe0a586a5,"objects.GameObject.onGoto","objects/GameObject.hx",413,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_424_onTickPos,"objects.GameObject","onTickPos",0x3e5daa75,"objects.GameObject.onTickPos","objects/GameObject.hx",424,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_438_damage,"objects.GameObject","damage",0x179674b2,"objects.GameObject.damage","objects/GameObject.hx",438,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_473_setAttack,"objects.GameObject","setAttack",0x8b9558a7,"objects.GameObject.setAttack","objects/GameObject.hx",473,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_120_physicalDamage,"objects.GameObject","physicalDamage",0x3e5bf529,"objects.GameObject.physicalDamage","objects/GameObject.hx",120,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_133_magicDamage,"objects.GameObject","magicDamage",0xe3dfde59,"objects.GameObject.magicDamage","objects/GameObject.hx",133,0x88e17532)
HX_LOCAL_STACK_FRAME(_hx_pos_c1f95aaf717b8ccd_143_trueDamage,"objects.GameObject","trueDamage",0x060adc20,"objects.GameObject.trueDamage","objects/GameObject.hx",143,0x88e17532)
namespace objects{

void GameObject_obj::__construct( ::Xml objectXML,::String objClass){
            	HX_GC_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_33_new)
HXLINE( 118)		this->bloodColors = null();
HXLINE( 117)		this->mapColor = ( (unsigned int)(0) );
HXLINE( 111)		this->floatTimeOffset = 0;
HXLINE( 107)		this->sizeMult = ( (float)(((Float)1.0)) );
HXLINE( 106)		this->nextBulletId = ( (signed char)(1) );
HXLINE( 100)		this->lastTickUpdateTime = 0;
HXLINE(  97)		this->myLastTickId = -1;
HXLINE(  96)		this->portrait = null();
HXLINE(  94)		this->objClass = HX_("",00,00,00,00);
HXLINE(  92)		this->ownerId = -1;
HXLINE(  90)		this->enterKeyTex = null();
HXLINE(  89)		this->enterTex = null();
HXLINE(  88)		this->nameTex = null();
HXLINE(  87)		this->nameText = null();
HXLINE(  86)		this->glowColor = ( (float)(((Float)0.0)) );
HXLINE(  85)		this->flashColor = ( (float)(((Float)0.0)) );
HXLINE(  84)		this->flashRepeats = ( (float)(((Float)0.0)) );
HXLINE(  83)		this->flashPeriodMs = ( (float)(((Float)0.0)) );
HXLINE(  82)		this->flashStartTime = ( (float)(((Float)0.0)) );
HXLINE(  81)		this->sinkLevel = ( (float)(((Float)0.0)) );
HXLINE(  80)		this->objectType = 0;
HXLINE(  78)		this->condition = 0;
HXLINE(  77)		this->equipment = null();
HXLINE(  76)		this->slotTypes = null();
HXLINE(  75)		this->resistance = 0;
HXLINE(  74)		this->defense = 0;
HXLINE(  73)		this->size = ( (float)(1) );
HXLINE(  72)		this->hp = 200;
HXLINE(  71)		this->maxHP = 200;
HXLINE(  70)		this->dead = false;
HXLINE(  69)		this->animations = null();
HXLINE(  68)		this->randomTextureData = null();
HXLINE(  67)		this->maskHeight = ( (float)(((Float)0.0)) );
HXLINE(  66)		this->maskWidth = ( (float)(((Float)0.0)) );
HXLINE(  65)		this->maskVValue = ( (float)(((Float)0.0)) );
HXLINE(  64)		this->maskUValue = ( (float)(((Float)0.0)) );
HXLINE(  63)		this->height = ( (float)(((Float)0.0)) );
HXLINE(  62)		this->width = ( (float)(((Float)0.0)) );
HXLINE(  61)		this->topVValue = ( (float)(((Float)0.0)) );
HXLINE(  60)		this->topUValue = ( (float)(((Float)0.0)) );
HXLINE(  59)		this->vValue = ( (float)(((Float)0.0)) );
HXLINE(  58)		this->uValue = ( (float)(((Float)0.0)) );
HXLINE(  57)		this->animatedChar = null();
HXLINE(  56)		this->attackStart = 0;
HXLINE(  55)		this->attackAngle = ( (float)(((Float)0.0)) );
HXLINE(  54)		this->lastFloatUpdate = -1;
HXLINE(  53)		this->floatFlip = false;
HXLINE(  52)		this->flying = false;
HXLINE(  51)		this->facing = ( (float)(((Float)0.0)) );
HXLINE(  50)		this->name = HX_("",00,00,00,00);
HXLINE(  47)		this->hBase = ( (float)(((Float)0.0)) );
HXLINE(  46)		this->screenYNoZ = ( (float)(((Float)0.0)) );
HXLINE(  44)		this->screenX = ( (float)(((Float)0.0)) );
HXLINE(  43)		this->mapZ = ( (float)(((Float)0.0)) );
HXLINE(  42)		this->mapY = ( (float)(((Float)0.0)) );
HXLINE(  41)		this->mapX = ( (float)(((Float)0.0)) );
HXLINE(  40)		this->objectId = 0;
HXLINE( 151)		this->props = ::objects::ObjectLibrary_obj::defaultProps;
HXLINE( 152)		this->objClass = objClass;
HXLINE( 153)		this->posAtTick =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 154)		this->tickPosition =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 155)		this->moveVec =  ::openfl::geom::Vector3D_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 156)		if (::hx::IsNull( objectXML )) {
HXLINE( 157)			return;
            		}
HXLINE( 159)		int _hx_tmp;
HXDLIN( 159)		if (::hx::IsNotNull( objectXML->get(HX_("type",ba,f2,08,4d)) )) {
HXLINE( 159)			_hx_tmp = ( (int)(::Std_obj::parseInt(objectXML->get(HX_("type",ba,f2,08,4d)))) );
            		}
            		else {
HXLINE( 159)			_hx_tmp = 0;
            		}
HXDLIN( 159)		this->objectType = _hx_tmp;
HXLINE( 160)		this->props = ( ( ::objects::ObjectProperties)(::objects::ObjectLibrary_obj::propsLibrary->get(this->objectType)) );
HXLINE( 161)		this->size = ( (float)((( (Float)(this->props->getSize()) ) / ( (Float)(100) ))) );
HXLINE( 162)		 ::objects::TextureData textureData = ( ( ::objects::TextureData)(::objects::ObjectLibrary_obj::typeToTextureData->get(this->objectType)) );
HXLINE( 163)		this->mapColor = ( (unsigned int)(::util::BitmapUtil_obj::mostCommonColor(textureData->texture)) );
HXLINE( 164)		this->bloodColors = ::util::BloodComposition_obj::getBloodComposition(this->objectType,textureData->texture,this->props->bloodProb,this->props->bloodColor);
HXLINE( 165)		this->uValue = textureData->uValue;
HXLINE( 166)		this->vValue = textureData->vValue;
HXLINE( 167)		this->width = textureData->width;
HXLINE( 168)		this->height = textureData->height;
HXLINE( 169)		this->maskUValue = textureData->maskUValue;
HXLINE( 170)		this->maskVValue = textureData->maskVValue;
HXLINE( 171)		this->maskWidth = textureData->maskWidth;
HXLINE( 172)		this->maskHeight = textureData->maskHeight;
HXLINE( 173)		this->animatedChar = textureData->animatedChar;
HXLINE( 174)		this->randomTextureData = textureData->randomTextureData;
HXLINE( 175)		if (::objects::ObjectLibrary_obj::typeToTopTextureData->exists(this->objectType)) {
HXLINE( 176)			 ::objects::TextureData topTextureData = ( ( ::objects::TextureData)(::objects::ObjectLibrary_obj::typeToTopTextureData->get(this->objectType)) );
HXLINE( 177)			::Array< ::Dynamic> topRandTexData = topTextureData->randomTextureData;
HXLINE( 178)			if (::hx::IsNotNull( topRandTexData )) {
HXLINE( 179)				 ::objects::TextureData randTex = topRandTexData->__get(::Math_obj::floor((::Math_obj::random() * ( (Float)(this->randomTextureData->length) )))).StaticCast<  ::objects::TextureData >();
HXLINE( 182)				this->topUValue = randTex->uValue;
HXLINE( 183)				this->topVValue = randTex->vValue;
            			}
            			else {
HXLINE( 185)				this->topUValue = topTextureData->uValue;
HXLINE( 186)				this->topVValue = topTextureData->vValue;
            			}
            		}
HXLINE( 191)		float _hx_tmp1;
HXDLIN( 191)		if ((this->width == 0)) {
HXLINE( 191)			_hx_tmp1 = ( (float)(1) );
            		}
            		else {
HXLINE( 191)			_hx_tmp1 = ( (float)((( (Float)(this->width) ) * ((Float)128.))) );
            		}
HXDLIN( 191)		this->sizeMult = _hx_tmp1;
HXLINE( 193)		 ::objects::animation::AnimationsData animationsData = ( ( ::objects::animation::AnimationsData)(::objects::ObjectLibrary_obj::typeToAnimationsData->get(this->objectType)) );
HXLINE( 194)		if (::hx::IsNotNull( animationsData )) {
HXLINE( 195)			this->animations =  ::objects::animation::Animations_obj::__alloc( HX_CTX ,animationsData);
            		}
HXLINE( 197)		this->mapZ = ( (float)(this->props->baseZ) );
HXLINE( 198)		this->flying = this->props->flying;
HXLINE( 199)		int _hx_tmp2;
HXDLIN( 199)		if (( (bool)(objectXML->elementsNamed(HX_("Health",bc,9c,9a,31))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 199)			 ::Xml _this = ( ( ::Xml)(objectXML->elementsNamed(HX_("Health",bc,9c,9a,31))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 199)			bool _hx_tmp3;
HXDLIN( 199)			if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE( 199)				_hx_tmp3 = (_this->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 199)				_hx_tmp3 = false;
            			}
HXDLIN( 199)			if (_hx_tmp3) {
HXLINE( 199)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            			}
HXDLIN( 199)			 ::Xml _this1 = _this->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 199)			bool _hx_tmp4;
HXDLIN( 199)			if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE( 199)				_hx_tmp4 = (_this1->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 199)				_hx_tmp4 = true;
            			}
HXDLIN( 199)			if (_hx_tmp4) {
HXLINE( 199)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            			}
HXDLIN( 199)			_hx_tmp2 = ( (int)(::Std_obj::parseInt(_this1->nodeValue)) );
            		}
            		else {
HXLINE( 199)			_hx_tmp2 = 0;
            		}
HXDLIN( 199)		this->hp = (this->maxHP = _hx_tmp2);
HXLINE( 200)		int _hx_tmp5;
HXDLIN( 200)		if (( (bool)(objectXML->elementsNamed(HX_("Defense",60,91,b4,6b))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 200)			 ::Xml _this2 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Defense",60,91,b4,6b))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 200)			bool _hx_tmp6;
HXDLIN( 200)			if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE( 200)				_hx_tmp6 = (_this2->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 200)				_hx_tmp6 = false;
            			}
HXDLIN( 200)			if (_hx_tmp6) {
HXLINE( 200)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            			}
HXDLIN( 200)			 ::Xml _this3 = _this2->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 200)			bool _hx_tmp7;
HXDLIN( 200)			if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE( 200)				_hx_tmp7 = (_this3->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 200)				_hx_tmp7 = true;
            			}
HXDLIN( 200)			if (_hx_tmp7) {
HXLINE( 200)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            			}
HXDLIN( 200)			_hx_tmp5 = ( (int)(::Std_obj::parseInt(_this3->nodeValue)) );
            		}
            		else {
HXLINE( 200)			_hx_tmp5 = 0;
            		}
HXDLIN( 200)		this->defense = _hx_tmp5;
HXLINE( 201)		int _hx_tmp8;
HXDLIN( 201)		if (( (bool)(objectXML->elementsNamed(HX_("Resistance",d9,15,07,97))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 201)			 ::Xml _this4 = ( ( ::Xml)(objectXML->elementsNamed(HX_("Resistance",d9,15,07,97))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 201)			bool _hx_tmp9;
HXDLIN( 201)			if ((_this4->nodeType != ::Xml_obj::Document)) {
HXLINE( 201)				_hx_tmp9 = (_this4->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 201)				_hx_tmp9 = false;
            			}
HXDLIN( 201)			if (_hx_tmp9) {
HXLINE( 201)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this4->nodeType)));
            			}
HXDLIN( 201)			 ::Xml _this5 = _this4->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 201)			bool _hx_tmp10;
HXDLIN( 201)			if ((_this5->nodeType != ::Xml_obj::Document)) {
HXLINE( 201)				_hx_tmp10 = (_this5->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 201)				_hx_tmp10 = true;
            			}
HXDLIN( 201)			if (_hx_tmp10) {
HXLINE( 201)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this5->nodeType)));
            			}
HXDLIN( 201)			_hx_tmp8 = ( (int)(::Std_obj::parseInt(_this5->nodeValue)) );
            		}
            		else {
HXLINE( 201)			_hx_tmp8 = 0;
            		}
HXDLIN( 201)		this->resistance = _hx_tmp8;
HXLINE( 202)		::Array< int > _hx_tmp11;
HXDLIN( 202)		if (( (bool)(objectXML->elementsNamed(HX_("SlotTypes",7b,69,ba,9c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 202)			 ::Xml _this6 = ( ( ::Xml)(objectXML->elementsNamed(HX_("SlotTypes",7b,69,ba,9c))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 202)			bool _this7;
HXDLIN( 202)			if ((_this6->nodeType != ::Xml_obj::Document)) {
HXLINE( 202)				_this7 = (_this6->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 202)				_this7 = false;
            			}
HXDLIN( 202)			if (_this7) {
HXLINE( 202)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this6->nodeType)));
            			}
HXDLIN( 202)			 ::Xml _this8 = _this6->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 202)			bool _this9;
HXDLIN( 202)			if ((_this8->nodeType != ::Xml_obj::Document)) {
HXLINE( 202)				_this9 = (_this8->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 202)				_this9 = true;
            			}
HXDLIN( 202)			if (_this9) {
HXLINE( 202)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this8->nodeType)));
            			}
HXDLIN( 202)			::Array< ::String > _this10 = _this8->nodeValue.split(HX_(",",2c,00,00,00));
HXDLIN( 202)			::Array< int > result = ::Array_obj< int >::__new(_this10->length);
HXDLIN( 202)			{
HXLINE( 202)				int _g = 0;
HXDLIN( 202)				int _g1 = _this10->length;
HXDLIN( 202)				while((_g < _g1)){
HXLINE( 202)					_g = (_g + 1);
HXDLIN( 202)					int i = (_g - 1);
HXDLIN( 202)					{
HXLINE( 202)						int inValue = ::hx::TCast< int >::cast(::Std_obj::parseInt(( (::String)(_hx_array_unsafe_get(_this10,i)) )));
HXDLIN( 202)						result->__unsafe_set(i,inValue);
            					}
            				}
            			}
HXDLIN( 202)			_hx_tmp11 = result;
            		}
            		else {
HXLINE( 202)			_hx_tmp11 = ::Array_obj< int >::__new();
            		}
HXDLIN( 202)		this->slotTypes = _hx_tmp11;
HXLINE( 203)		this->equipment = ::Array_obj< int >::__new();
HXLINE( 204)		{
HXLINE( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
HXDLIN( 205)			this->equipment->push(-1);
            		}
HXLINE( 207)		bool _hx_tmp12;
HXDLIN( 207)		if (!(this->props->showName)) {
HXLINE( 207)			_hx_tmp12 = (objClass == HX_("Portal",cc,ee,b9,31));
            		}
            		else {
HXLINE( 207)			_hx_tmp12 = true;
            		}
HXDLIN( 207)		if (_hx_tmp12) {
HXLINE( 208)			this->name = this->props->displayId;
            		}
            	}

Dynamic GameObject_obj::__CreateEmpty() { return new GameObject_obj; }

void *GameObject_obj::_hx_vtable = 0;

Dynamic GameObject_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GameObject_obj > _hx_result = new GameObject_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool GameObject_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0cff6b45;
}

void GameObject_obj::dispose(){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_211_dispose)
HXLINE( 212)		this->map = null();
HXLINE( 213)		this->curSquare = null();
HXLINE( 214)		if (::hx::IsNotNull( this->portrait )) {
HXLINE( 215)			this->portrait->dispose();
HXLINE( 216)			this->portrait = null();
            		}
HXLINE( 219)		if (::hx::IsNotNull( this->nameTex )) {
HXLINE( 220)			this->nameTex->dispose();
HXLINE( 221)			this->nameTex = null();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(GameObject_obj,dispose,(void))

bool GameObject_obj::addTo( ::map::Map map,float x,float y){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_225_addTo)
HXLINE( 226)		this->map = map;
HXLINE( 227)		this->posAtTick->x = (this->tickPosition->x = ( (Float)(x) ));
HXLINE( 228)		this->posAtTick->y = (this->tickPosition->y = ( (Float)(y) ));
HXLINE( 229)		this->moveTo(x,y);
HXLINE( 240)		if (this->props->floating) {
HXLINE( 241)			this->floatTimeOffset = ::Std_obj::_hx_int((::Math_obj::random() * ( (Float)(this->props->floatTime) )));
            		}
HXLINE( 243)		return true;
            	}


void GameObject_obj::removeFromMap(){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_246_removeFromMap)
HXLINE( 247)		bool _hx_tmp;
HXDLIN( 247)		if (this->props->staticObj) {
HXLINE( 247)			_hx_tmp = ::hx::IsNotNull( this->curSquare );
            		}
            		else {
HXLINE( 247)			_hx_tmp = false;
            		}
HXDLIN( 247)		if (_hx_tmp) {
HXLINE( 248)			if (::hx::IsInstanceEq( this->curSquare->obj,::hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 249)				this->curSquare->obj = null();
            			}
HXLINE( 251)			this->curSquare = null();
            		}
HXLINE( 254)		this->map = null();
HXLINE( 255)		this->curSquare = null();
HXLINE( 256)		this->dispose();
            	}


HX_DEFINE_DYNAMIC_FUNC0(GameObject_obj,removeFromMap,(void))

bool GameObject_obj::update(int time,short dt){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_259_update)
HXLINE( 260)		bool _hx_tmp;
HXDLIN( 260)		if ((this->moveVec->x == 0)) {
HXLINE( 260)			_hx_tmp = (this->moveVec->y == 0);
            		}
            		else {
HXLINE( 260)			_hx_tmp = false;
            		}
HXDLIN( 260)		if (!(_hx_tmp)) {
HXLINE( 261)			if ((this->myLastTickId < ::network::NetworkHandler_obj::lastTickId)) {
HXLINE( 262)				this->moveVec->x = ( (Float)(0) );
HXLINE( 263)				this->moveVec->y = ( (Float)(0) );
HXLINE( 264)				this->moveTo(( (float)(this->tickPosition->x) ),( (float)(this->tickPosition->y) ));
            			}
            			else {
HXLINE( 266)				int tickDT = (time - this->lastTickUpdateTime);
HXLINE( 267)				this->moveTo(( (float)((this->posAtTick->x + (( (Float)(tickDT) ) * this->moveVec->x))) ),( (float)((this->posAtTick->y + (( (Float)(tickDT) ) * this->moveVec->y))) ));
            			}
            		}
HXLINE( 271)		if ((this->objectId != this->map->player->objectId)) {
HXLINE( 272)			float scaleDt = ( (float)((( (Float)(dt) ) * ((Float)0.01))) );
HXLINE( 273)			this->moveTo(( (float)(((( (Float)(scaleDt) ) * this->tickPosition->x) + ((( (float)(1) ) - scaleDt) * this->mapX))) ),( (float)(((( (Float)(scaleDt) ) * this->tickPosition->y) + ((( (float)(1) ) - scaleDt) * this->mapY))) ));
            		}
HXLINE( 276)		bool _hx_tmp1;
HXDLIN( 276)		if (this->props->floating) {
HXLINE( 276)			_hx_tmp1 = ((time - this->lastFloatUpdate) >= 16);
            		}
            		else {
HXLINE( 276)			_hx_tmp1 = false;
            		}
HXDLIN( 276)		if (_hx_tmp1) {
HXLINE( 277)			int floatTime = this->props->floatTime;
HXLINE( 278)			Float floatHeight = this->props->floatHeight;
HXLINE( 280)			if (this->props->floatSine) {
HXLINE( 281)				this->mapZ = ( (float)(((floatHeight / ( (Float)(2) )) * ( (Float)((::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(( (float)((( (Float)((time + this->floatTimeOffset)) ) / ( (Float)(floatTime) ))) )) ) * ((Float)10430.3783504704534))) & 65535)] + 1)) ))) );
            			}
            			else {
HXLINE( 283)				float _hx_tmp2;
HXDLIN( 283)				if (this->floatFlip) {
HXLINE( 283)					_hx_tmp2 = ( (float)((( (Float)(this->mapZ) ) - (((Float)0.00001) * ( (Float)(floatTime) )))) );
            				}
            				else {
HXLINE( 283)					_hx_tmp2 = ( (float)((this->mapZ + (((Float)0.00001) * ( (Float)(floatTime) )))) );
            				}
HXDLIN( 283)				this->mapZ = _hx_tmp2;
HXLINE( 284)				if ((this->mapZ >= floatHeight)) {
HXLINE( 285)					this->floatFlip = true;
            				}
HXLINE( 286)				if ((this->mapZ <= 0)) {
HXLINE( 287)					this->floatFlip = false;
            				}
            			}
HXLINE( 290)			this->lastFloatUpdate = time;
            		}
HXLINE( 293)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(GameObject_obj,update,return )

void GameObject_obj::setObjectId(int objId){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_296_setObjectId)
HXLINE( 297)		 ::objects::TextureData textureData = null();
HXLINE( 298)		this->objectId = objId;
HXLINE( 299)		if (::hx::IsNotNull( this->randomTextureData )) {
HXLINE( 300)			textureData = this->randomTextureData->__get(::hx::Mod(objId,this->randomTextureData->length)).StaticCast<  ::objects::TextureData >();
HXLINE( 301)			this->uValue = textureData->uValue;
HXLINE( 302)			this->vValue = textureData->vValue;
HXLINE( 303)			this->width = textureData->width;
HXLINE( 304)			this->height = textureData->height;
HXLINE( 305)			this->maskUValue = textureData->maskUValue;
HXLINE( 306)			this->maskVValue = textureData->maskVValue;
HXLINE( 307)			this->maskWidth = textureData->maskWidth;
HXLINE( 308)			this->maskHeight = textureData->maskHeight;
HXLINE( 309)			this->animatedChar = textureData->animatedChar;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameObject_obj,setObjectId,(void))

void GameObject_obj::setAltTexture(int altTextureId){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_313_setAltTexture)
HXLINE( 314)		if (::hx::IsNotNull( this->randomTextureData )) {
HXLINE( 315)			return;
            		}
HXLINE( 317)		 ::objects::TextureData altTextureData;
HXLINE( 318)		 ::objects::TextureData textureData = ( ( ::objects::TextureData)(::objects::ObjectLibrary_obj::typeToTextureData->get(this->objectType)) );
HXLINE( 319)		if ((altTextureId == 0)) {
HXLINE( 320)			altTextureData = textureData;
            		}
            		else {
HXLINE( 322)			altTextureData = textureData->getAltTextureData(altTextureId);
HXLINE( 323)			if (::hx::IsNull( altTextureData )) {
HXLINE( 324)				return;
            			}
            		}
HXLINE( 327)		this->uValue = altTextureData->uValue;
HXLINE( 328)		this->vValue = altTextureData->vValue;
HXLINE( 329)		this->width = altTextureData->width;
HXLINE( 330)		this->height = altTextureData->height;
HXLINE( 331)		this->maskUValue = altTextureData->maskUValue;
HXLINE( 332)		this->maskVValue = altTextureData->maskVValue;
HXLINE( 333)		this->maskWidth = altTextureData->maskWidth;
HXLINE( 334)		this->maskHeight = altTextureData->maskHeight;
HXLINE( 335)		this->animatedChar = altTextureData->animatedChar;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameObject_obj,setAltTexture,(void))

void GameObject_obj::playSound(int id){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_339_playSound)
HXDLIN( 339)		::sound::SoundEffectLibrary_obj::play(this->props->sounds->get_string(id),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(GameObject_obj,playSound,(void))

unsigned int GameObject_obj::getColor(){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_383_getColor)
HXDLIN( 383)		return this->mapColor;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GameObject_obj,getColor,return )

Float GameObject_obj::distTo(float x,float y){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_392_distTo)
HXLINE( 393)		float dx = (x - this->mapX);
HXLINE( 394)		float dy = (y - this->mapY);
HXLINE( 395)		return ::Math_obj::sqrt(( (Float)(((dx * dx) + (dy * dy))) ));
            	}


HX_DEFINE_DYNAMIC_FUNC2(GameObject_obj,distTo,return )

bool GameObject_obj::moveTo(float x,float y){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_398_moveTo)
HXLINE( 399)		 ::map::Map square = this->map;
HXDLIN( 399)		int square1 = ::Std_obj::_hx_int(( (Float)(x) ));
HXDLIN( 399)		 ::map::Square square2 = square->lookupSquare(( (unsigned short)(square1) ),( (unsigned short)(::Std_obj::_hx_int(( (Float)(y) ))) ));
HXLINE( 400)		this->mapX = x;
HXLINE( 401)		this->mapY = y;
HXLINE( 402)		if (this->props->staticObj) {
HXLINE( 403)			if (::hx::IsNotNull( this->curSquare )) {
HXLINE( 404)				this->curSquare->obj = null();
            			}
HXLINE( 405)			if (::hx::IsNotNull( square2 )) {
HXLINE( 406)				square2->obj = ::hx::ObjectPtr<OBJ_>(this);
            			}
            		}
HXLINE( 409)		this->curSquare = square2;
HXLINE( 410)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(GameObject_obj,moveTo,return )

void GameObject_obj::onGoto(float x,float y,int time){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_413_onGoto)
HXLINE( 414)		this->moveTo(x,y);
HXLINE( 415)		this->lastTickUpdateTime = time;
HXLINE( 416)		this->tickPosition->x = ( (Float)(x) );
HXLINE( 417)		this->tickPosition->y = ( (Float)(y) );
HXLINE( 418)		this->posAtTick->x = ( (Float)(x) );
HXLINE( 419)		this->posAtTick->y = ( (Float)(y) );
HXLINE( 420)		this->moveVec->x = ( (Float)(0) );
HXLINE( 421)		this->moveVec->y = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC3(GameObject_obj,onGoto,(void))

void GameObject_obj::onTickPos(float x,float y,int tickTime,int tickId){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_424_onTickPos)
HXLINE( 425)		if ((this->myLastTickId < ::network::NetworkHandler_obj::lastTickId)) {
HXLINE( 426)			this->moveTo(( (float)(this->tickPosition->x) ),( (float)(this->tickPosition->y) ));
            		}
HXLINE( 428)		this->lastTickUpdateTime = ::Global_obj::gameSprite->lastUpdate;
HXLINE( 429)		this->tickPosition->x = ( (Float)(x) );
HXLINE( 430)		this->tickPosition->y = ( (Float)(y) );
HXLINE( 431)		this->posAtTick->x = ( (Float)(this->mapX) );
HXLINE( 432)		this->posAtTick->y = ( (Float)(this->mapY) );
HXLINE( 433)		this->moveVec->x = ((this->tickPosition->x - this->posAtTick->x) / ( (Float)(tickTime) ));
HXLINE( 434)		this->moveVec->y = ((this->tickPosition->y - this->posAtTick->y) / ( (Float)(tickTime) ));
HXLINE( 435)		this->myLastTickId = tickId;
            	}


HX_DEFINE_DYNAMIC_FUNC4(GameObject_obj,onTickPos,(void))

void GameObject_obj::damage(int origType,int damageAmount,::Array< int > effects,bool kill, ::objects::Projectile proj,::hx::Null< unsigned int >  __o_textColor){
            		unsigned int textColor = __o_textColor.Default(11542560);
            	HX_GC_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_438_damage)
HXLINE( 439)		if (kill) {
HXLINE( 440)			this->dead = true;
            		}
            		else {
HXLINE( 441)			if (::hx::IsNotNull( effects )) {
HXLINE( 442)				int _g = 0;
HXDLIN( 442)				while((_g < effects->length)){
HXLINE( 442)					int conditionEffect = effects->__get(_g);
HXDLIN( 442)					_g = (_g + 1);
HXLINE( 444)					switch((int)(conditionEffect)){
            						case (int)2: {
            						}
            						break;
            						case (int)3: {
            						}
            						break;
            						case (int)4: {
            						}
            						break;
            						case (int)5: {
            						}
            						break;
            						case (int)6: {
            						}
            						break;
            						case (int)11: {
HXLINE( 452)							goto _hx_goto_14;
            						}
            						break;
            					}
            				}
            				_hx_goto_14:;
            			}
            		}
HXLINE( 469)		if ((damageAmount > 0)) {
HXLINE( 470)			 ::map::Map _hx_tmp = this->map;
HXDLIN( 470)			_hx_tmp->addStatusText( ::map::CharacterStatusText_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),(HX_("-",2d,00,00,00) + ::Std_obj::string(damageAmount)),( (int)(textColor) ),750));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(GameObject_obj,damage,(void))

void GameObject_obj::setAttack(int containerType,float attackAngle){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_473_setAttack)
HXLINE( 474)		this->attackAngle = attackAngle;
HXLINE( 475)		this->attackStart = ::lime::_hx_system::System_obj::getTimer();
            	}


HX_DEFINE_DYNAMIC_FUNC2(GameObject_obj,setAttack,(void))

int GameObject_obj::physicalDamage(int dmg,int def,int cond){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_120_physicalDamage)
HXLINE( 121)		if (((cond & 256) != 0)) {
HXLINE( 122)			return 0;
            		}
HXLINE( 124)		if (((cond & 1024) != 0)) {
HXLINE( 125)			return dmg;
            		}
HXLINE( 127)		if (((cond & 512) != 0)) {
HXLINE( 128)			return ::Std_obj::_hx_int((( (Float)(dmg) ) - (( (Float)(def) ) * ((Float)1.25))));
            		}
HXLINE( 130)		return (dmg - def);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(GameObject_obj,physicalDamage,return )

int GameObject_obj::magicDamage(int dmg,int res,int cond){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_133_magicDamage)
HXLINE( 134)		if (((cond & 256) != 0)) {
HXLINE( 135)			return 0;
            		}
HXLINE( 137)		if (((cond & 1024) != 0)) {
HXLINE( 138)			return dmg;
            		}
HXLINE( 140)		return (dmg - res);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(GameObject_obj,magicDamage,return )

int GameObject_obj::trueDamage(int dmg,int cond){
            	HX_STACKFRAME(&_hx_pos_c1f95aaf717b8ccd_143_trueDamage)
HXLINE( 144)		if (((cond & 256) != 0)) {
HXLINE( 145)			return 0;
            		}
HXLINE( 147)		return dmg;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GameObject_obj,trueDamage,return )


::hx::ObjectPtr< GameObject_obj > GameObject_obj::__new( ::Xml objectXML,::String objClass) {
	::hx::ObjectPtr< GameObject_obj > __this = new GameObject_obj();
	__this->__construct(objectXML,objClass);
	return __this;
}

::hx::ObjectPtr< GameObject_obj > GameObject_obj::__alloc(::hx::Ctx *_hx_ctx, ::Xml objectXML,::String objClass) {
	GameObject_obj *__this = (GameObject_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(GameObject_obj), true, "objects.GameObject"));
	*(void **)__this = GameObject_obj::_hx_vtable;
	__this->__construct(objectXML,objClass);
	return __this;
}

GameObject_obj::GameObject_obj()
{
}

void GameObject_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(GameObject);
	HX_MARK_MEMBER_NAME(map,"map");
	HX_MARK_MEMBER_NAME(curSquare,"curSquare");
	HX_MARK_MEMBER_NAME(objectId,"objectId");
	HX_MARK_MEMBER_NAME(mapX,"mapX");
	HX_MARK_MEMBER_NAME(mapY,"mapY");
	HX_MARK_MEMBER_NAME(mapZ,"mapZ");
	HX_MARK_MEMBER_NAME(screenX,"screenX");
	HX_MARK_MEMBER_NAME(screenYNoZ,"screenYNoZ");
	HX_MARK_MEMBER_NAME(hBase,"hBase");
	HX_MARK_MEMBER_NAME(props,"props");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(facing,"facing");
	HX_MARK_MEMBER_NAME(flying,"flying");
	HX_MARK_MEMBER_NAME(floatFlip,"floatFlip");
	HX_MARK_MEMBER_NAME(lastFloatUpdate,"lastFloatUpdate");
	HX_MARK_MEMBER_NAME(attackAngle,"attackAngle");
	HX_MARK_MEMBER_NAME(attackStart,"attackStart");
	HX_MARK_MEMBER_NAME(animatedChar,"animatedChar");
	HX_MARK_MEMBER_NAME(uValue,"uValue");
	HX_MARK_MEMBER_NAME(vValue,"vValue");
	HX_MARK_MEMBER_NAME(topUValue,"topUValue");
	HX_MARK_MEMBER_NAME(topVValue,"topVValue");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(maskUValue,"maskUValue");
	HX_MARK_MEMBER_NAME(maskVValue,"maskVValue");
	HX_MARK_MEMBER_NAME(maskWidth,"maskWidth");
	HX_MARK_MEMBER_NAME(maskHeight,"maskHeight");
	HX_MARK_MEMBER_NAME(randomTextureData,"randomTextureData");
	HX_MARK_MEMBER_NAME(animations,"animations");
	HX_MARK_MEMBER_NAME(dead,"dead");
	HX_MARK_MEMBER_NAME(maxHP,"maxHP");
	HX_MARK_MEMBER_NAME(hp,"hp");
	HX_MARK_MEMBER_NAME(size,"size");
	HX_MARK_MEMBER_NAME(defense,"defense");
	HX_MARK_MEMBER_NAME(resistance,"resistance");
	HX_MARK_MEMBER_NAME(slotTypes,"slotTypes");
	HX_MARK_MEMBER_NAME(equipment,"equipment");
	HX_MARK_MEMBER_NAME(condition,"condition");
	HX_MARK_MEMBER_NAME(objectType,"objectType");
	HX_MARK_MEMBER_NAME(sinkLevel,"sinkLevel");
	HX_MARK_MEMBER_NAME(flashStartTime,"flashStartTime");
	HX_MARK_MEMBER_NAME(flashPeriodMs,"flashPeriodMs");
	HX_MARK_MEMBER_NAME(flashRepeats,"flashRepeats");
	HX_MARK_MEMBER_NAME(flashColor,"flashColor");
	HX_MARK_MEMBER_NAME(glowColor,"glowColor");
	HX_MARK_MEMBER_NAME(nameText,"nameText");
	HX_MARK_MEMBER_NAME(nameTex,"nameTex");
	HX_MARK_MEMBER_NAME(enterTex,"enterTex");
	HX_MARK_MEMBER_NAME(enterKeyTex,"enterKeyTex");
	HX_MARK_MEMBER_NAME(ownerId,"ownerId");
	HX_MARK_MEMBER_NAME(objClass,"objClass");
	HX_MARK_MEMBER_NAME(portrait,"portrait");
	HX_MARK_MEMBER_NAME(myLastTickId,"myLastTickId");
	HX_MARK_MEMBER_NAME(posAtTick,"posAtTick");
	HX_MARK_MEMBER_NAME(tickPosition,"tickPosition");
	HX_MARK_MEMBER_NAME(lastTickUpdateTime,"lastTickUpdateTime");
	HX_MARK_MEMBER_NAME(moveVec,"moveVec");
	HX_MARK_MEMBER_NAME(nextBulletId,"nextBulletId");
	HX_MARK_MEMBER_NAME(sizeMult,"sizeMult");
	HX_MARK_MEMBER_NAME(floatTimeOffset,"floatTimeOffset");
	HX_MARK_MEMBER_NAME(mapColor,"mapColor");
	HX_MARK_MEMBER_NAME(bloodColors,"bloodColors");
	HX_MARK_END_CLASS();
}

void GameObject_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(map,"map");
	HX_VISIT_MEMBER_NAME(curSquare,"curSquare");
	HX_VISIT_MEMBER_NAME(objectId,"objectId");
	HX_VISIT_MEMBER_NAME(mapX,"mapX");
	HX_VISIT_MEMBER_NAME(mapY,"mapY");
	HX_VISIT_MEMBER_NAME(mapZ,"mapZ");
	HX_VISIT_MEMBER_NAME(screenX,"screenX");
	HX_VISIT_MEMBER_NAME(screenYNoZ,"screenYNoZ");
	HX_VISIT_MEMBER_NAME(hBase,"hBase");
	HX_VISIT_MEMBER_NAME(props,"props");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(facing,"facing");
	HX_VISIT_MEMBER_NAME(flying,"flying");
	HX_VISIT_MEMBER_NAME(floatFlip,"floatFlip");
	HX_VISIT_MEMBER_NAME(lastFloatUpdate,"lastFloatUpdate");
	HX_VISIT_MEMBER_NAME(attackAngle,"attackAngle");
	HX_VISIT_MEMBER_NAME(attackStart,"attackStart");
	HX_VISIT_MEMBER_NAME(animatedChar,"animatedChar");
	HX_VISIT_MEMBER_NAME(uValue,"uValue");
	HX_VISIT_MEMBER_NAME(vValue,"vValue");
	HX_VISIT_MEMBER_NAME(topUValue,"topUValue");
	HX_VISIT_MEMBER_NAME(topVValue,"topVValue");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(maskUValue,"maskUValue");
	HX_VISIT_MEMBER_NAME(maskVValue,"maskVValue");
	HX_VISIT_MEMBER_NAME(maskWidth,"maskWidth");
	HX_VISIT_MEMBER_NAME(maskHeight,"maskHeight");
	HX_VISIT_MEMBER_NAME(randomTextureData,"randomTextureData");
	HX_VISIT_MEMBER_NAME(animations,"animations");
	HX_VISIT_MEMBER_NAME(dead,"dead");
	HX_VISIT_MEMBER_NAME(maxHP,"maxHP");
	HX_VISIT_MEMBER_NAME(hp,"hp");
	HX_VISIT_MEMBER_NAME(size,"size");
	HX_VISIT_MEMBER_NAME(defense,"defense");
	HX_VISIT_MEMBER_NAME(resistance,"resistance");
	HX_VISIT_MEMBER_NAME(slotTypes,"slotTypes");
	HX_VISIT_MEMBER_NAME(equipment,"equipment");
	HX_VISIT_MEMBER_NAME(condition,"condition");
	HX_VISIT_MEMBER_NAME(objectType,"objectType");
	HX_VISIT_MEMBER_NAME(sinkLevel,"sinkLevel");
	HX_VISIT_MEMBER_NAME(flashStartTime,"flashStartTime");
	HX_VISIT_MEMBER_NAME(flashPeriodMs,"flashPeriodMs");
	HX_VISIT_MEMBER_NAME(flashRepeats,"flashRepeats");
	HX_VISIT_MEMBER_NAME(flashColor,"flashColor");
	HX_VISIT_MEMBER_NAME(glowColor,"glowColor");
	HX_VISIT_MEMBER_NAME(nameText,"nameText");
	HX_VISIT_MEMBER_NAME(nameTex,"nameTex");
	HX_VISIT_MEMBER_NAME(enterTex,"enterTex");
	HX_VISIT_MEMBER_NAME(enterKeyTex,"enterKeyTex");
	HX_VISIT_MEMBER_NAME(ownerId,"ownerId");
	HX_VISIT_MEMBER_NAME(objClass,"objClass");
	HX_VISIT_MEMBER_NAME(portrait,"portrait");
	HX_VISIT_MEMBER_NAME(myLastTickId,"myLastTickId");
	HX_VISIT_MEMBER_NAME(posAtTick,"posAtTick");
	HX_VISIT_MEMBER_NAME(tickPosition,"tickPosition");
	HX_VISIT_MEMBER_NAME(lastTickUpdateTime,"lastTickUpdateTime");
	HX_VISIT_MEMBER_NAME(moveVec,"moveVec");
	HX_VISIT_MEMBER_NAME(nextBulletId,"nextBulletId");
	HX_VISIT_MEMBER_NAME(sizeMult,"sizeMult");
	HX_VISIT_MEMBER_NAME(floatTimeOffset,"floatTimeOffset");
	HX_VISIT_MEMBER_NAME(mapColor,"mapColor");
	HX_VISIT_MEMBER_NAME(bloodColors,"bloodColors");
}

::hx::Val GameObject_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"hp") ) { return ::hx::Val( hp ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mapX") ) { return ::hx::Val( mapX ); }
		if (HX_FIELD_EQ(inName,"mapY") ) { return ::hx::Val( mapY ); }
		if (HX_FIELD_EQ(inName,"mapZ") ) { return ::hx::Val( mapZ ); }
		if (HX_FIELD_EQ(inName,"name") ) { return ::hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"dead") ) { return ::hx::Val( dead ); }
		if (HX_FIELD_EQ(inName,"size") ) { return ::hx::Val( size ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"hBase") ) { return ::hx::Val( hBase ); }
		if (HX_FIELD_EQ(inName,"props") ) { return ::hx::Val( props ); }
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"maxHP") ) { return ::hx::Val( maxHP ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"facing") ) { return ::hx::Val( facing ); }
		if (HX_FIELD_EQ(inName,"flying") ) { return ::hx::Val( flying ); }
		if (HX_FIELD_EQ(inName,"uValue") ) { return ::hx::Val( uValue ); }
		if (HX_FIELD_EQ(inName,"vValue") ) { return ::hx::Val( vValue ); }
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"distTo") ) { return ::hx::Val( distTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"moveTo") ) { return ::hx::Val( moveTo_dyn() ); }
		if (HX_FIELD_EQ(inName,"onGoto") ) { return ::hx::Val( onGoto_dyn() ); }
		if (HX_FIELD_EQ(inName,"damage") ) { return ::hx::Val( damage_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"screenX") ) { return ::hx::Val( screenX ); }
		if (HX_FIELD_EQ(inName,"defense") ) { return ::hx::Val( defense ); }
		if (HX_FIELD_EQ(inName,"nameTex") ) { return ::hx::Val( nameTex ); }
		if (HX_FIELD_EQ(inName,"ownerId") ) { return ::hx::Val( ownerId ); }
		if (HX_FIELD_EQ(inName,"moveVec") ) { return ::hx::Val( moveVec ); }
		if (HX_FIELD_EQ(inName,"dispose") ) { return ::hx::Val( dispose_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"objectId") ) { return ::hx::Val( objectId ); }
		if (HX_FIELD_EQ(inName,"nameText") ) { return ::hx::Val( nameText ); }
		if (HX_FIELD_EQ(inName,"enterTex") ) { return ::hx::Val( enterTex ); }
		if (HX_FIELD_EQ(inName,"objClass") ) { return ::hx::Val( objClass ); }
		if (HX_FIELD_EQ(inName,"portrait") ) { return ::hx::Val( portrait ); }
		if (HX_FIELD_EQ(inName,"sizeMult") ) { return ::hx::Val( sizeMult ); }
		if (HX_FIELD_EQ(inName,"mapColor") ) { return ::hx::Val( mapColor ); }
		if (HX_FIELD_EQ(inName,"getColor") ) { return ::hx::Val( getColor_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curSquare") ) { return ::hx::Val( curSquare ); }
		if (HX_FIELD_EQ(inName,"floatFlip") ) { return ::hx::Val( floatFlip ); }
		if (HX_FIELD_EQ(inName,"topUValue") ) { return ::hx::Val( topUValue ); }
		if (HX_FIELD_EQ(inName,"topVValue") ) { return ::hx::Val( topVValue ); }
		if (HX_FIELD_EQ(inName,"maskWidth") ) { return ::hx::Val( maskWidth ); }
		if (HX_FIELD_EQ(inName,"slotTypes") ) { return ::hx::Val( slotTypes ); }
		if (HX_FIELD_EQ(inName,"equipment") ) { return ::hx::Val( equipment ); }
		if (HX_FIELD_EQ(inName,"condition") ) { return ::hx::Val( condition ); }
		if (HX_FIELD_EQ(inName,"sinkLevel") ) { return ::hx::Val( sinkLevel ); }
		if (HX_FIELD_EQ(inName,"glowColor") ) { return ::hx::Val( glowColor ); }
		if (HX_FIELD_EQ(inName,"posAtTick") ) { return ::hx::Val( posAtTick ); }
		if (HX_FIELD_EQ(inName,"playSound") ) { return ::hx::Val( playSound_dyn() ); }
		if (HX_FIELD_EQ(inName,"onTickPos") ) { return ::hx::Val( onTickPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"setAttack") ) { return ::hx::Val( setAttack_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"screenYNoZ") ) { return ::hx::Val( screenYNoZ ); }
		if (HX_FIELD_EQ(inName,"maskUValue") ) { return ::hx::Val( maskUValue ); }
		if (HX_FIELD_EQ(inName,"maskVValue") ) { return ::hx::Val( maskVValue ); }
		if (HX_FIELD_EQ(inName,"maskHeight") ) { return ::hx::Val( maskHeight ); }
		if (HX_FIELD_EQ(inName,"animations") ) { return ::hx::Val( animations ); }
		if (HX_FIELD_EQ(inName,"resistance") ) { return ::hx::Val( resistance ); }
		if (HX_FIELD_EQ(inName,"objectType") ) { return ::hx::Val( objectType ); }
		if (HX_FIELD_EQ(inName,"flashColor") ) { return ::hx::Val( flashColor ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"attackAngle") ) { return ::hx::Val( attackAngle ); }
		if (HX_FIELD_EQ(inName,"attackStart") ) { return ::hx::Val( attackStart ); }
		if (HX_FIELD_EQ(inName,"enterKeyTex") ) { return ::hx::Val( enterKeyTex ); }
		if (HX_FIELD_EQ(inName,"bloodColors") ) { return ::hx::Val( bloodColors ); }
		if (HX_FIELD_EQ(inName,"setObjectId") ) { return ::hx::Val( setObjectId_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animatedChar") ) { return ::hx::Val( animatedChar ); }
		if (HX_FIELD_EQ(inName,"flashRepeats") ) { return ::hx::Val( flashRepeats ); }
		if (HX_FIELD_EQ(inName,"myLastTickId") ) { return ::hx::Val( myLastTickId ); }
		if (HX_FIELD_EQ(inName,"tickPosition") ) { return ::hx::Val( tickPosition ); }
		if (HX_FIELD_EQ(inName,"nextBulletId") ) { return ::hx::Val( nextBulletId ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"flashPeriodMs") ) { return ::hx::Val( flashPeriodMs ); }
		if (HX_FIELD_EQ(inName,"removeFromMap") ) { return ::hx::Val( removeFromMap_dyn() ); }
		if (HX_FIELD_EQ(inName,"setAltTexture") ) { return ::hx::Val( setAltTexture_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"flashStartTime") ) { return ::hx::Val( flashStartTime ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"lastFloatUpdate") ) { return ::hx::Val( lastFloatUpdate ); }
		if (HX_FIELD_EQ(inName,"floatTimeOffset") ) { return ::hx::Val( floatTimeOffset ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"randomTextureData") ) { return ::hx::Val( randomTextureData ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"lastTickUpdateTime") ) { return ::hx::Val( lastTickUpdateTime ); }
	}
	return super::__Field(inName,inCallProp);
}

bool GameObject_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"trueDamage") ) { outValue = trueDamage_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"magicDamage") ) { outValue = magicDamage_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"physicalDamage") ) { outValue = physicalDamage_dyn(); return true; }
	}
	return false;
}

::hx::Val GameObject_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"hp") ) { hp=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mapX") ) { mapX=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mapY") ) { mapY=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mapZ") ) { mapZ=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dead") ) { dead=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"size") ) { size=inValue.Cast< float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"hBase") ) { hBase=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"props") ) { props=inValue.Cast<  ::objects::ObjectProperties >(); return inValue; }
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxHP") ) { maxHP=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"facing") ) { facing=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"flying") ) { flying=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uValue") ) { uValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vValue") ) { vValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"screenX") ) { screenX=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"defense") ) { defense=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nameTex") ) { nameTex=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ownerId") ) { ownerId=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moveVec") ) { moveVec=inValue.Cast<  ::openfl::geom::Vector3D >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"objectId") ) { objectId=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nameText") ) { nameText=inValue.Cast<  ::ui::SimpleText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"enterTex") ) { enterTex=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"objClass") ) { objClass=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"portrait") ) { portrait=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sizeMult") ) { sizeMult=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mapColor") ) { mapColor=inValue.Cast< unsigned int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curSquare") ) { curSquare=inValue.Cast<  ::map::Square >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floatFlip") ) { floatFlip=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"topUValue") ) { topUValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"topVValue") ) { topVValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskWidth") ) { maskWidth=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slotTypes") ) { slotTypes=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"equipment") ) { equipment=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"condition") ) { condition=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sinkLevel") ) { sinkLevel=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"glowColor") ) { glowColor=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"posAtTick") ) { posAtTick=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"screenYNoZ") ) { screenYNoZ=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskUValue") ) { maskUValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskVValue") ) { maskVValue=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maskHeight") ) { maskHeight=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animations") ) { animations=inValue.Cast<  ::objects::animation::Animations >(); return inValue; }
		if (HX_FIELD_EQ(inName,"resistance") ) { resistance=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"objectType") ) { objectType=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"flashColor") ) { flashColor=inValue.Cast< float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"attackAngle") ) { attackAngle=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"attackStart") ) { attackStart=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"enterKeyTex") ) { enterKeyTex=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bloodColors") ) { bloodColors=inValue.Cast< ::Array< unsigned int > >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animatedChar") ) { animatedChar=inValue.Cast<  ::util::AnimatedChar >(); return inValue; }
		if (HX_FIELD_EQ(inName,"flashRepeats") ) { flashRepeats=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"myLastTickId") ) { myLastTickId=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tickPosition") ) { tickPosition=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nextBulletId") ) { nextBulletId=inValue.Cast< signed char >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"flashPeriodMs") ) { flashPeriodMs=inValue.Cast< float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"flashStartTime") ) { flashStartTime=inValue.Cast< float >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"lastFloatUpdate") ) { lastFloatUpdate=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"floatTimeOffset") ) { floatTimeOffset=inValue.Cast< int >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"randomTextureData") ) { randomTextureData=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"lastTickUpdateTime") ) { lastTickUpdateTime=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void GameObject_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("map",9c,0a,53,00));
	outFields->push(HX_("curSquare",3d,1a,7f,c9));
	outFields->push(HX_("objectId",7a,2c,2c,83));
	outFields->push(HX_("mapX",3c,3e,56,48));
	outFields->push(HX_("mapY",3d,3e,56,48));
	outFields->push(HX_("mapZ",3e,3e,56,48));
	outFields->push(HX_("screenX",6c,c3,36,2a));
	outFields->push(HX_("screenYNoZ",8c,ef,6c,c8));
	outFields->push(HX_("hBase",99,68,96,0d));
	outFields->push(HX_("props",70,e7,8f,c8));
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("facing",1a,3f,05,e4));
	outFields->push(HX_("flying",4f,52,f8,47));
	outFields->push(HX_("floatFlip",69,02,f7,f6));
	outFields->push(HX_("lastFloatUpdate",0f,7e,63,d0));
	outFields->push(HX_("attackAngle",eb,02,92,ca));
	outFields->push(HX_("attackStart",7a,33,bb,2b));
	outFields->push(HX_("animatedChar",19,8b,fc,9e));
	outFields->push(HX_("uValue",bc,26,a7,8c));
	outFields->push(HX_("vValue",1b,83,02,f3));
	outFields->push(HX_("topUValue",31,9f,e2,54));
	outFields->push(HX_("topVValue",90,fb,3d,bb));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("maskUValue",c8,54,8b,a1));
	outFields->push(HX_("maskVValue",27,b1,e6,07));
	outFields->push(HX_("maskWidth",7a,0d,cb,50));
	outFields->push(HX_("maskHeight",f3,35,30,17));
	outFields->push(HX_("randomTextureData",62,53,b3,f3));
	outFields->push(HX_("animations",ef,34,1c,83));
	outFields->push(HX_("dead",a4,4e,66,42));
	outFields->push(HX_("maxHP",ac,3a,26,03));
	outFields->push(HX_("hp",08,5b,00,00));
	outFields->push(HX_("size",c1,a0,53,4c));
	outFields->push(HX_("defense",80,69,63,9e));
	outFields->push(HX_("resistance",b9,11,56,a0));
	outFields->push(HX_("slotTypes",9b,89,e7,fa));
	outFields->push(HX_("equipment",4e,34,85,3a));
	outFields->push(HX_("condition",9b,e9,33,fc));
	outFields->push(HX_("objectType",19,69,41,cf));
	outFields->push(HX_("sinkLevel",31,22,1c,e4));
	outFields->push(HX_("flashStartTime",bf,b9,ba,91));
	outFields->push(HX_("flashPeriodMs",97,c8,69,0a));
	outFields->push(HX_("flashRepeats",e8,e0,1b,df));
	outFields->push(HX_("flashColor",93,0d,6d,68));
	outFields->push(HX_("glowColor",96,b3,39,7a));
	outFields->push(HX_("nameText",98,ec,80,49));
	outFields->push(HX_("nameTex",5c,e4,86,ac));
	outFields->push(HX_("enterTex",af,e7,98,43));
	outFields->push(HX_("enterKeyTex",c0,dc,10,97));
	outFields->push(HX_("ownerId",ee,8a,73,35));
	outFields->push(HX_("objClass",c1,18,71,f5));
	outFields->push(HX_("portrait",5b,21,af,b8));
	outFields->push(HX_("myLastTickId",1a,9a,68,c1));
	outFields->push(HX_("posAtTick",a4,72,25,c4));
	outFields->push(HX_("tickPosition",26,45,57,d2));
	outFields->push(HX_("lastTickUpdateTime",69,fd,65,20));
	outFields->push(HX_("moveVec",c3,37,8d,4a));
	outFields->push(HX_("nextBulletId",d0,52,8a,31));
	outFields->push(HX_("sizeMult",51,29,38,e2));
	outFields->push(HX_("floatTimeOffset",3c,44,e2,fe));
	outFields->push(HX_("mapColor",27,e1,9e,c1));
	outFields->push(HX_("bloodColors",0a,41,99,f1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo GameObject_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::map::Map */ ,(int)offsetof(GameObject_obj,map),HX_("map",9c,0a,53,00)},
	{::hx::fsObject /*  ::map::Square */ ,(int)offsetof(GameObject_obj,curSquare),HX_("curSquare",3d,1a,7f,c9)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,objectId),HX_("objectId",7a,2c,2c,83)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,mapX),HX_("mapX",3c,3e,56,48)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,mapY),HX_("mapY",3d,3e,56,48)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,mapZ),HX_("mapZ",3e,3e,56,48)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,screenX),HX_("screenX",6c,c3,36,2a)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,screenYNoZ),HX_("screenYNoZ",8c,ef,6c,c8)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,hBase),HX_("hBase",99,68,96,0d)},
	{::hx::fsObject /*  ::objects::ObjectProperties */ ,(int)offsetof(GameObject_obj,props),HX_("props",70,e7,8f,c8)},
	{::hx::fsString,(int)offsetof(GameObject_obj,name),HX_("name",4b,72,ff,48)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,facing),HX_("facing",1a,3f,05,e4)},
	{::hx::fsBool,(int)offsetof(GameObject_obj,flying),HX_("flying",4f,52,f8,47)},
	{::hx::fsBool,(int)offsetof(GameObject_obj,floatFlip),HX_("floatFlip",69,02,f7,f6)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,lastFloatUpdate),HX_("lastFloatUpdate",0f,7e,63,d0)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,attackAngle),HX_("attackAngle",eb,02,92,ca)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,attackStart),HX_("attackStart",7a,33,bb,2b)},
	{::hx::fsObject /*  ::util::AnimatedChar */ ,(int)offsetof(GameObject_obj,animatedChar),HX_("animatedChar",19,8b,fc,9e)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,uValue),HX_("uValue",bc,26,a7,8c)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,vValue),HX_("vValue",1b,83,02,f3)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,topUValue),HX_("topUValue",31,9f,e2,54)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,topVValue),HX_("topVValue",90,fb,3d,bb)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,maskUValue),HX_("maskUValue",c8,54,8b,a1)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,maskVValue),HX_("maskVValue",27,b1,e6,07)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,maskWidth),HX_("maskWidth",7a,0d,cb,50)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,maskHeight),HX_("maskHeight",f3,35,30,17)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(GameObject_obj,randomTextureData),HX_("randomTextureData",62,53,b3,f3)},
	{::hx::fsObject /*  ::objects::animation::Animations */ ,(int)offsetof(GameObject_obj,animations),HX_("animations",ef,34,1c,83)},
	{::hx::fsBool,(int)offsetof(GameObject_obj,dead),HX_("dead",a4,4e,66,42)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,maxHP),HX_("maxHP",ac,3a,26,03)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,hp),HX_("hp",08,5b,00,00)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,size),HX_("size",c1,a0,53,4c)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,defense),HX_("defense",80,69,63,9e)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,resistance),HX_("resistance",b9,11,56,a0)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(GameObject_obj,slotTypes),HX_("slotTypes",9b,89,e7,fa)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(GameObject_obj,equipment),HX_("equipment",4e,34,85,3a)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,condition),HX_("condition",9b,e9,33,fc)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,objectType),HX_("objectType",19,69,41,cf)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,sinkLevel),HX_("sinkLevel",31,22,1c,e4)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,flashStartTime),HX_("flashStartTime",bf,b9,ba,91)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,flashPeriodMs),HX_("flashPeriodMs",97,c8,69,0a)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,flashRepeats),HX_("flashRepeats",e8,e0,1b,df)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,flashColor),HX_("flashColor",93,0d,6d,68)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,glowColor),HX_("glowColor",96,b3,39,7a)},
	{::hx::fsObject /*  ::ui::SimpleText */ ,(int)offsetof(GameObject_obj,nameText),HX_("nameText",98,ec,80,49)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(GameObject_obj,nameTex),HX_("nameTex",5c,e4,86,ac)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(GameObject_obj,enterTex),HX_("enterTex",af,e7,98,43)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(GameObject_obj,enterKeyTex),HX_("enterKeyTex",c0,dc,10,97)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,ownerId),HX_("ownerId",ee,8a,73,35)},
	{::hx::fsString,(int)offsetof(GameObject_obj,objClass),HX_("objClass",c1,18,71,f5)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(GameObject_obj,portrait),HX_("portrait",5b,21,af,b8)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,myLastTickId),HX_("myLastTickId",1a,9a,68,c1)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(GameObject_obj,posAtTick),HX_("posAtTick",a4,72,25,c4)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(GameObject_obj,tickPosition),HX_("tickPosition",26,45,57,d2)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,lastTickUpdateTime),HX_("lastTickUpdateTime",69,fd,65,20)},
	{::hx::fsObject /*  ::openfl::geom::Vector3D */ ,(int)offsetof(GameObject_obj,moveVec),HX_("moveVec",c3,37,8d,4a)},
	{::hx::fsUnknown /* signed char */ ,(int)offsetof(GameObject_obj,nextBulletId),HX_("nextBulletId",d0,52,8a,31)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(GameObject_obj,sizeMult),HX_("sizeMult",51,29,38,e2)},
	{::hx::fsInt,(int)offsetof(GameObject_obj,floatTimeOffset),HX_("floatTimeOffset",3c,44,e2,fe)},
	{::hx::fsUnknown /* unsigned int */ ,(int)offsetof(GameObject_obj,mapColor),HX_("mapColor",27,e1,9e,c1)},
	{::hx::fsObject /* ::Array< unsigned int > */ ,(int)offsetof(GameObject_obj,bloodColors),HX_("bloodColors",0a,41,99,f1)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *GameObject_obj_sStaticStorageInfo = 0;
#endif

static ::String GameObject_obj_sMemberFields[] = {
	HX_("curSquare",3d,1a,7f,c9),
	HX_("objectId",7a,2c,2c,83),
	HX_("mapX",3c,3e,56,48),
	HX_("mapY",3d,3e,56,48),
	HX_("mapZ",3e,3e,56,48),
	HX_("screenX",6c,c3,36,2a),
	HX_("screenYNoZ",8c,ef,6c,c8),
	HX_("hBase",99,68,96,0d),
	HX_("props",70,e7,8f,c8),
	HX_("name",4b,72,ff,48),
	HX_("facing",1a,3f,05,e4),
	HX_("flying",4f,52,f8,47),
	HX_("floatFlip",69,02,f7,f6),
	HX_("lastFloatUpdate",0f,7e,63,d0),
	HX_("attackAngle",eb,02,92,ca),
	HX_("attackStart",7a,33,bb,2b),
	HX_("animatedChar",19,8b,fc,9e),
	HX_("uValue",bc,26,a7,8c),
	HX_("vValue",1b,83,02,f3),
	HX_("topUValue",31,9f,e2,54),
	HX_("topVValue",90,fb,3d,bb),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("maskUValue",c8,54,8b,a1),
	HX_("maskVValue",27,b1,e6,07),
	HX_("maskWidth",7a,0d,cb,50),
	HX_("maskHeight",f3,35,30,17),
	HX_("randomTextureData",62,53,b3,f3),
	HX_("animations",ef,34,1c,83),
	HX_("dead",a4,4e,66,42),
	HX_("maxHP",ac,3a,26,03),
	HX_("hp",08,5b,00,00),
	HX_("size",c1,a0,53,4c),
	HX_("defense",80,69,63,9e),
	HX_("resistance",b9,11,56,a0),
	HX_("slotTypes",9b,89,e7,fa),
	HX_("equipment",4e,34,85,3a),
	HX_("condition",9b,e9,33,fc),
	HX_("objectType",19,69,41,cf),
	HX_("sinkLevel",31,22,1c,e4),
	HX_("flashStartTime",bf,b9,ba,91),
	HX_("flashPeriodMs",97,c8,69,0a),
	HX_("flashRepeats",e8,e0,1b,df),
	HX_("flashColor",93,0d,6d,68),
	HX_("glowColor",96,b3,39,7a),
	HX_("nameText",98,ec,80,49),
	HX_("nameTex",5c,e4,86,ac),
	HX_("enterTex",af,e7,98,43),
	HX_("enterKeyTex",c0,dc,10,97),
	HX_("ownerId",ee,8a,73,35),
	HX_("objClass",c1,18,71,f5),
	HX_("portrait",5b,21,af,b8),
	HX_("myLastTickId",1a,9a,68,c1),
	HX_("posAtTick",a4,72,25,c4),
	HX_("tickPosition",26,45,57,d2),
	HX_("lastTickUpdateTime",69,fd,65,20),
	HX_("moveVec",c3,37,8d,4a),
	HX_("nextBulletId",d0,52,8a,31),
	HX_("sizeMult",51,29,38,e2),
	HX_("floatTimeOffset",3c,44,e2,fe),
	HX_("mapColor",27,e1,9e,c1),
	HX_("bloodColors",0a,41,99,f1),
	HX_("dispose",9f,80,4c,bb),
	HX_("removeFromMap",6e,37,b8,30),
	HX_("update",09,86,05,87),
	HX_("setObjectId",3c,f6,8c,b3),
	HX_("setAltTexture",f4,9c,95,d2),
	HX_("playSound",3b,ba,b0,a1),
	HX_("getColor",ed,80,33,aa),
	HX_("distTo",81,d6,1e,bd),
	HX_("moveTo",ec,d2,ac,cc),
	HX_("onGoto",62,a2,f3,e6),
	HX_("onTickPos",d8,c2,7f,f2),
	HX_("damage",6f,90,e4,1d),
	HX_("setAttack",0a,71,b7,3f),
	::String(null()) };

::hx::Class GameObject_obj::__mClass;

static ::String GameObject_obj_sStaticFields[] = {
	HX_("physicalDamage",e6,95,f7,74),
	HX_("magicDamage",7c,15,03,77),
	HX_("trueDamage",5d,1a,be,ef),
	::String(null())
};

void GameObject_obj::__register()
{
	GameObject_obj _hx_dummy;
	GameObject_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.GameObject",cb,11,7e,3f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GameObject_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GameObject_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(GameObject_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< GameObject_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GameObject_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GameObject_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace objects
