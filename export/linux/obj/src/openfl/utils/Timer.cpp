// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_Timer
#include <haxe/Timer.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_TimerEvent
#include <openfl/events/TimerEvent.h>
#endif
#ifndef INCLUDED_openfl_utils_Timer
#include <openfl/utils/Timer.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_79d6633524574c80_109_new,"openfl.utils.Timer","new",0xe52329bc,"openfl.utils.Timer.new","openfl/utils/Timer.hx",109,0xaa6369f6)
HX_LOCAL_STACK_FRAME(_hx_pos_79d6633524574c80_132_reset,"openfl.utils.Timer","reset",0x2125b22b,"openfl.utils.Timer.reset","openfl/utils/Timer.hx",132,0xaa6369f6)
HX_LOCAL_STACK_FRAME(_hx_pos_79d6633524574c80_147_start,"openfl.utils.Timer","start",0xbe68dcbe,"openfl.utils.Timer.start","openfl/utils/Timer.hx",147,0xaa6369f6)
HX_LOCAL_STACK_FRAME(_hx_pos_79d6633524574c80_167_stop,"openfl.utils.Timer","stop",0x9cfac726,"openfl.utils.Timer.stop","openfl/utils/Timer.hx",167,0xaa6369f6)
HX_LOCAL_STACK_FRAME(_hx_pos_79d6633524574c80_221_timer_onTimer,"openfl.utils.Timer","timer_onTimer",0x5f4568c8,"openfl.utils.Timer.timer_onTimer","openfl/utils/Timer.hx",221,0xaa6369f6)
namespace openfl{
namespace utils{

void Timer_obj::__construct(Float delay,::hx::Null< int >  __o_repeatCount){
            		int repeatCount = __o_repeatCount.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_79d6633524574c80_109_new)
HXLINE( 110)		bool _hx_tmp;
HXDLIN( 110)		if (!(::Math_obj::isNaN(delay))) {
HXLINE( 110)			_hx_tmp = (delay < 0);
            		}
            		else {
HXLINE( 110)			_hx_tmp = true;
            		}
HXDLIN( 110)		if (_hx_tmp) {
HXLINE( 112)			HX_STACK_DO_THROW( ::openfl::errors::Error_obj::__alloc( HX_CTX ,HX_("The delay specified is negative or not a finite number",42,5b,8b,e3),null()));
            		}
HXLINE( 115)		super::__construct(null());
HXLINE( 117)		this->_hx___delay = delay;
HXLINE( 118)		this->_hx___repeatCount = repeatCount;
HXLINE( 120)		this->running = false;
HXLINE( 121)		this->currentCount = 0;
            	}

Dynamic Timer_obj::__CreateEmpty() { return new Timer_obj; }

void *Timer_obj::_hx_vtable = 0;

Dynamic Timer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Timer_obj > _hx_result = new Timer_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Timer_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0c89e854) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0c89e854;
	} else {
		return inClassId==(int)0x3b9e57e4;
	}
}

void Timer_obj::reset(){
            	HX_STACKFRAME(&_hx_pos_79d6633524574c80_132_reset)
HXLINE( 133)		if (this->running) {
HXLINE( 135)			this->stop();
            		}
HXLINE( 138)		this->currentCount = 0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,reset,(void))

void Timer_obj::start(){
            	HX_GC_STACKFRAME(&_hx_pos_79d6633524574c80_147_start)
HXDLIN( 147)		if (!(this->running)) {
HXLINE( 149)			this->running = true;
HXLINE( 154)			this->_hx___timer =  ::haxe::Timer_obj::__alloc( HX_CTX ,( (Float)(::Std_obj::_hx_int(this->_hx___delay)) ));
HXLINE( 155)			this->_hx___timer->run = this->timer_onTimer_dyn();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,start,(void))

void Timer_obj::stop(){
            	HX_STACKFRAME(&_hx_pos_79d6633524574c80_167_stop)
HXLINE( 168)		this->running = false;
HXLINE( 177)		if (::hx::IsNotNull( this->_hx___timer )) {
HXLINE( 179)			this->_hx___timer->stop();
HXLINE( 180)			this->_hx___timer = null();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,stop,(void))

void Timer_obj::timer_onTimer(){
            	HX_GC_STACKFRAME(&_hx_pos_79d6633524574c80_221_timer_onTimer)
HXLINE( 222)		this->currentCount++;
HXLINE( 224)		bool _hx_tmp;
HXDLIN( 224)		if ((this->_hx___repeatCount > 0)) {
HXLINE( 224)			_hx_tmp = (this->currentCount >= this->_hx___repeatCount);
            		}
            		else {
HXLINE( 224)			_hx_tmp = false;
            		}
HXDLIN( 224)		if (_hx_tmp) {
HXLINE( 226)			this->stop();
HXLINE( 227)			this->dispatchEvent( ::openfl::events::TimerEvent_obj::__alloc( HX_CTX ,HX_("timer",c5,bf,35,10),null(),null()));
HXLINE( 228)			this->dispatchEvent( ::openfl::events::TimerEvent_obj::__alloc( HX_CTX ,HX_("timerComplete",9e,49,cc,97),null(),null()));
            		}
            		else {
HXLINE( 232)			this->dispatchEvent( ::openfl::events::TimerEvent_obj::__alloc( HX_CTX ,HX_("timer",c5,bf,35,10),null(),null()));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,timer_onTimer,(void))


::hx::ObjectPtr< Timer_obj > Timer_obj::__new(Float delay,::hx::Null< int >  __o_repeatCount) {
	::hx::ObjectPtr< Timer_obj > __this = new Timer_obj();
	__this->__construct(delay,__o_repeatCount);
	return __this;
}

::hx::ObjectPtr< Timer_obj > Timer_obj::__alloc(::hx::Ctx *_hx_ctx,Float delay,::hx::Null< int >  __o_repeatCount) {
	Timer_obj *__this = (Timer_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Timer_obj), true, "openfl.utils.Timer"));
	*(void **)__this = Timer_obj::_hx_vtable;
	__this->__construct(delay,__o_repeatCount);
	return __this;
}

Timer_obj::Timer_obj()
{
}

void Timer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Timer);
	HX_MARK_MEMBER_NAME(currentCount,"currentCount");
	HX_MARK_MEMBER_NAME(running,"running");
	HX_MARK_MEMBER_NAME(_hx___delay,"__delay");
	HX_MARK_MEMBER_NAME(_hx___repeatCount,"__repeatCount");
	HX_MARK_MEMBER_NAME(_hx___timer,"__timer");
	 ::openfl::events::EventDispatcher_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Timer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(currentCount,"currentCount");
	HX_VISIT_MEMBER_NAME(running,"running");
	HX_VISIT_MEMBER_NAME(_hx___delay,"__delay");
	HX_VISIT_MEMBER_NAME(_hx___repeatCount,"__repeatCount");
	HX_VISIT_MEMBER_NAME(_hx___timer,"__timer");
	 ::openfl::events::EventDispatcher_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val Timer_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"stop") ) { return ::hx::Val( stop_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { return ::hx::Val( running ); }
		if (HX_FIELD_EQ(inName,"__delay") ) { return ::hx::Val( _hx___delay ); }
		if (HX_FIELD_EQ(inName,"__timer") ) { return ::hx::Val( _hx___timer ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentCount") ) { return ::hx::Val( currentCount ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__repeatCount") ) { return ::hx::Val( _hx___repeatCount ); }
		if (HX_FIELD_EQ(inName,"timer_onTimer") ) { return ::hx::Val( timer_onTimer_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val Timer_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { running=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__delay") ) { _hx___delay=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__timer") ) { _hx___timer=inValue.Cast<  ::haxe::Timer >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"currentCount") ) { currentCount=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"__repeatCount") ) { _hx___repeatCount=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Timer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("currentCount",d6,29,6f,91));
	outFields->push(HX_("running",ff,6d,69,eb));
	outFields->push(HX_("__delay",63,30,85,41));
	outFields->push(HX_("__repeatCount",54,d4,02,64));
	outFields->push(HX_("__timer",a5,18,94,7a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Timer_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(Timer_obj,currentCount),HX_("currentCount",d6,29,6f,91)},
	{::hx::fsBool,(int)offsetof(Timer_obj,running),HX_("running",ff,6d,69,eb)},
	{::hx::fsFloat,(int)offsetof(Timer_obj,_hx___delay),HX_("__delay",63,30,85,41)},
	{::hx::fsInt,(int)offsetof(Timer_obj,_hx___repeatCount),HX_("__repeatCount",54,d4,02,64)},
	{::hx::fsObject /*  ::haxe::Timer */ ,(int)offsetof(Timer_obj,_hx___timer),HX_("__timer",a5,18,94,7a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *Timer_obj_sStaticStorageInfo = 0;
#endif

static ::String Timer_obj_sMemberFields[] = {
	HX_("currentCount",d6,29,6f,91),
	HX_("running",ff,6d,69,eb),
	HX_("__delay",63,30,85,41),
	HX_("__repeatCount",54,d4,02,64),
	HX_("__timer",a5,18,94,7a),
	HX_("reset",cf,49,c8,e6),
	HX_("start",62,74,0b,84),
	HX_("stop",02,f0,5b,4c),
	HX_("timer_onTimer",6c,44,7e,1e),
	::String(null()) };

::hx::Class Timer_obj::__mClass;

void Timer_obj::__register()
{
	Timer_obj _hx_dummy;
	Timer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("openfl.utils.Timer",ca,db,6c,10);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Timer_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Timer_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Timer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Timer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace utils
