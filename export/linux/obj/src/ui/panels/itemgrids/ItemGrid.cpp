// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_game_GameSprite
#include <game/GameSprite.h>
#endif
#ifndef INCLUDED_game_model_VialModel
#include <game/model/VialModel.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_map_Map
#include <map/Map.h>
#endif
#ifndef INCLUDED_network_NetworkHandler
#include <network/NetworkHandler.h>
#endif
#ifndef INCLUDED_objects_GameObject
#include <objects/GameObject.h>
#endif
#ifndef INCLUDED_objects_ObjectLibrary
#include <objects/ObjectLibrary.h>
#endif
#ifndef INCLUDED_objects_Player
#include <objects/Player.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_MouseEvent
#include <openfl/events/MouseEvent.h>
#endif
#ifndef INCLUDED_ui_model_TabStripModel
#include <ui/model/TabStripModel.h>
#endif
#ifndef INCLUDED_ui_model_VialData
#include <ui/model/VialData.h>
#endif
#ifndef INCLUDED_ui_panels_Panel
#include <ui/panels/Panel.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_ContainerGrid
#include <ui/panels/itemgrids/ContainerGrid.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_InventoryGrid
#include <ui/panels/itemgrids/InventoryGrid.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_ItemGrid
#include <ui/panels/itemgrids/ItemGrid.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_itemtiles_InteractiveItemTile
#include <ui/panels/itemgrids/itemtiles/InteractiveItemTile.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_itemtiles_ItemTile
#include <ui/panels/itemgrids/itemtiles/ItemTile.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_itemtiles_ItemTileEvent
#include <ui/panels/itemgrids/itemtiles/ItemTileEvent.h>
#endif
#ifndef INCLUDED_ui_panels_itemgrids_itemtiles_ItemTileSprite
#include <ui/panels/itemgrids/itemtiles/ItemTileSprite.h>
#endif
#ifndef INCLUDED_ui_tooltip_EquipmentToolTip
#include <ui/tooltip/EquipmentToolTip.h>
#endif
#ifndef INCLUDED_ui_tooltip_ToolTip
#include <ui/tooltip/ToolTip.h>
#endif
#ifndef INCLUDED_ui_view_Inventory
#include <ui/view/Inventory.h>
#endif
#ifndef INCLUDED_ui_view_VialSlotView
#include <ui/view/VialSlotView.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b4a36b805b37501c_24_new,"ui.panels.itemgrids.ItemGrid","new",0x5ccc7704,"ui.panels.itemgrids.ItemGrid.new","ui/panels/itemgrids/ItemGrid.hx",24,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_61_onAdded,"ui.panels.itemgrids.ItemGrid","onAdded",0x9cfc3bc5,"ui.panels.itemgrids.ItemGrid.onAdded","ui/panels/itemgrids/ItemGrid.hx",61,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_71_onRemoved,"ui.panels.itemgrids.ItemGrid","onRemoved",0x5fe411e5,"ui.panels.itemgrids.ItemGrid.onRemoved","ui/panels/itemgrids/ItemGrid.hx",71,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_80_addToVialStack,"ui.panels.itemgrids.ItemGrid","addToVialStack",0x7b58d1ca,"ui.panels.itemgrids.ItemGrid.addToVialStack","ui/panels/itemgrids/ItemGrid.hx",80,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_93_dropItem,"ui.panels.itemgrids.ItemGrid","dropItem",0x2c4f33be,"ui.panels.itemgrids.ItemGrid.dropItem","ui/panels/itemgrids/ItemGrid.hx",93,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_118_swapItemTiles,"ui.panels.itemgrids.ItemGrid","swapItemTiles",0xf6c38a03,"ui.panels.itemgrids.ItemGrid.swapItemTiles","ui/panels/itemgrids/ItemGrid.hx",118,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_132_dropWithoutDestTile,"ui.panels.itemgrids.ItemGrid","dropWithoutDestTile",0x9b6c304d,"ui.panels.itemgrids.ItemGrid.dropWithoutDestTile","ui/panels/itemgrids/ItemGrid.hx",132,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_140_equipOrUseContainer,"ui.panels.itemgrids.ItemGrid","equipOrUseContainer",0xbbb82b31,"ui.panels.itemgrids.ItemGrid.equipOrUseContainer","ui/panels/itemgrids/ItemGrid.hx",140,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_150_equipOrUseInventory,"ui.panels.itemgrids.ItemGrid","equipOrUseInventory",0x44fb2c8c,"ui.panels.itemgrids.ItemGrid.equipOrUseInventory","ui/panels/itemgrids/ItemGrid.hx",150,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_160_onTileMove,"ui.panels.itemgrids.ItemGrid","onTileMove",0x5cf7137a,"ui.panels.itemgrids.ItemGrid.onTileMove","ui/panels/itemgrids/ItemGrid.hx",160,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_187_onVialMove,"ui.panels.itemgrids.ItemGrid","onVialMove",0x713d0f2a,"ui.panels.itemgrids.ItemGrid.onVialMove","ui/panels/itemgrids/ItemGrid.hx",187,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_204_onCtrlClick,"ui.panels.itemgrids.ItemGrid","onCtrlClick",0x7055e522,"ui.panels.itemgrids.ItemGrid.onCtrlClick","ui/panels/itemgrids/ItemGrid.hx",204,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_217_onDoubleClick,"ui.panels.itemgrids.ItemGrid","onDoubleClick",0x9ae0fc3c,"ui.panels.itemgrids.ItemGrid.onDoubleClick","ui/panels/itemgrids/ItemGrid.hx",217,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_226_draw,"ui.panels.itemgrids.ItemGrid","draw",0xcf8954e0,"ui.panels.itemgrids.ItemGrid.draw","ui/panels/itemgrids/ItemGrid.hx",226,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_229_setItems,"ui.panels.itemgrids.ItemGrid","setItems",0x1135dbda,"ui.panels.itemgrids.ItemGrid.setItems","ui/panels/itemgrids/ItemGrid.hx",229,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_231_addToGrid,"ui.panels.itemgrids.ItemGrid","addToGrid",0xc782b086,"ui.panels.itemgrids.ItemGrid.addToGrid","ui/panels/itemgrids/ItemGrid.hx",231,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_239_getCharacterType,"ui.panels.itemgrids.ItemGrid","getCharacterType",0x03b72f69,"ui.panels.itemgrids.ItemGrid.getCharacterType","ui/panels/itemgrids/ItemGrid.hx",239,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_249_onTileHover,"ui.panels.itemgrids.ItemGrid","onTileHover",0x1a391133,"ui.panels.itemgrids.ItemGrid.onTileHover","ui/panels/itemgrids/ItemGrid.hx",249,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_198_onShiftClick,"ui.panels.itemgrids.ItemGrid","onShiftClick",0xfdf16f41,"ui.panels.itemgrids.ItemGrid.onShiftClick","ui/panels/itemgrids/ItemGrid.hx",198,0x93775c6b)
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_25_boot,"ui.panels.itemgrids.ItemGrid","boot",0xce34ad0e,"ui.panels.itemgrids.ItemGrid.boot","ui/panels/itemgrids/ItemGrid.hx",25,0x93775c6b)
static const int _hx_array_data_2083e512_21[] = {
	(int)0,(int)0,(int)0,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_b4a36b805b37501c_26_boot,"ui.panels.itemgrids.ItemGrid","boot",0xce34ad0e,"ui.panels.itemgrids.ItemGrid.boot","ui/panels/itemgrids/ItemGrid.hx",26,0x93775c6b)
static const int _hx_array_data_2083e512_23[] = {
	(int)1,(int)0,(int)0,(int)1,
};
static const int _hx_array_data_2083e512_24[] = {
	(int)0,(int)1,(int)1,(int)0,
};
static const int _hx_array_data_2083e512_25[] = {
	(int)1,(int)0,(int)0,(int)0,
};
static const int _hx_array_data_2083e512_26[] = {
	(int)0,(int)1,(int)0,(int)0,
};
static const int _hx_array_data_2083e512_27[] = {
	(int)0,(int)0,(int)0,(int)1,
};
static const int _hx_array_data_2083e512_28[] = {
	(int)0,(int)0,(int)1,(int)0,
};
static const int _hx_array_data_2083e512_29[] = {
	(int)1,(int)0,(int)0,(int)1,
};
static const int _hx_array_data_2083e512_30[] = {
	(int)0,(int)1,(int)1,(int)0,
};
static const int _hx_array_data_2083e512_31[] = {
	(int)1,(int)0,(int)0,(int)0,
};
static const int _hx_array_data_2083e512_32[] = {
	(int)0,(int)1,(int)0,(int)0,
};
static const int _hx_array_data_2083e512_33[] = {
	(int)0,(int)0,(int)0,(int)1,
};
static const int _hx_array_data_2083e512_34[] = {
	(int)0,(int)0,(int)1,(int)0,
};
namespace ui{
namespace panels{
namespace itemgrids{

void ItemGrid_obj::__construct( ::objects::GameObject gridOwner, ::objects::Player currentPlayer,int itemIndexOffset,::hx::Null< bool >  __o_disableBgDraw){
            		bool disableBgDraw = __o_disableBgDraw.Default(false);
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_24_new)
HXLINE(  45)		this->disableBgDraw = false;
HXLINE(  44)		this->indexOffset = 0;
HXLINE(  43)		this->interactive = false;
HXLINE(  50)		super::__construct(null());
HXLINE(  51)		this->owner = gridOwner;
HXLINE(  52)		this->curPlayer = currentPlayer;
HXLINE(  53)		this->indexOffset = itemIndexOffset;
HXLINE(  54)		this->disableBgDraw = disableBgDraw;
HXLINE(  55)		if (::hx::IsInstanceEq( gridOwner,currentPlayer )) {
HXLINE(  56)			this->interactive = true;
            		}
HXLINE(  58)		this->addEventListener(HX_("addedToStage",63,22,55,0c),this->onAdded_dyn(),null(),null(),null());
            	}

Dynamic ItemGrid_obj::__CreateEmpty() { return new ItemGrid_obj; }

void *ItemGrid_obj::_hx_vtable = 0;

Dynamic ItemGrid_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ItemGrid_obj > _hx_result = new ItemGrid_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool ItemGrid_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1f4df417) {
		if (inClassId<=(int)0x0bf625e0) {
			if (inClassId<=(int)0x0330636f) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0330636f;
			} else {
				return inClassId==(int)0x0bf625e0;
			}
		} else {
			return inClassId==(int)0x0c89e854 || inClassId==(int)0x1f4df417;
		}
	} else {
		if (inClassId<=(int)0x6b353933) {
			return inClassId==(int)0x4af7dd8e || inClassId==(int)0x6b353933;
		} else {
			return inClassId==(int)0x7fae8619;
		}
	}
}

void ItemGrid_obj::onAdded( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_61_onAdded)
HXLINE(  62)		this->removeEventListener(HX_("addedToStage",63,22,55,0c),this->onAdded_dyn(),null());
HXLINE(  63)		this->addEventListener(HX_("removedFromStage",34,21,76,ba),this->onRemoved_dyn(),null(),null(),null());
HXLINE(  65)		this->addEventListener(HX_("ITEM_MOVE",fd,f4,5a,d0),this->onTileMove_dyn(),null(),null(),null());
HXLINE(  66)		this->addEventListener(HX_("ITEM_SHIFT_CLICK",df,a0,e2,97),::ui::panels::itemgrids::ItemGrid_obj::onShiftClick_dyn(),null(),null(),null());
HXLINE(  67)		this->addEventListener(HX_("ITEM_DOUBLE_CLICK",26,0b,a1,b4),this->onDoubleClick_dyn(),null(),null(),null());
HXLINE(  68)		this->addEventListener(HX_("ITEM_CTRL_CLICK",40,21,0f,ba),this->onCtrlClick_dyn(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onAdded,(void))

void ItemGrid_obj::onRemoved( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_71_onRemoved)
HXLINE(  72)		this->removeEventListener(HX_("removedFromStage",34,21,76,ba),this->onRemoved_dyn(),null());
HXLINE(  74)		this->removeEventListener(HX_("ITEM_MOVE",fd,f4,5a,d0),this->onTileMove_dyn(),null());
HXLINE(  75)		this->removeEventListener(HX_("ITEM_SHIFT_CLICK",df,a0,e2,97),::ui::panels::itemgrids::ItemGrid_obj::onShiftClick_dyn(),null());
HXLINE(  76)		this->removeEventListener(HX_("ITEM_DOUBLE_CLICK",26,0b,a1,b4),this->onDoubleClick_dyn(),null());
HXLINE(  77)		this->removeEventListener(HX_("ITEM_CTRL_CLICK",40,21,0f,ba),this->onCtrlClick_dyn(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onRemoved,(void))

void ItemGrid_obj::addToVialStack( ::ui::panels::itemgrids::itemtiles::InteractiveItemTile sourceTile){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_80_addToVialStack)
HXLINE(  81)		bool _hx_tmp;
HXDLIN(  81)		bool _hx_tmp1;
HXDLIN(  81)		bool _hx_tmp2;
HXDLIN(  81)		if (::hx::IsNotNull( ::hx::ClassOf< ::network::NetworkHandler >() )) {
HXLINE(  81)			_hx_tmp2 = !(this->interactive);
            		}
            		else {
HXLINE(  81)			_hx_tmp2 = true;
            		}
HXDLIN(  81)		if (!(_hx_tmp2)) {
HXLINE(  81)			_hx_tmp1 = ::hx::IsNull( sourceTile );
            		}
            		else {
HXLINE(  81)			_hx_tmp1 = true;
            		}
HXDLIN(  81)		if (!(_hx_tmp1)) {
HXLINE(  84)			int _hx_tmp3 = ::game::model::VialModel_obj::getVialData(sourceTile->getItemId())->maxVialCount;
HXDLIN(  84)			 ::objects::Player _hx_tmp4 = ::Global_obj::gameSprite->map->player;
HXLINE(  81)			_hx_tmp = (_hx_tmp3 <= _hx_tmp4->getVialCount(sourceTile->getItemId()));
            		}
            		else {
HXLINE(  81)			_hx_tmp = true;
            		}
HXDLIN(  81)		if (_hx_tmp) {
HXLINE(  85)			return;
            		}
HXLINE(  87)		 ::objects::Player _hx_tmp5 = this->curPlayer;
HXDLIN(  87)		 ::objects::GameObject _hx_tmp6 = this->owner;
HXDLIN(  87)		int sourceTile1 = sourceTile->tileId;
HXDLIN(  87)		int sourceTile2 = sourceTile->itemSprite->itemId;
HXDLIN(  87)		 ::objects::Player _hx_tmp7 = this->curPlayer;
HXDLIN(  87)		::network::NetworkHandler_obj::invSwapVial(_hx_tmp5,_hx_tmp6,sourceTile1,sourceTile2,_hx_tmp7,::game::model::VialModel_obj::getVialSlot(sourceTile->getItemId()),-1);
HXLINE(  89)		sourceTile->setItem(-1);
HXLINE(  90)		sourceTile->updateUseability(this->curPlayer);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,addToVialStack,(void))

void ItemGrid_obj::dropItem( ::ui::panels::itemgrids::itemtiles::InteractiveItemTile itemTile){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_93_dropItem)
HXLINE(  94)		::Array< int > equipment = null();
HXLINE(  95)		int equipCount = 0;
HXLINE(  97)		bool isUntradable = ::objects::ObjectLibrary_obj::isUntradable(itemTile->itemSprite->itemId);
HXLINE(  98)		bool _hx_tmp;
HXDLIN(  98)		bool _hx_tmp1;
HXDLIN(  98)		 ::objects::GameObject tmp = this->owner;
HXDLIN(  98)		 ::map::Map _hx_tmp2;
HXDLIN(  98)		if (::hx::IsNotNull( tmp )) {
HXLINE(  98)			_hx_tmp2 = tmp->map;
            		}
            		else {
HXLINE(  98)			_hx_tmp2 = null();
            		}
HXDLIN(  98)		if (::hx::IsNotNull( _hx_tmp2 )) {
HXLINE(  98)			if ((this->owner->objectId != this->curPlayer->objectId)) {
HXLINE(  98)				_hx_tmp1 = (this->owner->ownerId == this->curPlayer->accountId);
            			}
            			else {
HXLINE(  98)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE(  98)			_hx_tmp1 = false;
            		}
HXDLIN(  98)		if (_hx_tmp1) {
HXLINE(  98)			_hx_tmp = !(isUntradable);
            		}
            		else {
HXLINE(  98)			_hx_tmp = false;
            		}
HXDLIN(  98)		if (_hx_tmp) {
HXLINE( 100)			 ::objects::GameObject go = this->owner->map->getGameObject(::Global_obj::currentInteractiveTarget);
HXLINE( 101)			::String _hx_tmp3;
HXDLIN( 101)			if (::hx::IsNotNull( go )) {
HXLINE( 101)				_hx_tmp3 = go->objClass;
            			}
            			else {
HXLINE( 101)				_hx_tmp3 = null();
            			}
HXDLIN( 101)			if ((_hx_tmp3 == HX_("Container",21,55,46,61))) {
HXLINE( 102)				equipment = go->equipment;
HXLINE( 103)				equipCount = equipment->length;
HXLINE( 104)				{
HXLINE( 104)					int _g = 0;
HXDLIN( 104)					int _g1 = equipCount;
HXDLIN( 104)					while((_g < _g1)){
HXLINE( 104)						_g = (_g + 1);
HXLINE( 105)						if ((equipment->__get((_g - 1)) < 0)) {
HXLINE( 106)							goto _hx_goto_4;
            						}
            					}
            					_hx_goto_4:;
            				}
HXLINE( 108)				if ((0 < equipCount)) {
HXLINE( 109)					this->dropWithoutDestTile(itemTile,go,0);
            				}
            				else {
HXLINE( 111)					 ::objects::GameObject _hx_tmp4 = this->owner;
HXDLIN( 111)					int itemTile1 = itemTile->tileId;
HXDLIN( 111)					::network::NetworkHandler_obj::invDrop(_hx_tmp4,itemTile1,itemTile->getItemId());
            				}
            			}
            			else {
HXLINE( 113)				 ::objects::GameObject _hx_tmp5 = this->owner;
HXDLIN( 113)				int itemTile2 = itemTile->tileId;
HXDLIN( 113)				::network::NetworkHandler_obj::invDrop(_hx_tmp5,itemTile2,itemTile->getItemId());
            			}
            		}
HXLINE( 115)		itemTile->setItem(-1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,dropItem,(void))

bool ItemGrid_obj::swapItemTiles( ::ui::panels::itemgrids::itemtiles::ItemTile sourceTile, ::ui::panels::itemgrids::itemtiles::ItemTile destTile){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_118_swapItemTiles)
HXLINE( 119)		bool _hx_tmp;
HXDLIN( 119)		bool _hx_tmp1;
HXDLIN( 119)		bool _hx_tmp2;
HXDLIN( 119)		if (::hx::IsNotNull( ::hx::ClassOf< ::network::NetworkHandler >() )) {
HXLINE( 119)			_hx_tmp2 = !(this->interactive);
            		}
            		else {
HXLINE( 119)			_hx_tmp2 = true;
            		}
HXDLIN( 119)		if (!(_hx_tmp2)) {
HXLINE( 119)			_hx_tmp1 = ::hx::IsNull( sourceTile );
            		}
            		else {
HXLINE( 119)			_hx_tmp1 = true;
            		}
HXDLIN( 119)		if (!(_hx_tmp1)) {
HXLINE( 119)			_hx_tmp = ::hx::IsNull( destTile );
            		}
            		else {
HXLINE( 119)			_hx_tmp = true;
            		}
HXDLIN( 119)		if (_hx_tmp) {
HXLINE( 120)			return false;
            		}
HXLINE( 122)		::network::NetworkHandler_obj::invSwap(this->curPlayer,this->owner,sourceTile->tileId,sourceTile->itemSprite->itemId,destTile->ownerGrid->owner,destTile->tileId,destTile->itemSprite->itemId);
HXLINE( 124)		int tempItemId = sourceTile->getItemId();
HXLINE( 125)		sourceTile->setItem(destTile->getItemId());
HXLINE( 126)		destTile->setItem(tempItemId);
HXLINE( 127)		sourceTile->updateUseability(this->curPlayer);
HXLINE( 128)		destTile->updateUseability(this->curPlayer);
HXLINE( 129)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ItemGrid_obj,swapItemTiles,return )

void ItemGrid_obj::dropWithoutDestTile( ::ui::panels::itemgrids::itemtiles::ItemTile sourceTile, ::objects::GameObject container,int containerIndex){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_132_dropWithoutDestTile)
HXLINE( 133)		bool _hx_tmp;
HXDLIN( 133)		bool _hx_tmp1;
HXDLIN( 133)		bool _hx_tmp2;
HXDLIN( 133)		if (::hx::IsNotNull( ::hx::ClassOf< ::network::NetworkHandler >() )) {
HXLINE( 133)			_hx_tmp2 = !(this->interactive);
            		}
            		else {
HXLINE( 133)			_hx_tmp2 = true;
            		}
HXDLIN( 133)		if (!(_hx_tmp2)) {
HXLINE( 133)			_hx_tmp1 = ::hx::IsNull( sourceTile );
            		}
            		else {
HXLINE( 133)			_hx_tmp1 = true;
            		}
HXDLIN( 133)		if (!(_hx_tmp1)) {
HXLINE( 133)			_hx_tmp = ::hx::IsNull( container );
            		}
            		else {
HXLINE( 133)			_hx_tmp = true;
            		}
HXDLIN( 133)		if (_hx_tmp) {
HXLINE( 134)			return;
            		}
HXLINE( 136)		::network::NetworkHandler_obj::invSwap(this->curPlayer,this->owner,sourceTile->tileId,sourceTile->itemSprite->itemId,container,containerIndex,-1);
HXLINE( 137)		sourceTile->setItem(-1);
            	}


HX_DEFINE_DYNAMIC_FUNC3(ItemGrid_obj,dropWithoutDestTile,(void))

void ItemGrid_obj::equipOrUseContainer( ::ui::panels::itemgrids::itemtiles::InteractiveItemTile tile){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_140_equipOrUseContainer)
HXLINE( 141)		 ::objects::GameObject tileOwner = tile->ownerGrid->owner;
HXLINE( 142)		 ::objects::Player player = this->curPlayer;
HXLINE( 143)		int nextAvailableSlotIndex = this->curPlayer->nextAvailableInventorySlot();
HXLINE( 144)		if ((nextAvailableSlotIndex != -1)) {
HXLINE( 145)			::network::NetworkHandler_obj::invSwap(player,this->owner,tile->tileId,tile->itemSprite->itemId,this->curPlayer,nextAvailableSlotIndex,-1);
            		}
            		else {
HXLINE( 147)			::network::NetworkHandler_obj::useItem_new(tileOwner,tile->tileId);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,equipOrUseContainer,(void))

void ItemGrid_obj::equipOrUseInventory( ::ui::panels::itemgrids::itemtiles::InteractiveItemTile tile){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_150_equipOrUseInventory)
HXLINE( 151)		 ::objects::GameObject tileOwner = tile->ownerGrid->owner;
HXLINE( 152)		 ::objects::Player player = this->curPlayer;
HXLINE( 153)		int matchingSlotIndex = ::objects::ObjectLibrary_obj::getMatchingSlotIndex(tile->getItemId(),player);
HXLINE( 154)		if ((matchingSlotIndex != -1)) {
HXLINE( 155)			int tile1 = tile->tileId;
HXDLIN( 155)			int _hx_tmp = tile->getItemId();
HXDLIN( 155)			::network::NetworkHandler_obj::invSwap(player,tileOwner,tile1,_hx_tmp,player,matchingSlotIndex,player->equipment->__get(matchingSlotIndex));
            		}
            		else {
HXLINE( 157)			::network::NetworkHandler_obj::useItem_new(tileOwner,tile->tileId);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,equipOrUseInventory,(void))

void ItemGrid_obj::onTileMove( ::ui::panels::itemgrids::itemtiles::ItemTileEvent e){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_160_onTileMove)
HXLINE( 161)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile targetTile = null();
HXLINE( 162)		int slot = 0;
HXLINE( 163)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile sourceTile = e->tile;
HXLINE( 164)		 ::openfl::display::DisplayObject target = sourceTile->getDropTarget();
HXLINE( 165)		bool _hx_tmp;
HXDLIN( 165)		bool _hx_tmp1;
HXDLIN( 165)		if ((sourceTile->getItemId() != 2721)) {
HXLINE( 165)			_hx_tmp1 = (sourceTile->getItemId() == 2722);
            		}
            		else {
HXLINE( 165)			_hx_tmp1 = true;
            		}
HXDLIN( 165)		if (_hx_tmp1) {
HXLINE( 165)			_hx_tmp = ::Std_obj::isOfType(target,::hx::ClassOf< ::ui::view::VialSlotView >());
            		}
            		else {
HXLINE( 165)			_hx_tmp = false;
            		}
HXDLIN( 165)		if (_hx_tmp) {
HXLINE( 167)			this->onVialMove(e);
HXLINE( 168)			return;
            		}
            		else {
HXLINE( 169)			if (::Std_obj::isOfType(target,::hx::ClassOf< ::ui::panels::itemgrids::itemtiles::InteractiveItemTile >())) {
HXLINE( 170)				targetTile = ::hx::TCast<  ::ui::panels::itemgrids::itemtiles::InteractiveItemTile >::cast(target);
HXLINE( 171)				bool _hx_tmp2;
HXDLIN( 171)				if (sourceTile->canHoldItem(targetTile->getItemId())) {
HXLINE( 171)					_hx_tmp2 = targetTile->canHoldItem(sourceTile->getItemId());
            				}
            				else {
HXLINE( 171)					_hx_tmp2 = false;
            				}
HXDLIN( 171)				if (_hx_tmp2) {
HXLINE( 172)					this->swapItemTiles(sourceTile,targetTile);
            				}
            			}
            			else {
HXLINE( 173)				if (::Std_obj::isOfType(target,::hx::ClassOf< ::ui::view::Inventory >())) {
HXLINE( 174)					slot = sourceTile->ownerGrid->curPlayer->nextAvailableInventorySlot();
HXLINE( 175)					if ((slot != -1)) {
HXLINE( 176)						::network::NetworkHandler_obj::invSwap(this->curPlayer,sourceTile->ownerGrid->owner,sourceTile->tileId,sourceTile->itemSprite->itemId,this->curPlayer,slot,-1);
HXLINE( 178)						sourceTile->setItem(-1);
HXLINE( 179)						sourceTile->updateUseability(this->curPlayer);
            					}
            				}
            				else {
HXLINE( 181)					bool _hx_tmp3;
HXDLIN( 181)					if (::hx::IsNotNull( target )) {
HXLINE( 181)						_hx_tmp3 = ::Std_obj::isOfType(target,::hx::ClassOf< ::openfl::display::Stage >());
            					}
            					else {
HXLINE( 181)						_hx_tmp3 = true;
            					}
HXDLIN( 181)					if (_hx_tmp3) {
HXLINE( 182)						this->dropItem(sourceTile);
            					}
            				}
            			}
            		}
HXLINE( 184)		sourceTile->resetItemPosition();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onTileMove,(void))

void ItemGrid_obj::onVialMove( ::ui::panels::itemgrids::itemtiles::ItemTileEvent e){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_187_onVialMove)
HXLINE( 188)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile sourceTile = e->tile;
HXLINE( 189)		 ::openfl::display::DisplayObject target = sourceTile->getDropTarget();
HXLINE( 190)		bool _hx_tmp;
HXDLIN( 190)		if (::hx::IsNotNull( target )) {
HXLINE( 190)			_hx_tmp = ::Std_obj::isOfType(target,::hx::ClassOf< ::openfl::display::Stage >());
            		}
            		else {
HXLINE( 190)			_hx_tmp = true;
            		}
HXDLIN( 190)		if (_hx_tmp) {
HXLINE( 191)			this->dropItem(sourceTile);
            		}
            		else {
HXLINE( 192)			if (::Std_obj::isOfType(target,::hx::ClassOf< ::ui::view::VialSlotView >())) {
HXLINE( 193)				this->addToVialStack(sourceTile);
            			}
            		}
HXLINE( 195)		sourceTile->resetItemPosition();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onVialMove,(void))

void ItemGrid_obj::onCtrlClick( ::ui::panels::itemgrids::itemtiles::ItemTileEvent e){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_204_onCtrlClick)
HXLINE( 205)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile tile = e->tile;
HXLINE( 206)		int slot = 0;
HXLINE( 207)		if (::Std_obj::isOfType(tile->ownerGrid,::hx::ClassOf< ::ui::panels::itemgrids::InventoryGrid >())) {
HXLINE( 208)			slot = tile->ownerGrid->curPlayer->swapInventoryIndex(::Global_obj::tabStripModel->currentSelection);
HXLINE( 209)			if ((slot != -1)) {
HXLINE( 210)				::network::NetworkHandler_obj::invSwap(this->curPlayer,tile->ownerGrid->owner,tile->tileId,tile->itemSprite->itemId,this->curPlayer,slot,-1);
HXLINE( 211)				tile->setItem(-1);
HXLINE( 212)				tile->updateUseability(this->curPlayer);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onCtrlClick,(void))

void ItemGrid_obj::onDoubleClick( ::ui::panels::itemgrids::itemtiles::ItemTileEvent e){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_217_onDoubleClick)
HXLINE( 218)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile tile = e->tile;
HXLINE( 219)		if (::Std_obj::isOfType(tile->ownerGrid,::hx::ClassOf< ::ui::panels::itemgrids::ContainerGrid >())) {
HXLINE( 220)			this->equipOrUseContainer(tile);
            		}
            		else {
HXLINE( 222)			this->equipOrUseInventory(tile);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onDoubleClick,(void))

void ItemGrid_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_226_draw)
HXDLIN( 226)		this->setItems(this->owner->equipment,this->indexOffset);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ItemGrid_obj,draw,(void))

void ItemGrid_obj::setItems(::Array< int > items,::hx::Null< int >  __o_itemIndexOffset){
            		int itemIndexOffset = __o_itemIndexOffset.Default(0);
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_229_setItems)
            	}


HX_DEFINE_DYNAMIC_FUNC2(ItemGrid_obj,setItems,(void))

void ItemGrid_obj::addToGrid( ::ui::panels::itemgrids::itemtiles::ItemTile tile,int numRows,int tileIndex){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_231_addToGrid)
HXLINE( 232)		::Array< int > _hx_tmp;
HXDLIN( 232)		if (this->disableBgDraw) {
HXLINE( 232)			_hx_tmp = null();
            		}
            		else {
HXLINE( 232)			_hx_tmp = ::ui::panels::itemgrids::ItemGrid_obj::CutsByNum->__get(numRows).StaticCast< ::Array< ::Dynamic> >()->__get(tileIndex).StaticCast< ::Array< int > >();
            		}
HXDLIN( 232)		tile->drawBackground(_hx_tmp);
HXLINE( 233)		tile->addEventListener(HX_("rollOver",71,ab,a8,12),this->onTileHover_dyn(),null(),null(),null());
HXLINE( 234)		tile->set_x(( (Float)((::Std_obj::_hx_int(( (Float)(::hx::Mod(tileIndex,4)) )) * 44)) ));
HXLINE( 235)		tile->set_y(( (Float)((::Std_obj::_hx_int((( (Float)(tileIndex) ) / ( (Float)(4) ))) * 44)) ));
HXLINE( 236)		this->addChild(tile);
            	}


HX_DEFINE_DYNAMIC_FUNC3(ItemGrid_obj,addToGrid,(void))

::String ItemGrid_obj::getCharacterType(){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_239_getCharacterType)
HXLINE( 240)		if (::hx::IsInstanceEq( this->owner,this->curPlayer )) {
HXLINE( 241)			return HX_("CURRENT_PLAYER",07,5e,b6,a9);
            		}
HXLINE( 243)		if (::Std_obj::isOfType(this->owner,::hx::ClassOf< ::objects::Player >())) {
HXLINE( 244)			return HX_("OTHER_PLAYER",50,40,ec,2d);
            		}
HXLINE( 246)		return HX_("NPC",c1,75,3b,00);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ItemGrid_obj,getCharacterType,return )

void ItemGrid_obj::onTileHover( ::openfl::events::MouseEvent e){
            	HX_GC_STACKFRAME(&_hx_pos_b4a36b805b37501c_249_onTileHover)
HXLINE( 250)		if (::hx::IsNull( this->stage )) {
HXLINE( 251)			return;
            		}
HXLINE( 253)		 ::ui::panels::itemgrids::itemtiles::ItemTile tile = ::hx::TCast<  ::ui::panels::itemgrids::itemtiles::ItemTile >::cast(e->currentTarget);
HXLINE( 254)		if ((tile->itemSprite->itemId > 0)) {
HXLINE( 255)			int tile1 = tile->itemSprite->itemId;
HXDLIN( 255)			 ::objects::Player _hx_tmp = this->curPlayer;
HXDLIN( 255)			int _hx_tmp1;
HXDLIN( 255)			if (::hx::IsNotNull( this->owner )) {
HXLINE( 255)				_hx_tmp1 = this->owner->objectType;
            			}
            			else {
HXLINE( 255)				_hx_tmp1 = -1;
            			}
HXLINE( 256)			::String _hx_tmp2 = this->getCharacterType();
HXLINE( 255)			this->tooltip =  ::ui::tooltip::EquipmentToolTip_obj::__alloc( HX_CTX ,tile1,_hx_tmp,_hx_tmp1,_hx_tmp2,tile->tileId);
HXLINE( 257)			this->tooltip->attachToTarget(tile);
HXLINE( 258)			this->stage->addChild(this->tooltip);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onTileHover,(void))

::Array< int > ItemGrid_obj::NO_CUT;

::Array< ::Dynamic> ItemGrid_obj::CutsByNum;

void ItemGrid_obj::onShiftClick( ::ui::panels::itemgrids::itemtiles::ItemTileEvent e){
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_198_onShiftClick)
HXLINE( 199)		 ::ui::panels::itemgrids::itemtiles::InteractiveItemTile tile = e->tile;
HXLINE( 200)		bool _hx_tmp;
HXDLIN( 200)		if (!(::Std_obj::isOfType(tile->ownerGrid,::hx::ClassOf< ::ui::panels::itemgrids::InventoryGrid >()))) {
HXLINE( 200)			_hx_tmp = ::Std_obj::isOfType(tile->ownerGrid,::hx::ClassOf< ::ui::panels::itemgrids::ContainerGrid >());
            		}
            		else {
HXLINE( 200)			_hx_tmp = true;
            		}
HXDLIN( 200)		if (_hx_tmp) {
HXLINE( 201)			::network::NetworkHandler_obj::useItem_new(tile->ownerGrid->owner,tile->tileId);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ItemGrid_obj,onShiftClick,(void))


::hx::ObjectPtr< ItemGrid_obj > ItemGrid_obj::__new( ::objects::GameObject gridOwner, ::objects::Player currentPlayer,int itemIndexOffset,::hx::Null< bool >  __o_disableBgDraw) {
	::hx::ObjectPtr< ItemGrid_obj > __this = new ItemGrid_obj();
	__this->__construct(gridOwner,currentPlayer,itemIndexOffset,__o_disableBgDraw);
	return __this;
}

::hx::ObjectPtr< ItemGrid_obj > ItemGrid_obj::__alloc(::hx::Ctx *_hx_ctx, ::objects::GameObject gridOwner, ::objects::Player currentPlayer,int itemIndexOffset,::hx::Null< bool >  __o_disableBgDraw) {
	ItemGrid_obj *__this = (ItemGrid_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ItemGrid_obj), true, "ui.panels.itemgrids.ItemGrid"));
	*(void **)__this = ItemGrid_obj::_hx_vtable;
	__this->__construct(gridOwner,currentPlayer,itemIndexOffset,__o_disableBgDraw);
	return __this;
}

ItemGrid_obj::ItemGrid_obj()
{
}

void ItemGrid_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ItemGrid);
	HX_MARK_MEMBER_NAME(owner,"owner");
	HX_MARK_MEMBER_NAME(curPlayer,"curPlayer");
	HX_MARK_MEMBER_NAME(interactive,"interactive");
	HX_MARK_MEMBER_NAME(indexOffset,"indexOffset");
	HX_MARK_MEMBER_NAME(disableBgDraw,"disableBgDraw");
	HX_MARK_MEMBER_NAME(tooltip,"tooltip");
	 ::ui::panels::Panel_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ItemGrid_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(owner,"owner");
	HX_VISIT_MEMBER_NAME(curPlayer,"curPlayer");
	HX_VISIT_MEMBER_NAME(interactive,"interactive");
	HX_VISIT_MEMBER_NAME(indexOffset,"indexOffset");
	HX_VISIT_MEMBER_NAME(disableBgDraw,"disableBgDraw");
	HX_VISIT_MEMBER_NAME(tooltip,"tooltip");
	 ::ui::panels::Panel_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ItemGrid_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"owner") ) { return ::hx::Val( owner ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tooltip") ) { return ::hx::Val( tooltip ); }
		if (HX_FIELD_EQ(inName,"onAdded") ) { return ::hx::Val( onAdded_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"dropItem") ) { return ::hx::Val( dropItem_dyn() ); }
		if (HX_FIELD_EQ(inName,"setItems") ) { return ::hx::Val( setItems_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curPlayer") ) { return ::hx::Val( curPlayer ); }
		if (HX_FIELD_EQ(inName,"onRemoved") ) { return ::hx::Val( onRemoved_dyn() ); }
		if (HX_FIELD_EQ(inName,"addToGrid") ) { return ::hx::Val( addToGrid_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"onTileMove") ) { return ::hx::Val( onTileMove_dyn() ); }
		if (HX_FIELD_EQ(inName,"onVialMove") ) { return ::hx::Val( onVialMove_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"interactive") ) { return ::hx::Val( interactive ); }
		if (HX_FIELD_EQ(inName,"indexOffset") ) { return ::hx::Val( indexOffset ); }
		if (HX_FIELD_EQ(inName,"onCtrlClick") ) { return ::hx::Val( onCtrlClick_dyn() ); }
		if (HX_FIELD_EQ(inName,"onTileHover") ) { return ::hx::Val( onTileHover_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"disableBgDraw") ) { return ::hx::Val( disableBgDraw ); }
		if (HX_FIELD_EQ(inName,"swapItemTiles") ) { return ::hx::Val( swapItemTiles_dyn() ); }
		if (HX_FIELD_EQ(inName,"onDoubleClick") ) { return ::hx::Val( onDoubleClick_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"addToVialStack") ) { return ::hx::Val( addToVialStack_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"getCharacterType") ) { return ::hx::Val( getCharacterType_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"dropWithoutDestTile") ) { return ::hx::Val( dropWithoutDestTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"equipOrUseContainer") ) { return ::hx::Val( equipOrUseContainer_dyn() ); }
		if (HX_FIELD_EQ(inName,"equipOrUseInventory") ) { return ::hx::Val( equipOrUseInventory_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ItemGrid_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"NO_CUT") ) { outValue = ( NO_CUT ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"CutsByNum") ) { outValue = ( CutsByNum ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onShiftClick") ) { outValue = onShiftClick_dyn(); return true; }
	}
	return false;
}

::hx::Val ItemGrid_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"owner") ) { owner=inValue.Cast<  ::objects::GameObject >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tooltip") ) { tooltip=inValue.Cast<  ::ui::tooltip::EquipmentToolTip >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curPlayer") ) { curPlayer=inValue.Cast<  ::objects::Player >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"interactive") ) { interactive=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"indexOffset") ) { indexOffset=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"disableBgDraw") ) { disableBgDraw=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ItemGrid_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"NO_CUT") ) { NO_CUT=ioValue.Cast< ::Array< int > >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"CutsByNum") ) { CutsByNum=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

void ItemGrid_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("owner",33,98,76,38));
	outFields->push(HX_("curPlayer",01,05,46,a8));
	outFields->push(HX_("interactive",e2,3d,59,3c));
	outFields->push(HX_("indexOffset",45,40,51,85));
	outFields->push(HX_("disableBgDraw",71,b0,9d,1f));
	outFields->push(HX_("tooltip",03,ad,8c,6a));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ItemGrid_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::objects::GameObject */ ,(int)offsetof(ItemGrid_obj,owner),HX_("owner",33,98,76,38)},
	{::hx::fsObject /*  ::objects::Player */ ,(int)offsetof(ItemGrid_obj,curPlayer),HX_("curPlayer",01,05,46,a8)},
	{::hx::fsBool,(int)offsetof(ItemGrid_obj,interactive),HX_("interactive",e2,3d,59,3c)},
	{::hx::fsInt,(int)offsetof(ItemGrid_obj,indexOffset),HX_("indexOffset",45,40,51,85)},
	{::hx::fsBool,(int)offsetof(ItemGrid_obj,disableBgDraw),HX_("disableBgDraw",71,b0,9d,1f)},
	{::hx::fsObject /*  ::ui::tooltip::EquipmentToolTip */ ,(int)offsetof(ItemGrid_obj,tooltip),HX_("tooltip",03,ad,8c,6a)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo ItemGrid_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< int > */ ,(void *) &ItemGrid_obj::NO_CUT,HX_("NO_CUT",24,5f,7c,eb)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(void *) &ItemGrid_obj::CutsByNum,HX_("CutsByNum",1e,a2,a9,7c)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String ItemGrid_obj_sMemberFields[] = {
	HX_("owner",33,98,76,38),
	HX_("curPlayer",01,05,46,a8),
	HX_("interactive",e2,3d,59,3c),
	HX_("indexOffset",45,40,51,85),
	HX_("disableBgDraw",71,b0,9d,1f),
	HX_("tooltip",03,ad,8c,6a),
	HX_("onAdded",21,73,81,b2),
	HX_("onRemoved",41,d8,aa,ca),
	HX_("addToVialStack",ee,7d,19,b5),
	HX_("dropItem",e2,6c,5a,eb),
	HX_("swapItemTiles",5f,ae,42,8c),
	HX_("dropWithoutDestTile",a9,01,95,d0),
	HX_("equipOrUseContainer",8d,fc,e0,f0),
	HX_("equipOrUseInventory",e8,fd,23,7a),
	HX_("onTileMove",9e,dd,1d,60),
	HX_("onVialMove",4e,d9,63,74),
	HX_("onCtrlClick",7e,fa,1f,2f),
	HX_("onDoubleClick",98,20,60,30),
	HX_("draw",04,2c,70,42),
	HX_("setItems",fe,14,41,d0),
	HX_("addToGrid",e2,76,49,32),
	HX_("getCharacterType",8d,2c,16,b0),
	HX_("onTileHover",8f,26,03,d9),
	::String(null()) };

static void ItemGrid_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ItemGrid_obj::NO_CUT,"NO_CUT");
	HX_MARK_MEMBER_NAME(ItemGrid_obj::CutsByNum,"CutsByNum");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ItemGrid_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ItemGrid_obj::NO_CUT,"NO_CUT");
	HX_VISIT_MEMBER_NAME(ItemGrid_obj::CutsByNum,"CutsByNum");
};

#endif

::hx::Class ItemGrid_obj::__mClass;

static ::String ItemGrid_obj_sStaticFields[] = {
	HX_("NO_CUT",24,5f,7c,eb),
	HX_("CutsByNum",1e,a2,a9,7c),
	HX_("onShiftClick",65,0a,fa,2f),
	::String(null())
};

void ItemGrid_obj::__register()
{
	ItemGrid_obj _hx_dummy;
	ItemGrid_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("ui.panels.itemgrids.ItemGrid",12,e5,83,20);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ItemGrid_obj::__GetStatic;
	__mClass->mSetStaticField = &ItemGrid_obj::__SetStatic;
	__mClass->mMarkFunc = ItemGrid_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ItemGrid_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ItemGrid_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ItemGrid_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ItemGrid_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ItemGrid_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ItemGrid_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ItemGrid_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_25_boot)
HXDLIN(  25)		NO_CUT = ::Array_obj< int >::fromData( _hx_array_data_2083e512_21,4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_b4a36b805b37501c_26_boot)
HXDLIN(  26)		CutsByNum = ::Array_obj< ::Dynamic>::__new(3)->init(0,::Array_obj< ::Dynamic>::__new(4)->init(0,::Array_obj< int >::fromData( _hx_array_data_2083e512_23,4))->init(1,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(2,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(3,::Array_obj< int >::fromData( _hx_array_data_2083e512_24,4)))->init(1,::Array_obj< ::Dynamic>::__new(8)->init(0,::Array_obj< int >::fromData( _hx_array_data_2083e512_25,4))->init(1,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(2,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(3,::Array_obj< int >::fromData( _hx_array_data_2083e512_26,4))->init(4,::Array_obj< int >::fromData( _hx_array_data_2083e512_27,4))->init(5,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(6,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(7,::Array_obj< int >::fromData( _hx_array_data_2083e512_28,4)))->init(2,::Array_obj< ::Dynamic>::__new(12)->init(0,::Array_obj< int >::fromData( _hx_array_data_2083e512_29,4))->init(1,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(2,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(3,::Array_obj< int >::fromData( _hx_array_data_2083e512_30,4))->init(4,::Array_obj< int >::fromData( _hx_array_data_2083e512_31,4))->init(5,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(6,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(7,::Array_obj< int >::fromData( _hx_array_data_2083e512_32,4))->init(8,::Array_obj< int >::fromData( _hx_array_data_2083e512_33,4))->init(9,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(10,::ui::panels::itemgrids::ItemGrid_obj::NO_CUT)->init(11,::Array_obj< int >::fromData( _hx_array_data_2083e512_34,4)));
            	}
}

} // end namespace ui
} // end namespace panels
} // end namespace itemgrids
