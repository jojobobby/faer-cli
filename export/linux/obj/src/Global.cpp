// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED__Xml_XmlType_Impl_
#include <_Xml/XmlType_Impl_.h>
#endif
#ifndef INCLUDED_account_Account
#include <account/Account.h>
#endif
#ifndef INCLUDED_account_services_BuyCharacterSlotTask
#include <account/services/BuyCharacterSlotTask.h>
#endif
#ifndef INCLUDED_account_services_BuySkinTask
#include <account/services/BuySkinTask.h>
#endif
#ifndef INCLUDED_account_services_ChangePasswordTask
#include <account/services/ChangePasswordTask.h>
#endif
#ifndef INCLUDED_account_services_DeleteCharacterTask
#include <account/services/DeleteCharacterTask.h>
#endif
#ifndef INCLUDED_account_services_GetCharListTask
#include <account/services/GetCharListTask.h>
#endif
#ifndef INCLUDED_account_services_LoadAccountTask
#include <account/services/LoadAccountTask.h>
#endif
#ifndef INCLUDED_account_services_LoginTask
#include <account/services/LoginTask.h>
#endif
#ifndef INCLUDED_account_services_RegisterAccountTask
#include <account/services/RegisterAccountTask.h>
#endif
#ifndef INCLUDED_account_services_SendPasswordReminderTask
#include <account/services/SendPasswordReminderTask.h>
#endif
#ifndef INCLUDED_account_services_UploadBehaviorTask
#include <account/services/UploadBehaviorTask.h>
#endif
#ifndef INCLUDED_account_services_UploadXmlTask
#include <account/services/UploadXmlTask.h>
#endif
#ifndef INCLUDED_account_view_BuyingDialog
#include <account/view/BuyingDialog.h>
#endif
#ifndef INCLUDED_appengine_SavedCharactersList
#include <appengine/SavedCharactersList.h>
#endif
#ifndef INCLUDED_assets_CharacterTemplate
#include <assets/CharacterTemplate.h>
#endif
#ifndef INCLUDED_characters_CharacterModel
#include <characters/CharacterModel.h>
#endif
#ifndef INCLUDED_characters_DeletingCharacterView
#include <characters/DeletingCharacterView.h>
#endif
#ifndef INCLUDED_classes_model_CharacterClass
#include <classes/model/CharacterClass.h>
#endif
#ifndef INCLUDED_classes_model_CharacterSkin
#include <classes/model/CharacterSkin.h>
#endif
#ifndef INCLUDED_classes_model_CharacterSkinState
#include <classes/model/CharacterSkinState.h>
#endif
#ifndef INCLUDED_classes_model_CharacterSkins
#include <classes/model/CharacterSkins.h>
#endif
#ifndef INCLUDED_classes_model_ClassModel
#include <classes/model/ClassModel.h>
#endif
#ifndef INCLUDED_core_Layers
#include <core/Layers.h>
#endif
#ifndef INCLUDED_core_PlayerModel
#include <core/PlayerModel.h>
#endif
#ifndef INCLUDED_core_ScreensView
#include <core/ScreensView.h>
#endif
#ifndef INCLUDED_engine_GLTextureData
#include <engine/GLTextureData.h>
#endif
#ifndef INCLUDED_engine_TextureFactory
#include <engine/TextureFactory.h>
#endif
#ifndef INCLUDED_game_GameSprite
#include <game/GameSprite.h>
#endif
#ifndef INCLUDED_game_model_GameInitData
#include <game/model/GameInitData.h>
#endif
#ifndef INCLUDED_game_model_VialModel
#include <game/model/VialModel.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lib_tasks_Task
#include <lib/tasks/Task.h>
#endif
#ifndef INCLUDED_lib_tasks_TaskData
#include <lib/tasks/TaskData.h>
#endif
#ifndef INCLUDED_lime_graphics_Image
#include <lime/graphics/Image.h>
#endif
#ifndef INCLUDED_lime_system_System
#include <lime/system/System.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool_objects_Projectile
#include <lime/utils/ObjectPool_objects_Projectile.h>
#endif
#ifndef INCLUDED_map_Map
#include <map/Map.h>
#endif
#ifndef INCLUDED_mapeditor_MapEditor
#include <mapeditor/MapEditor.h>
#endif
#ifndef INCLUDED_network_NetworkHandler
#include <network/NetworkHandler.h>
#endif
#ifndef INCLUDED_objects_GameObject
#include <objects/GameObject.h>
#endif
#ifndef INCLUDED_objects_Player
#include <objects/Player.h>
#endif
#ifndef INCLUDED_objects_Projectile
#include <objects/Projectile.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage3D
#include <openfl/display/Stage3D.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_Assets
#include <openfl/utils/Assets.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_screens_AccountLoadingScreen
#include <screens/AccountLoadingScreen.h>
#endif
#ifndef INCLUDED_screens_CharacterSelectionScreen
#include <screens/CharacterSelectionScreen.h>
#endif
#ifndef INCLUDED_screens_LoadingScreen
#include <screens/LoadingScreen.h>
#endif
#ifndef INCLUDED_servers_Server
#include <servers/Server.h>
#endif
#ifndef INCLUDED_servers_ServerModel
#include <servers/ServerModel.h>
#endif
#ifndef INCLUDED_ui_dialogs_Dialog
#include <ui/dialogs/Dialog.h>
#endif
#ifndef INCLUDED_ui_dialogs_DialogsView
#include <ui/dialogs/DialogsView.h>
#endif
#ifndef INCLUDED_ui_dialogs_ErrorDialog
#include <ui/dialogs/ErrorDialog.h>
#endif
#ifndef INCLUDED_ui_model_TabStripModel
#include <ui/model/TabStripModel.h>
#endif
#ifndef INCLUDED_ui_view_TitleView
#include <ui/view/TitleView.h>
#endif
#ifndef INCLUDED_util_EmptySignal
#include <util/EmptySignal.h>
#endif
#ifndef INCLUDED_util_Signal
#include <util/Signal.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_84_init,"Global","init",0xeb6d69db,"Global.init","Global.hx",84,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_140_init,"Global","init",0xeb6d69db,"Global.init","Global.hx",140,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_82_init,"Global","init",0xeb6d69db,"Global.init","Global.hx",82,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_159_makeDefaultSkin,"Global","makeDefaultSkin",0x891d77a5,"Global.makeDefaultSkin","Global.hx",159,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_172_playGame,"Global","playGame",0xec2b4851,"Global.playGame","Global.hx",172,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_178_useVial,"Global","useVial",0xc08798da,"Global.useVial","Global.hx",178,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_187_parseCharList,"Global","parseCharList",0xd7e7217c,"Global.parseCharList","Global.hx",187,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_217_deleteChar,"Global","deleteChar",0x611a15ac,"Global.deleteChar","Global.hx",217,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_214_deleteChar,"Global","deleteChar",0x611a15ac,"Global.deleteChar","Global.hx",214,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_235_buyCharSlot,"Global","buyCharSlot",0x2bbfd1ef,"Global.buyCharSlot","Global.hx",235,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_226_buyCharSlot,"Global","buyCharSlot",0x2bbfd1ef,"Global.buyCharSlot","Global.hx",226,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_246_invalidate,"Global","invalidate",0x5337f286,"Global.invalidate","Global.hx",246,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_249_setScreenValid,"Global","setScreenValid",0x30d2b7f9,"Global.setScreenValid","Global.hx",249,0xfa68b11b)
HX_LOCAL_STACK_FRAME(_hx_pos_babd1827f55eb107_53_boot,"Global","boot",0xe6cdb2fd,"Global.boot","Global.hx",53,0xfa68b11b)

void Global_obj::__construct() { }

Dynamic Global_obj::__CreateEmpty() { return new Global_obj; }

void *Global_obj::_hx_vtable = 0;

Dynamic Global_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Global_obj > _hx_result = new Global_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Global_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3d916843;
}

int Global_obj::currentInteractiveTarget;

 ::game::GameSprite Global_obj::gameSprite;

 ::core::Layers Global_obj::layers;

 ::mapeditor::MapEditor Global_obj::currentEditor;

 ::lime::utils::ObjectPool_objects_Projectile Global_obj::projPool;

 ::servers::ServerModel Global_obj::serverModel;

 ::classes::model::ClassModel Global_obj::classModel;

 ::core::PlayerModel Global_obj::playerModel;

 ::characters::CharacterModel Global_obj::charModel;

 ::ui::model::TabStripModel Global_obj::tabStripModel;

 ::account::services::LoadAccountTask Global_obj::loadTask;

 ::account::services::LoginTask Global_obj::loginTask;

 ::account::services::GetCharListTask Global_obj::charListTask;

 ::account::services::DeleteCharacterTask Global_obj::deleteCharacterTask;

 ::account::services::BuyCharacterSlotTask Global_obj::buyCharacterSlotTask;

 ::account::services::RegisterAccountTask Global_obj::registerAccountTask;

 ::account::services::ChangePasswordTask Global_obj::changePasswordTask;

 ::account::services::SendPasswordReminderTask Global_obj::sendPasswordReminderTask;

 ::account::services::BuySkinTask Global_obj::buySkinTask;

 ::account::services::UploadBehaviorTask Global_obj::uploadBehaviorTask;

 ::account::services::UploadXmlTask Global_obj::uploadXmlTask;

 ::util::EmptySignal Global_obj::updateAccount;

 ::util::Signal Global_obj::focusCharSkin;

void Global_obj::init( ::openfl::display::Sprite root){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::objects::Projectile _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_84_init)
HXLINE(  84)			return  ::objects::Projectile_obj::__alloc( HX_CTX );
            		}
            		HX_END_LOCAL_FUNC0(return)

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            		void _hx_run( ::openfl::events::Event _){
            			HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_140_init)
HXLINE( 141)			 ::openfl::display::BitmapData bitmapData = ::Main_obj::tempAtlas;
HXDLIN( 141)			 ::engine::GLTextureData _hx_tmp;
HXDLIN( 141)			if (::hx::IsNull( bitmapData )) {
HXLINE( 141)				_hx_tmp = null();
            			}
            			else {
HXLINE( 141)				if (::engine::TextureFactory_obj::textures->exists(bitmapData)) {
HXLINE( 141)					_hx_tmp = ( ( ::engine::GLTextureData)(::engine::TextureFactory_obj::textures->get(bitmapData)) );
            				}
            				else {
HXLINE( 141)					if (::hx::IsNull( bitmapData->image )) {
HXLINE( 141)						_hx_tmp = null();
            					}
            					else {
HXLINE( 141)						int value = bitmapData->width;
HXDLIN( 141)						value = (value - 1);
HXDLIN( 141)						value = (value | (value >> 1));
HXDLIN( 141)						value = (value | (value >> 2));
HXDLIN( 141)						value = (value | (value >> 4));
HXDLIN( 141)						value = (value | (value >> 8));
HXDLIN( 141)						value = (value | (value >> 16));
HXDLIN( 141)						value = (value + 1);
HXDLIN( 141)						int width = value;
HXDLIN( 141)						int value1 = bitmapData->height;
HXDLIN( 141)						value1 = (value1 - 1);
HXDLIN( 141)						value1 = (value1 | (value1 >> 1));
HXDLIN( 141)						value1 = (value1 | (value1 >> 2));
HXDLIN( 141)						value1 = (value1 | (value1 >> 4));
HXDLIN( 141)						value1 = (value1 | (value1 >> 8));
HXDLIN( 141)						value1 = (value1 | (value1 >> 16));
HXDLIN( 141)						value1 = (value1 + 1);
HXDLIN( 141)						int height = value1;
HXDLIN( 141)						Float xOff = (( (Float)((width - bitmapData->width)) ) / ( (Float)(2) ));
HXDLIN( 141)						Float yOff = (( (Float)((height - bitmapData->height)) ) / ( (Float)(2) ));
HXDLIN( 141)						 ::openfl::display::BitmapData bitmapTexture =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,0);
HXDLIN( 141)						bitmapTexture->copyPixels(bitmapData,bitmapData->rect, ::openfl::geom::Point_obj::__alloc( HX_CTX ,0,0),null(),null(),null());
HXDLIN( 141)						 ::engine::GLTextureData texture =  ::engine::GLTextureData_obj::__alloc( HX_CTX ,width,height,bitmapTexture);
HXDLIN( 141)						texture->xOffset = xOff;
HXDLIN( 141)						texture->yOffset = yOff;
HXDLIN( 141)						if ((::engine::TextureFactory_obj::count > 1000)) {
HXLINE( 141)							::engine::TextureFactory_obj::disposeNormalTextures();
HXDLIN( 141)							::engine::TextureFactory_obj::count = 0;
            						}
HXDLIN( 141)						::engine::TextureFactory_obj::textures->set(bitmapData,texture);
HXDLIN( 141)						::engine::TextureFactory_obj::count++;
HXDLIN( 141)						_hx_tmp = texture;
            					}
            				}
            			}
HXDLIN( 141)			::Main_obj::atlas = _hx_tmp;
HXLINE( 148)			::Main_obj::tempAtlas->dispose();
HXLINE( 150)			 ::core::ScreensView _hx_tmp1 = ::Global_obj::layers->screens;
HXDLIN( 150)			_hx_tmp1->setScreen( ::screens::AccountLoadingScreen_obj::__alloc( HX_CTX ));
HXLINE( 151)			::Global_obj::loadTask->start();
HXLINE( 152)			::Global_obj::charListTask->start();
HXLINE( 153)			::Global_obj::updateAccount->emit();
HXLINE( 154)			 ::core::ScreensView _hx_tmp2 = ::Global_obj::layers->screens;
HXDLIN( 154)			_hx_tmp2->setScreen( ::ui::view::TitleView_obj::__alloc( HX_CTX ));
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_82_init)
HXLINE(  83)		::Global_obj::projPool =  ::lime::utils::ObjectPool_objects_Projectile_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_0()),null(),null());
HXLINE(  87)		::Global_obj::loadTask =  ::account::services::LoadAccountTask_obj::__alloc( HX_CTX );
HXLINE(  88)		::Global_obj::loginTask =  ::account::services::LoginTask_obj::__alloc( HX_CTX );
HXLINE(  89)		::Global_obj::charListTask =  ::account::services::GetCharListTask_obj::__alloc( HX_CTX );
HXLINE(  90)		::Global_obj::deleteCharacterTask =  ::account::services::DeleteCharacterTask_obj::__alloc( HX_CTX );
HXLINE(  91)		::Global_obj::buyCharacterSlotTask =  ::account::services::BuyCharacterSlotTask_obj::__alloc( HX_CTX );
HXLINE(  92)		::Global_obj::registerAccountTask =  ::account::services::RegisterAccountTask_obj::__alloc( HX_CTX );
HXLINE(  93)		::Global_obj::changePasswordTask =  ::account::services::ChangePasswordTask_obj::__alloc( HX_CTX );
HXLINE(  94)		::Global_obj::sendPasswordReminderTask =  ::account::services::SendPasswordReminderTask_obj::__alloc( HX_CTX );
HXLINE(  95)		::Global_obj::buySkinTask =  ::account::services::BuySkinTask_obj::__alloc( HX_CTX );
HXLINE(  96)		::Global_obj::uploadBehaviorTask =  ::account::services::UploadBehaviorTask_obj::__alloc( HX_CTX );
HXLINE(  97)		::Global_obj::uploadXmlTask =  ::account::services::UploadXmlTask_obj::__alloc( HX_CTX );
HXLINE(  99)		::Global_obj::serverModel =  ::servers::ServerModel_obj::__alloc( HX_CTX );
HXLINE( 100)		::Global_obj::classModel =  ::classes::model::ClassModel_obj::__alloc( HX_CTX );
HXLINE( 101)		::Global_obj::playerModel =  ::core::PlayerModel_obj::__alloc( HX_CTX );
HXLINE( 102)		::Global_obj::charModel =  ::characters::CharacterModel_obj::__alloc( HX_CTX );
HXLINE( 103)		::Global_obj::tabStripModel =  ::ui::model::TabStripModel_obj::__alloc( HX_CTX );
HXLINE( 105)		::Global_obj::updateAccount =  ::util::EmptySignal_obj::__alloc( HX_CTX );
HXLINE( 106)		::Global_obj::focusCharSkin =  ::util::Signal_obj::__alloc( HX_CTX );
HXLINE( 108)		::Global_obj::layers =  ::core::Layers_obj::__alloc( HX_CTX );
HXLINE( 109)		root->addChild(::Global_obj::layers);
HXLINE( 111)		 ::Xml playersXML = ::Xml_obj::parse(::openfl::utils::Assets_obj::getText(HX_("assets/xmls/Players.xml",74,3c,e1,93)))->firstElement();
HXLINE( 112)		 ::Xml skinsXML = ::Xml_obj::parse(::openfl::utils::Assets_obj::getText(HX_("assets/xmls/Skins.xml",98,23,14,11)))->firstElement();
HXLINE( 114)		{
HXLINE( 114)			 ::Dynamic xml = playersXML->elements();
HXDLIN( 114)			while(( (bool)(xml->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 114)				 ::Xml xml1 = ( ( ::Xml)(xml->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 115)				int charType;
HXDLIN( 115)				if (::hx::IsNotNull( xml1->get(HX_("type",ba,f2,08,4d)) )) {
HXLINE( 115)					charType = ( (int)(::Std_obj::parseInt(xml1->get(HX_("type",ba,f2,08,4d)))) );
            				}
            				else {
HXLINE( 115)					charType = 0;
            				}
HXLINE( 116)				 ::classes::model::CharacterClass character = ::Global_obj::classModel->getCharacterClass(charType);
HXLINE( 117)				character->id = charType;
HXLINE( 118)				::String tmp = xml1->get(HX_("id",db,5b,00,00));
HXDLIN( 118)				::String _hx_tmp;
HXDLIN( 118)				if (::hx::IsNotNull( tmp )) {
HXLINE( 118)					_hx_tmp = tmp;
            				}
            				else {
HXLINE( 118)					_hx_tmp = HX_("",00,00,00,00);
            				}
HXDLIN( 118)				character->name = _hx_tmp;
HXLINE( 119)				::String _hx_tmp1;
HXDLIN( 119)				if (( (bool)(xml1->elementsNamed(HX_("Description",dc,a0,4f,43))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 119)					 ::Xml _this = ( ( ::Xml)(xml1->elementsNamed(HX_("Description",dc,a0,4f,43))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 119)					bool _hx_tmp2;
HXDLIN( 119)					if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE( 119)						_hx_tmp2 = (_this->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 119)						_hx_tmp2 = false;
            					}
HXDLIN( 119)					if (_hx_tmp2) {
HXLINE( 119)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            					}
HXDLIN( 119)					 ::Xml _this1 = _this->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 119)					bool _hx_tmp3;
HXDLIN( 119)					if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE( 119)						_hx_tmp3 = (_this1->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 119)						_hx_tmp3 = true;
            					}
HXDLIN( 119)					if (_hx_tmp3) {
HXLINE( 119)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            					}
HXDLIN( 119)					_hx_tmp1 = _this1->nodeValue;
            				}
            				else {
HXLINE( 119)					_hx_tmp1 = HX_("",00,00,00,00);
            				}
HXDLIN( 119)				character->description = _hx_tmp1;
HXLINE( 120)				::String _hx_tmp4;
HXDLIN( 120)				if (( (bool)(xml1->elementsNamed(HX_("HitSound",9c,a5,dd,99))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 120)					 ::Xml _this2 = ( ( ::Xml)(xml1->elementsNamed(HX_("HitSound",9c,a5,dd,99))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 120)					bool _hx_tmp5;
HXDLIN( 120)					if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)						_hx_tmp5 = (_this2->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 120)						_hx_tmp5 = false;
            					}
HXDLIN( 120)					if (_hx_tmp5) {
HXLINE( 120)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            					}
HXDLIN( 120)					 ::Xml _this3 = _this2->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 120)					bool _hx_tmp6;
HXDLIN( 120)					if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE( 120)						_hx_tmp6 = (_this3->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 120)						_hx_tmp6 = true;
            					}
HXDLIN( 120)					if (_hx_tmp6) {
HXLINE( 120)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            					}
HXDLIN( 120)					_hx_tmp4 = _this3->nodeValue;
            				}
            				else {
HXLINE( 120)					_hx_tmp4 = HX_("",00,00,00,00);
            				}
HXDLIN( 120)				character->hitSound = _hx_tmp4;
HXLINE( 121)				::String _hx_tmp7;
HXDLIN( 121)				if (( (bool)(xml1->elementsNamed(HX_("DeathSound",1b,d5,f4,79))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 121)					 ::Xml _this4 = ( ( ::Xml)(xml1->elementsNamed(HX_("DeathSound",1b,d5,f4,79))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 121)					bool _hx_tmp8;
HXDLIN( 121)					if ((_this4->nodeType != ::Xml_obj::Document)) {
HXLINE( 121)						_hx_tmp8 = (_this4->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 121)						_hx_tmp8 = false;
            					}
HXDLIN( 121)					if (_hx_tmp8) {
HXLINE( 121)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this4->nodeType)));
            					}
HXDLIN( 121)					 ::Xml _this5 = _this4->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 121)					bool _hx_tmp9;
HXDLIN( 121)					if ((_this5->nodeType != ::Xml_obj::Document)) {
HXLINE( 121)						_hx_tmp9 = (_this5->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 121)						_hx_tmp9 = true;
            					}
HXDLIN( 121)					if (_hx_tmp9) {
HXLINE( 121)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this5->nodeType)));
            					}
HXDLIN( 121)					_hx_tmp7 = _this5->nodeValue;
            				}
            				else {
HXLINE( 121)					_hx_tmp7 = HX_("",00,00,00,00);
            				}
HXDLIN( 121)				character->deathSound = _hx_tmp7;
HXLINE( 122)				int _hx_tmp10;
HXDLIN( 122)				if (( (bool)(xml1->elementsNamed(HX_("BloodProb",4f,b8,3a,b6))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 122)					 ::Xml _this6 = ( ( ::Xml)(xml1->elementsNamed(HX_("BloodProb",4f,b8,3a,b6))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 122)					bool _hx_tmp11;
HXDLIN( 122)					if ((_this6->nodeType != ::Xml_obj::Document)) {
HXLINE( 122)						_hx_tmp11 = (_this6->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 122)						_hx_tmp11 = false;
            					}
HXDLIN( 122)					if (_hx_tmp11) {
HXLINE( 122)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this6->nodeType)));
            					}
HXDLIN( 122)					 ::Xml _this7 = _this6->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 122)					bool _hx_tmp12;
HXDLIN( 122)					if ((_this7->nodeType != ::Xml_obj::Document)) {
HXLINE( 122)						_hx_tmp12 = (_this7->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 122)						_hx_tmp12 = true;
            					}
HXDLIN( 122)					if (_hx_tmp12) {
HXLINE( 122)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this7->nodeType)));
            					}
HXDLIN( 122)					_hx_tmp10 = ( (int)(::Std_obj::parseInt(_this7->nodeValue)) );
            				}
            				else {
HXLINE( 122)					_hx_tmp10 = 0;
            				}
HXDLIN( 122)				character->bloodProb = ( (float)(_hx_tmp10) );
HXLINE( 123)				::Array< int > _hx_tmp13;
HXDLIN( 123)				if (( (bool)(xml1->elementsNamed(HX_("SlotTypes",7b,69,ba,9c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 123)					 ::Xml _this8 = ( ( ::Xml)(xml1->elementsNamed(HX_("SlotTypes",7b,69,ba,9c))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 123)					bool _this9;
HXDLIN( 123)					if ((_this8->nodeType != ::Xml_obj::Document)) {
HXLINE( 123)						_this9 = (_this8->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 123)						_this9 = false;
            					}
HXDLIN( 123)					if (_this9) {
HXLINE( 123)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this8->nodeType)));
            					}
HXDLIN( 123)					 ::Xml _this10 = _this8->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 123)					bool _this11;
HXDLIN( 123)					if ((_this10->nodeType != ::Xml_obj::Document)) {
HXLINE( 123)						_this11 = (_this10->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 123)						_this11 = true;
            					}
HXDLIN( 123)					if (_this11) {
HXLINE( 123)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this10->nodeType)));
            					}
HXDLIN( 123)					::Array< ::String > _this12 = _this10->nodeValue.split(HX_(",",2c,00,00,00));
HXDLIN( 123)					::Array< int > result = ::Array_obj< int >::__new(_this12->length);
HXDLIN( 123)					{
HXLINE( 123)						int _g = 0;
HXDLIN( 123)						int _g1 = _this12->length;
HXDLIN( 123)						while((_g < _g1)){
HXLINE( 123)							_g = (_g + 1);
HXDLIN( 123)							int i = (_g - 1);
HXDLIN( 123)							{
HXLINE( 123)								int inValue = ::hx::TCast< int >::cast(::Std_obj::parseInt(( (::String)(_hx_array_unsafe_get(_this12,i)) )));
HXDLIN( 123)								result->__unsafe_set(i,inValue);
            							}
            						}
            					}
HXDLIN( 123)					_hx_tmp13 = result;
            				}
            				else {
HXLINE( 123)					_hx_tmp13 = ::Array_obj< int >::__new();
            				}
HXDLIN( 123)				character->slotTypes = _hx_tmp13;
HXLINE( 124)				::Array< int > _hx_tmp14;
HXDLIN( 124)				if (( (bool)(xml1->elementsNamed(HX_("Equipment",2e,14,58,dc))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 124)					 ::Xml _this13 = ( ( ::Xml)(xml1->elementsNamed(HX_("Equipment",2e,14,58,dc))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 124)					bool _this14;
HXDLIN( 124)					if ((_this13->nodeType != ::Xml_obj::Document)) {
HXLINE( 124)						_this14 = (_this13->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 124)						_this14 = false;
            					}
HXDLIN( 124)					if (_this14) {
HXLINE( 124)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this13->nodeType)));
            					}
HXDLIN( 124)					 ::Xml _this15 = _this13->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 124)					bool _this16;
HXDLIN( 124)					if ((_this15->nodeType != ::Xml_obj::Document)) {
HXLINE( 124)						_this16 = (_this15->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 124)						_this16 = true;
            					}
HXDLIN( 124)					if (_this16) {
HXLINE( 124)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this15->nodeType)));
            					}
HXDLIN( 124)					::Array< ::String > _this17 = _this15->nodeValue.split(HX_(",",2c,00,00,00));
HXDLIN( 124)					::Array< int > result1 = ::Array_obj< int >::__new(_this17->length);
HXDLIN( 124)					{
HXLINE( 124)						int _g2 = 0;
HXDLIN( 124)						int _g3 = _this17->length;
HXDLIN( 124)						while((_g2 < _g3)){
HXLINE( 124)							_g2 = (_g2 + 1);
HXDLIN( 124)							int i1 = (_g2 - 1);
HXDLIN( 124)							{
HXLINE( 124)								int inValue1 = ::hx::TCast< int >::cast(::Std_obj::parseInt(( (::String)(_hx_array_unsafe_get(_this17,i1)) )));
HXDLIN( 124)								result1->__unsafe_set(i1,inValue1);
            							}
            						}
            					}
HXDLIN( 124)					_hx_tmp14 = result1;
            				}
            				else {
HXLINE( 124)					_hx_tmp14 = ::Array_obj< int >::__new();
            				}
HXDLIN( 124)				character->defaultEquipment = _hx_tmp14;
HXLINE( 125)				 ::classes::model::CharacterSkins character1 = character->skins;
HXDLIN( 125)				character1->addSkin(::Global_obj::makeDefaultSkin(xml1),true);
HXLINE( 126)				::Global_obj::classModel->map->set(charType,character);
            			}
            		}
HXLINE( 129)		{
HXLINE( 129)			 ::Dynamic xml2 = skinsXML->elements();
HXDLIN( 129)			while(( (bool)(xml2->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 129)				 ::Xml xml3 = ( ( ::Xml)(xml2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 130)				 ::Xml animXML = ( ( ::Xml)(xml3->elementsNamed(HX_("AnimatedTexture",58,70,fc,07))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 131)				::String file;
HXDLIN( 131)				if (( (bool)(animXML->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 131)					 ::Xml _this18 = ( ( ::Xml)(animXML->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 131)					bool file1;
HXDLIN( 131)					if ((_this18->nodeType != ::Xml_obj::Document)) {
HXLINE( 131)						file1 = (_this18->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 131)						file1 = false;
            					}
HXDLIN( 131)					if (file1) {
HXLINE( 131)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this18->nodeType)));
            					}
HXDLIN( 131)					 ::Xml _this19 = _this18->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 131)					bool file2;
HXDLIN( 131)					if ((_this19->nodeType != ::Xml_obj::Document)) {
HXLINE( 131)						file2 = (_this19->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 131)						file2 = true;
            					}
HXDLIN( 131)					if (file2) {
HXLINE( 131)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this19->nodeType)));
            					}
HXDLIN( 131)					file = _this19->nodeValue;
            				}
            				else {
HXLINE( 131)					file = HX_("",00,00,00,00);
            				}
HXLINE( 132)				int index;
HXDLIN( 132)				if (( (bool)(animXML->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 132)					 ::Xml _this20 = ( ( ::Xml)(animXML->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 132)					bool index1;
HXDLIN( 132)					if ((_this20->nodeType != ::Xml_obj::Document)) {
HXLINE( 132)						index1 = (_this20->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 132)						index1 = false;
            					}
HXDLIN( 132)					if (index1) {
HXLINE( 132)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this20->nodeType)));
            					}
HXDLIN( 132)					 ::Xml _this21 = _this20->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 132)					bool index2;
HXDLIN( 132)					if ((_this21->nodeType != ::Xml_obj::Document)) {
HXLINE( 132)						index2 = (_this21->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 132)						index2 = true;
            					}
HXDLIN( 132)					if (index2) {
HXLINE( 132)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this21->nodeType)));
            					}
HXDLIN( 132)					index = ( (int)(::Std_obj::parseInt(_this21->nodeValue)) );
            				}
            				else {
HXLINE( 132)					index = 0;
            				}
HXLINE( 133)				 ::classes::model::CharacterSkin skin =  ::classes::model::CharacterSkin_obj::__alloc( HX_CTX );
HXLINE( 134)				int _hx_tmp15;
HXDLIN( 134)				if (::hx::IsNotNull( xml3->get(HX_("type",ba,f2,08,4d)) )) {
HXLINE( 134)					_hx_tmp15 = ( (int)(::Std_obj::parseInt(xml3->get(HX_("type",ba,f2,08,4d)))) );
            				}
            				else {
HXLINE( 134)					_hx_tmp15 = 0;
            				}
HXDLIN( 134)				skin->id = _hx_tmp15;
HXLINE( 135)				::String tmp1 = xml3->get(HX_("id",db,5b,00,00));
HXDLIN( 135)				::String _hx_tmp16;
HXDLIN( 135)				if (::hx::IsNotNull( tmp1 )) {
HXLINE( 135)					_hx_tmp16 = tmp1;
            				}
            				else {
HXLINE( 135)					_hx_tmp16 = HX_("",00,00,00,00);
            				}
HXDLIN( 135)				skin->name = _hx_tmp16;
HXLINE( 136)				skin->_hx_template =  ::assets::CharacterTemplate_obj::__alloc( HX_CTX ,file,index);
HXLINE( 137)				 ::classes::model::ClassModel _hx_tmp17 = ::Global_obj::classModel;
HXDLIN( 137)				int _hx_tmp18;
HXDLIN( 137)				if (( (bool)(xml3->elementsNamed(HX_("PlayerClassType",51,1b,2f,2c))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 137)					 ::Xml _this22 = ( ( ::Xml)(xml3->elementsNamed(HX_("PlayerClassType",51,1b,2f,2c))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 137)					bool _hx_tmp19;
HXDLIN( 137)					if ((_this22->nodeType != ::Xml_obj::Document)) {
HXLINE( 137)						_hx_tmp19 = (_this22->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 137)						_hx_tmp19 = false;
            					}
HXDLIN( 137)					if (_hx_tmp19) {
HXLINE( 137)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this22->nodeType)));
            					}
HXDLIN( 137)					 ::Xml _this23 = _this22->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 137)					bool _hx_tmp20;
HXDLIN( 137)					if ((_this23->nodeType != ::Xml_obj::Document)) {
HXLINE( 137)						_hx_tmp20 = (_this23->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 137)						_hx_tmp20 = true;
            					}
HXDLIN( 137)					if (_hx_tmp20) {
HXLINE( 137)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this23->nodeType)));
            					}
HXDLIN( 137)					_hx_tmp18 = ( (int)(::Std_obj::parseInt(_this23->nodeValue)) );
            				}
            				else {
HXLINE( 137)					_hx_tmp18 = 0;
            				}
HXDLIN( 137)				_hx_tmp17->getCharacterClass(_hx_tmp18)->skins->addSkin(skin,null());
            			}
            		}
HXLINE( 140)		::Main_obj::primaryStage3D->addEventListener(HX_("context3DCreate",7c,bf,59,7b), ::Dynamic(new _hx_Closure_1()),null(),null(),null());
HXLINE( 156)		::Main_obj::primaryStage3D->requestContext3D(null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,init,(void))

 ::classes::model::CharacterSkin Global_obj::makeDefaultSkin( ::Xml xml){
            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_159_makeDefaultSkin)
HXLINE( 160)		 ::Xml animXML = ( ( ::Xml)(xml->elementsNamed(HX_("AnimatedTexture",58,70,fc,07))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 161)		::String file;
HXDLIN( 161)		if (( (bool)(animXML->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 161)			 ::Xml _this = ( ( ::Xml)(animXML->elementsNamed(HX_("Sheet",7f,52,4d,0f))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 161)			bool file1;
HXDLIN( 161)			if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE( 161)				file1 = (_this->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 161)				file1 = false;
            			}
HXDLIN( 161)			if (file1) {
HXLINE( 161)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            			}
HXDLIN( 161)			 ::Xml _this1 = _this->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 161)			bool file2;
HXDLIN( 161)			if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE( 161)				file2 = (_this1->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 161)				file2 = true;
            			}
HXDLIN( 161)			if (file2) {
HXLINE( 161)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            			}
HXDLIN( 161)			file = _this1->nodeValue;
            		}
            		else {
HXLINE( 161)			file = HX_("",00,00,00,00);
            		}
HXLINE( 162)		int index;
HXDLIN( 162)		if (( (bool)(animXML->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 162)			 ::Xml _this2 = ( ( ::Xml)(animXML->elementsNamed(HX_("Index",f2,0a,42,51))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 162)			bool index1;
HXDLIN( 162)			if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE( 162)				index1 = (_this2->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 162)				index1 = false;
            			}
HXDLIN( 162)			if (index1) {
HXLINE( 162)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            			}
HXDLIN( 162)			 ::Xml _this3 = _this2->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 162)			bool index2;
HXDLIN( 162)			if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE( 162)				index2 = (_this3->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 162)				index2 = true;
            			}
HXDLIN( 162)			if (index2) {
HXLINE( 162)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            			}
HXDLIN( 162)			index = ( (int)(::Std_obj::parseInt(_this3->nodeValue)) );
            		}
            		else {
HXLINE( 162)			index = 0;
            		}
HXLINE( 163)		 ::classes::model::CharacterSkin skin =  ::classes::model::CharacterSkin_obj::__alloc( HX_CTX );
HXLINE( 164)		skin->id = -1;
HXLINE( 165)		skin->name = HX_("Classic",f2,79,e2,36);
HXLINE( 166)		skin->_hx_template =  ::assets::CharacterTemplate_obj::__alloc( HX_CTX ,file,index);
HXLINE( 167)		skin->setState(::classes::model::CharacterSkinState_obj::OWNED);
HXLINE( 168)		skin->setIsSelected(true);
HXLINE( 169)		return skin;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,makeDefaultSkin,return )

void Global_obj::playGame( ::game::model::GameInitData gameInit){
            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_172_playGame)
HXLINE( 173)		::Global_obj::playerModel->currentCharId = gameInit->charId;
HXLINE( 174)		 ::servers::Server _hx_tmp = ::Global_obj::serverModel->getServer();
HXDLIN( 174)		::Global_obj::gameSprite =  ::game::GameSprite_obj::__alloc( HX_CTX ,_hx_tmp,gameInit->gameId,gameInit->createCharacter,gameInit->charId,gameInit->fmMap);
HXLINE( 175)		::Global_obj::layers->screens->setScreen(::Global_obj::gameSprite);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,playGame,(void))

void Global_obj::useVial(int vialId){
            	HX_STACKFRAME(&_hx_pos_babd1827f55eb107_178_useVial)
HXLINE( 179)		 ::objects::Player player = ::Global_obj::gameSprite->map->player;
HXLINE( 180)		bool _hx_tmp;
HXDLIN( 180)		bool _hx_tmp1;
HXDLIN( 180)		if ((player->getVialCount(vialId) > 0)) {
HXLINE( 180)			if ((vialId == 2721)) {
HXLINE( 180)				_hx_tmp1 = (player->hp >= player->maxHP);
            			}
            			else {
HXLINE( 180)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXLINE( 180)			_hx_tmp1 = true;
            		}
HXDLIN( 180)		if (!(_hx_tmp1)) {
HXLINE( 180)			if ((vialId == 2722)) {
HXLINE( 180)				_hx_tmp = (player->mp >= player->maxMP);
            			}
            			else {
HXLINE( 180)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 180)			_hx_tmp = true;
            		}
HXDLIN( 180)		if (_hx_tmp) {
HXLINE( 182)			return;
            		}
HXLINE( 184)		int _hx_tmp2 = ::lime::_hx_system::System_obj::getTimer();
HXDLIN( 184)		::network::NetworkHandler_obj::useItem(_hx_tmp2,player->objectId,::game::model::VialModel_obj::getVialSlot(vialId),vialId,( (Float)(player->mapX) ),( (Float)(player->mapY) ),1);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,useVial,(void))

void Global_obj::parseCharList( ::Xml xml){
            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_187_parseCharList)
HXLINE( 188)		{
HXLINE( 188)			 ::Dynamic iterXML = ( ( ::Xml)(xml->elementsNamed(HX_("ItemCosts",53,0b,20,ec))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->elementsNamed(HX_("ItemCost",20,f1,72,78));
HXDLIN( 188)			while(( (bool)(iterXML->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 188)				 ::Xml iterXML1 = ( ( ::Xml)(iterXML->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 189)				 ::classes::model::ClassModel skin = ::Global_obj::classModel;
HXDLIN( 189)				int skin1;
HXDLIN( 189)				if (::hx::IsNotNull( iterXML1->get(HX_("type",ba,f2,08,4d)) )) {
HXLINE( 189)					skin1 = ( (int)(::Std_obj::parseInt(iterXML1->get(HX_("type",ba,f2,08,4d)))) );
            				}
            				else {
HXLINE( 189)					skin1 = 0;
            				}
HXDLIN( 189)				 ::classes::model::CharacterSkin skin2 = skin->getCharacterSkin(skin1);
HXLINE( 190)				if (::hx::IsNotNull( skin2 )) {
HXLINE( 191)					int _hx_tmp;
HXDLIN( 191)					if (::hx::IsNotNull( iterXML1 )) {
HXLINE( 191)						bool _hx_tmp1;
HXDLIN( 191)						if ((iterXML1->nodeType != ::Xml_obj::Document)) {
HXLINE( 191)							_hx_tmp1 = (iterXML1->nodeType != ::Xml_obj::Element);
            						}
            						else {
HXLINE( 191)							_hx_tmp1 = false;
            						}
HXDLIN( 191)						if (_hx_tmp1) {
HXLINE( 191)							HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(iterXML1->nodeType)));
            						}
HXDLIN( 191)						 ::Xml _this = iterXML1->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 191)						bool _hx_tmp2;
HXDLIN( 191)						if ((_this->nodeType != ::Xml_obj::Document)) {
HXLINE( 191)							_hx_tmp2 = (_this->nodeType == ::Xml_obj::Element);
            						}
            						else {
HXLINE( 191)							_hx_tmp2 = true;
            						}
HXDLIN( 191)						if (_hx_tmp2) {
HXLINE( 191)							HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this->nodeType)));
            						}
HXDLIN( 191)						_hx_tmp = ( (int)(::Std_obj::parseInt(_this->nodeValue)) );
            					}
            					else {
HXLINE( 191)						_hx_tmp = 0;
            					}
HXDLIN( 191)					skin2->cost = _hx_tmp;
            				}
            			}
            		}
HXLINE( 194)		 ::Xml xml1 = ( ( ::Xml)(xml->elementsNamed(HX_("Account",8d,24,ab,6e))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 194)		::String _hx_tmp3;
HXDLIN( 194)		if (( (bool)(xml1->elementsNamed(HX_("Name",6b,9e,d8,33))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 194)			 ::Xml _this1 = ( ( ::Xml)(xml1->elementsNamed(HX_("Name",6b,9e,d8,33))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 194)			bool _hx_tmp4;
HXDLIN( 194)			if ((_this1->nodeType != ::Xml_obj::Document)) {
HXLINE( 194)				_hx_tmp4 = (_this1->nodeType != ::Xml_obj::Element);
            			}
            			else {
HXLINE( 194)				_hx_tmp4 = false;
            			}
HXDLIN( 194)			if (_hx_tmp4) {
HXLINE( 194)				HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this1->nodeType)));
            			}
HXDLIN( 194)			 ::Xml _this2 = _this1->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 194)			bool _hx_tmp5;
HXDLIN( 194)			if ((_this2->nodeType != ::Xml_obj::Document)) {
HXLINE( 194)				_hx_tmp5 = (_this2->nodeType == ::Xml_obj::Element);
            			}
            			else {
HXLINE( 194)				_hx_tmp5 = true;
            			}
HXDLIN( 194)			if (_hx_tmp5) {
HXLINE( 194)				HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this2->nodeType)));
            			}
HXDLIN( 194)			_hx_tmp3 = _this2->nodeValue;
            		}
            		else {
HXLINE( 194)			_hx_tmp3 = HX_("",00,00,00,00);
            		}
HXDLIN( 194)		::account::Account_obj::updateUser(_hx_tmp3,::account::Account_obj::email,::account::Account_obj::password);
HXLINE( 196)		{
HXLINE( 196)			int _g = 0;
HXDLIN( 196)			::Array< int > _g1;
HXDLIN( 196)			if (( (bool)(xml->elementsNamed(HX_("OwnedSkins",11,cd,d3,6d))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 196)				 ::Xml _this3 = ( ( ::Xml)(xml->elementsNamed(HX_("OwnedSkins",11,cd,d3,6d))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 196)				bool _this4;
HXDLIN( 196)				if ((_this3->nodeType != ::Xml_obj::Document)) {
HXLINE( 196)					_this4 = (_this3->nodeType != ::Xml_obj::Element);
            				}
            				else {
HXLINE( 196)					_this4 = false;
            				}
HXDLIN( 196)				if (_this4) {
HXLINE( 196)					HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this3->nodeType)));
            				}
HXDLIN( 196)				 ::Xml _this5 = _this3->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 196)				bool _this6;
HXDLIN( 196)				if ((_this5->nodeType != ::Xml_obj::Document)) {
HXLINE( 196)					_this6 = (_this5->nodeType == ::Xml_obj::Element);
            				}
            				else {
HXLINE( 196)					_this6 = true;
            				}
HXDLIN( 196)				if (_this6) {
HXLINE( 196)					HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this5->nodeType)));
            				}
HXDLIN( 196)				::Array< ::String > _this7 = _this5->nodeValue.split(HX_(",",2c,00,00,00));
HXDLIN( 196)				::Array< int > result = ::Array_obj< int >::__new(_this7->length);
HXDLIN( 196)				{
HXLINE( 196)					int _g2 = 0;
HXDLIN( 196)					int _g3 = _this7->length;
HXDLIN( 196)					while((_g2 < _g3)){
HXLINE( 196)						_g2 = (_g2 + 1);
HXDLIN( 196)						int i = (_g2 - 1);
HXDLIN( 196)						{
HXLINE( 196)							int inValue = ::hx::TCast< int >::cast(::Std_obj::parseInt(( (::String)(_hx_array_unsafe_get(_this7,i)) )));
HXDLIN( 196)							result->__unsafe_set(i,inValue);
            						}
            					}
            				}
HXDLIN( 196)				_g1 = result;
            			}
            			else {
HXLINE( 196)				_g1 = ::Array_obj< int >::__new();
            			}
HXDLIN( 196)			while((_g < _g1->length)){
HXLINE( 196)				int owned = _g1->__get(_g);
HXDLIN( 196)				_g = (_g + 1);
HXLINE( 197)				{
HXLINE( 197)					 ::classes::model::CharacterSkin tmp = ::Global_obj::classModel->getCharacterSkin(owned);
HXDLIN( 197)					if (::hx::IsNotNull( tmp )) {
HXLINE( 197)						tmp->setState(::classes::model::CharacterSkinState_obj::OWNED);
            					}
            				}
            			}
            		}
HXLINE( 199)		 ::core::PlayerModel _hx_tmp6 = ::Global_obj::playerModel;
HXDLIN( 199)		_hx_tmp6->setCharacterList( ::appengine::SavedCharactersList_obj::__alloc( HX_CTX ,xml));
HXLINE( 200)		::Global_obj::playerModel->isInvalidated = false;
HXLINE( 202)		::Array< ::Dynamic> list = ::Array_obj< ::Dynamic>::__new();
HXLINE( 203)		{
HXLINE( 203)			 ::Dynamic iterXML2 = ( ( ::Xml)(xml->elementsNamed(HX_("Servers",30,48,7b,cf))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) )->elementsNamed(HX_("Server",e3,be,cb,a2));
HXDLIN( 203)			while(( (bool)(iterXML2->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 203)				 ::Xml iterXML3 = ( ( ::Xml)(iterXML2->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 204)				 ::servers::Server _hx_tmp7 =  ::servers::Server_obj::__alloc( HX_CTX );
HXDLIN( 204)				::String _hx_tmp8;
HXDLIN( 204)				if (( (bool)(iterXML3->elementsNamed(HX_("Name",6b,9e,d8,33))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 204)					 ::Xml _this8 = ( ( ::Xml)(iterXML3->elementsNamed(HX_("Name",6b,9e,d8,33))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 204)					bool _hx_tmp9;
HXDLIN( 204)					if ((_this8->nodeType != ::Xml_obj::Document)) {
HXLINE( 204)						_hx_tmp9 = (_this8->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 204)						_hx_tmp9 = false;
            					}
HXDLIN( 204)					if (_hx_tmp9) {
HXLINE( 204)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this8->nodeType)));
            					}
HXDLIN( 204)					 ::Xml _this9 = _this8->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 204)					bool _hx_tmp10;
HXDLIN( 204)					if ((_this9->nodeType != ::Xml_obj::Document)) {
HXLINE( 204)						_hx_tmp10 = (_this9->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 204)						_hx_tmp10 = true;
            					}
HXDLIN( 204)					if (_hx_tmp10) {
HXLINE( 204)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this9->nodeType)));
            					}
HXDLIN( 204)					_hx_tmp8 = _this9->nodeValue;
            				}
            				else {
HXLINE( 204)					_hx_tmp8 = HX_("",00,00,00,00);
            				}
HXDLIN( 204)				 ::servers::Server _hx_tmp11 = _hx_tmp7->setName(_hx_tmp8);
HXLINE( 205)				::String _hx_tmp12;
HXDLIN( 205)				if (( (bool)(iterXML3->elementsNamed(HX_("DNS",89,dd,33,00))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 205)					 ::Xml _this10 = ( ( ::Xml)(iterXML3->elementsNamed(HX_("DNS",89,dd,33,00))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 205)					bool _hx_tmp13;
HXDLIN( 205)					if ((_this10->nodeType != ::Xml_obj::Document)) {
HXLINE( 205)						_hx_tmp13 = (_this10->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 205)						_hx_tmp13 = false;
            					}
HXDLIN( 205)					if (_hx_tmp13) {
HXLINE( 205)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this10->nodeType)));
            					}
HXDLIN( 205)					 ::Xml _this11 = _this10->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 205)					bool _hx_tmp14;
HXDLIN( 205)					if ((_this11->nodeType != ::Xml_obj::Document)) {
HXLINE( 205)						_hx_tmp14 = (_this11->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 205)						_hx_tmp14 = true;
            					}
HXDLIN( 205)					if (_hx_tmp14) {
HXLINE( 205)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this11->nodeType)));
            					}
HXDLIN( 205)					_hx_tmp12 = _this11->nodeValue;
            				}
            				else {
HXLINE( 205)					_hx_tmp12 = HX_("",00,00,00,00);
            				}
HXLINE( 204)				 ::servers::Server _hx_tmp15 = _hx_tmp11->setAddress(_hx_tmp12)->setPort(2050);
HXLINE( 207)				float _hx_tmp16;
HXDLIN( 207)				if (( (bool)(iterXML3->elementsNamed(HX_("Lat",3f,00,3a,00))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 207)					 ::Xml _this12 = ( ( ::Xml)(iterXML3->elementsNamed(HX_("Lat",3f,00,3a,00))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 207)					bool _hx_tmp17;
HXDLIN( 207)					if ((_this12->nodeType != ::Xml_obj::Document)) {
HXLINE( 207)						_hx_tmp17 = (_this12->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 207)						_hx_tmp17 = false;
            					}
HXDLIN( 207)					if (_hx_tmp17) {
HXLINE( 207)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this12->nodeType)));
            					}
HXDLIN( 207)					 ::Xml _this13 = _this12->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 207)					bool _hx_tmp18;
HXDLIN( 207)					if ((_this13->nodeType != ::Xml_obj::Document)) {
HXLINE( 207)						_hx_tmp18 = (_this13->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 207)						_hx_tmp18 = true;
            					}
HXDLIN( 207)					if (_hx_tmp18) {
HXLINE( 207)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this13->nodeType)));
            					}
HXDLIN( 207)					_hx_tmp16 = ( (float)(::Std_obj::parseFloat(_this13->nodeValue)) );
            				}
            				else {
HXLINE( 207)					_hx_tmp16 = ( (float)(0) );
            				}
HXDLIN( 207)				float _hx_tmp19;
HXDLIN( 207)				if (( (bool)(iterXML3->elementsNamed(HX_("Long",9c,d1,90,32))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 207)					 ::Xml _this14 = ( ( ::Xml)(iterXML3->elementsNamed(HX_("Long",9c,d1,90,32))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 207)					bool _hx_tmp20;
HXDLIN( 207)					if ((_this14->nodeType != ::Xml_obj::Document)) {
HXLINE( 207)						_hx_tmp20 = (_this14->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 207)						_hx_tmp20 = false;
            					}
HXDLIN( 207)					if (_hx_tmp20) {
HXLINE( 207)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this14->nodeType)));
            					}
HXDLIN( 207)					 ::Xml _this15 = _this14->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 207)					bool _hx_tmp21;
HXDLIN( 207)					if ((_this15->nodeType != ::Xml_obj::Document)) {
HXLINE( 207)						_hx_tmp21 = (_this15->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 207)						_hx_tmp21 = true;
            					}
HXDLIN( 207)					if (_hx_tmp21) {
HXLINE( 207)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this15->nodeType)));
            					}
HXDLIN( 207)					_hx_tmp19 = ( (float)(::Std_obj::parseFloat(_this15->nodeValue)) );
            				}
            				else {
HXLINE( 207)					_hx_tmp19 = ( (float)(0) );
            				}
HXLINE( 204)				 ::servers::Server _hx_tmp22 = _hx_tmp15->setLatLong(( (Float)(_hx_tmp16) ),( (Float)(_hx_tmp19) ));
HXLINE( 208)				float _hx_tmp23;
HXDLIN( 208)				if (( (bool)(iterXML3->elementsNamed(HX_("Usage",01,cd,5c,3d))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )) {
HXLINE( 208)					 ::Xml _this16 = ( ( ::Xml)(iterXML3->elementsNamed(HX_("Usage",01,cd,5c,3d))->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 208)					bool _hx_tmp24;
HXDLIN( 208)					if ((_this16->nodeType != ::Xml_obj::Document)) {
HXLINE( 208)						_hx_tmp24 = (_this16->nodeType != ::Xml_obj::Element);
            					}
            					else {
HXLINE( 208)						_hx_tmp24 = false;
            					}
HXDLIN( 208)					if (_hx_tmp24) {
HXLINE( 208)						HX_STACK_DO_THROW((HX_("Bad node type, expected Element or Document but found ",a0,d6,ba,79) + ::_Xml::XmlType_Impl__obj::toString(_this16->nodeType)));
            					}
HXDLIN( 208)					 ::Xml _this17 = _this16->children->__get(0).StaticCast<  ::Xml >();
HXDLIN( 208)					bool _hx_tmp25;
HXDLIN( 208)					if ((_this17->nodeType != ::Xml_obj::Document)) {
HXLINE( 208)						_hx_tmp25 = (_this17->nodeType == ::Xml_obj::Element);
            					}
            					else {
HXLINE( 208)						_hx_tmp25 = true;
            					}
HXDLIN( 208)					if (_hx_tmp25) {
HXLINE( 208)						HX_STACK_DO_THROW((HX_("Bad node type, unexpected ",be,79,d5,11) + ::_Xml::XmlType_Impl__obj::toString(_this17->nodeType)));
            					}
HXDLIN( 208)					_hx_tmp23 = ( (float)(::Std_obj::parseFloat(_this17->nodeValue)) );
            				}
            				else {
HXLINE( 208)					_hx_tmp23 = ( (float)(0) );
            				}
HXLINE( 204)				 ::servers::Server _hx_tmp26 = _hx_tmp22->setUsage(( (Float)(_hx_tmp23) ));
HXDLIN( 204)				list->push(_hx_tmp26->setIsAdminOnly(( (bool)(iterXML3->elementsNamed(HX_("AdminOnly",7b,31,bc,21))->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )));
            			}
            		}
HXLINE( 211)		::Global_obj::serverModel->setServers(list);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,parseCharList,(void))

void Global_obj::deleteChar(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		void _hx_run( ::lib::tasks::TaskData taskData){
            			HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_217_deleteChar)
HXLINE( 217)			if (taskData->success) {
HXLINE( 218)				 ::core::ScreensView _hx_tmp = ::Global_obj::layers->screens;
HXDLIN( 218)				_hx_tmp->setScreen( ::screens::CharacterSelectionScreen_obj::__alloc( HX_CTX ));
HXLINE( 219)				::Global_obj::layers->dialogs->closeDialogs();
            			}
            			else {
HXLINE( 221)				 ::ui::dialogs::DialogsView _hx_tmp1 = ::Global_obj::layers->dialogs;
HXDLIN( 221)				_hx_tmp1->openDialog( ::ui::dialogs::Dialog_obj::__alloc( HX_CTX ,HX_("",00,00,00,00),HX_("Unable to delete character",ac,f3,b7,b3),null(),null()));
            			}
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_214_deleteChar)
HXLINE( 215)		 ::ui::dialogs::DialogsView _hx_tmp = ::Global_obj::layers->dialogs;
HXDLIN( 215)		_hx_tmp->openDialog( ::characters::DeletingCharacterView_obj::__alloc( HX_CTX ));
HXLINE( 216)		::Global_obj::deleteCharacterTask->finished->once( ::Dynamic(new _hx_Closure_0()));
HXLINE( 223)		::Global_obj::deleteCharacterTask->start();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Global_obj,deleteChar,(void))

void Global_obj::buyCharSlot(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		void _hx_run( ::lib::tasks::TaskData taskData){
            			HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_235_buyCharSlot)
HXLINE( 236)			if (taskData->success) {
HXLINE( 237)				 ::core::ScreensView _hx_tmp = ::Global_obj::layers->screens;
HXDLIN( 237)				_hx_tmp->setScreen( ::screens::CharacterSelectionScreen_obj::__alloc( HX_CTX ));
            			}
            			else {
HXLINE( 239)				 ::ui::dialogs::DialogsView _hx_tmp1 = ::Global_obj::layers->dialogs;
HXDLIN( 239)				_hx_tmp1->openDialog( ::ui::dialogs::ErrorDialog_obj::__alloc( HX_CTX ,HX_("Unable to complete character slot purchase",3d,73,72,dc)));
            			}
HXLINE( 240)			::Global_obj::layers->dialogs->closeDialogs();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_226_buyCharSlot)
HXLINE( 227)		int _hx_tmp = ::Global_obj::playerModel->getGems();
HXDLIN( 227)		if ((_hx_tmp < ::Global_obj::playerModel->getNextCharSlotPrice())) {
HXLINE( 228)			 ::ui::dialogs::DialogsView _hx_tmp1 = ::Global_obj::layers->dialogs;
HXDLIN( 228)			::String _hx_tmp2;
HXDLIN( 228)			if (::Global_obj::playerModel->isNextCharSlotCurrencyGems()) {
HXLINE( 228)				_hx_tmp2 = HX_("Gems",24,29,3b,2f);
            			}
            			else {
HXLINE( 228)				_hx_tmp2 = HX_("Gold",c0,be,42,2f);
            			}
HXDLIN( 228)			_hx_tmp1->openDialog( ::ui::dialogs::Dialog_obj::__alloc( HX_CTX ,(HX_("Not Enough ",23,10,6a,c7) + _hx_tmp2),HX_("Insufficient funds when trying to buy a slot.",f4,91,24,21),HX_("Close",98,87,90,db),null()));
HXLINE( 230)			return;
            		}
HXLINE( 233)		 ::ui::dialogs::DialogsView _hx_tmp3 = ::Global_obj::layers->dialogs;
HXDLIN( 233)		_hx_tmp3->openDialog( ::account::view::BuyingDialog_obj::__alloc( HX_CTX ));
HXLINE( 235)		::Global_obj::buyCharacterSlotTask->finished->once( ::Dynamic(new _hx_Closure_0()));
HXLINE( 242)		::Global_obj::buyCharacterSlotTask->start();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Global_obj,buyCharSlot,(void))

void Global_obj::invalidate(){
            	HX_STACKFRAME(&_hx_pos_babd1827f55eb107_246_invalidate)
HXDLIN( 246)		::Global_obj::playerModel->isInvalidated = true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Global_obj,invalidate,(void))

void Global_obj::setScreenValid( ::openfl::display::Sprite sprite){
            	HX_GC_STACKFRAME(&_hx_pos_babd1827f55eb107_249_setScreenValid)
HXLINE( 250)		if (::Global_obj::playerModel->isInvalidated) {
HXLINE( 251)			 ::core::ScreensView _hx_tmp = ::Global_obj::layers->screens;
HXDLIN( 251)			_hx_tmp->setScreen( ::screens::LoadingScreen_obj::__alloc( HX_CTX ));
HXLINE( 252)			::Global_obj::charListTask->start();
            		}
HXLINE( 255)		::Global_obj::layers->screens->setScreen(sprite);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Global_obj,setScreenValid,(void))


Global_obj::Global_obj()
{
}

bool Global_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"layers") ) { outValue = ( layers ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"useVial") ) { outValue = useVial_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"projPool") ) { outValue = ( projPool ); return true; }
		if (HX_FIELD_EQ(inName,"loadTask") ) { outValue = ( loadTask ); return true; }
		if (HX_FIELD_EQ(inName,"playGame") ) { outValue = playGame_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"charModel") ) { outValue = ( charModel ); return true; }
		if (HX_FIELD_EQ(inName,"loginTask") ) { outValue = ( loginTask ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"gameSprite") ) { outValue = ( gameSprite ); return true; }
		if (HX_FIELD_EQ(inName,"classModel") ) { outValue = ( classModel ); return true; }
		if (HX_FIELD_EQ(inName,"deleteChar") ) { outValue = deleteChar_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"invalidate") ) { outValue = invalidate_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"serverModel") ) { outValue = ( serverModel ); return true; }
		if (HX_FIELD_EQ(inName,"playerModel") ) { outValue = ( playerModel ); return true; }
		if (HX_FIELD_EQ(inName,"buySkinTask") ) { outValue = ( buySkinTask ); return true; }
		if (HX_FIELD_EQ(inName,"buyCharSlot") ) { outValue = buyCharSlot_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"charListTask") ) { outValue = ( charListTask ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentEditor") ) { outValue = ( currentEditor ); return true; }
		if (HX_FIELD_EQ(inName,"tabStripModel") ) { outValue = ( tabStripModel ); return true; }
		if (HX_FIELD_EQ(inName,"uploadXmlTask") ) { outValue = ( uploadXmlTask ); return true; }
		if (HX_FIELD_EQ(inName,"updateAccount") ) { outValue = ( updateAccount ); return true; }
		if (HX_FIELD_EQ(inName,"focusCharSkin") ) { outValue = ( focusCharSkin ); return true; }
		if (HX_FIELD_EQ(inName,"parseCharList") ) { outValue = parseCharList_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setScreenValid") ) { outValue = setScreenValid_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"makeDefaultSkin") ) { outValue = makeDefaultSkin_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"changePasswordTask") ) { outValue = ( changePasswordTask ); return true; }
		if (HX_FIELD_EQ(inName,"uploadBehaviorTask") ) { outValue = ( uploadBehaviorTask ); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"deleteCharacterTask") ) { outValue = ( deleteCharacterTask ); return true; }
		if (HX_FIELD_EQ(inName,"registerAccountTask") ) { outValue = ( registerAccountTask ); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"buyCharacterSlotTask") ) { outValue = ( buyCharacterSlotTask ); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"currentInteractiveTarget") ) { outValue = ( currentInteractiveTarget ); return true; }
		if (HX_FIELD_EQ(inName,"sendPasswordReminderTask") ) { outValue = ( sendPasswordReminderTask ); return true; }
	}
	return false;
}

bool Global_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"layers") ) { layers=ioValue.Cast<  ::core::Layers >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"projPool") ) { projPool=ioValue.Cast<  ::lime::utils::ObjectPool_objects_Projectile >(); return true; }
		if (HX_FIELD_EQ(inName,"loadTask") ) { loadTask=ioValue.Cast<  ::account::services::LoadAccountTask >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"charModel") ) { charModel=ioValue.Cast<  ::characters::CharacterModel >(); return true; }
		if (HX_FIELD_EQ(inName,"loginTask") ) { loginTask=ioValue.Cast<  ::account::services::LoginTask >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"gameSprite") ) { gameSprite=ioValue.Cast<  ::game::GameSprite >(); return true; }
		if (HX_FIELD_EQ(inName,"classModel") ) { classModel=ioValue.Cast<  ::classes::model::ClassModel >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"serverModel") ) { serverModel=ioValue.Cast<  ::servers::ServerModel >(); return true; }
		if (HX_FIELD_EQ(inName,"playerModel") ) { playerModel=ioValue.Cast<  ::core::PlayerModel >(); return true; }
		if (HX_FIELD_EQ(inName,"buySkinTask") ) { buySkinTask=ioValue.Cast<  ::account::services::BuySkinTask >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"charListTask") ) { charListTask=ioValue.Cast<  ::account::services::GetCharListTask >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentEditor") ) { currentEditor=ioValue.Cast<  ::mapeditor::MapEditor >(); return true; }
		if (HX_FIELD_EQ(inName,"tabStripModel") ) { tabStripModel=ioValue.Cast<  ::ui::model::TabStripModel >(); return true; }
		if (HX_FIELD_EQ(inName,"uploadXmlTask") ) { uploadXmlTask=ioValue.Cast<  ::account::services::UploadXmlTask >(); return true; }
		if (HX_FIELD_EQ(inName,"updateAccount") ) { updateAccount=ioValue.Cast<  ::util::EmptySignal >(); return true; }
		if (HX_FIELD_EQ(inName,"focusCharSkin") ) { focusCharSkin=ioValue.Cast<  ::util::Signal >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"changePasswordTask") ) { changePasswordTask=ioValue.Cast<  ::account::services::ChangePasswordTask >(); return true; }
		if (HX_FIELD_EQ(inName,"uploadBehaviorTask") ) { uploadBehaviorTask=ioValue.Cast<  ::account::services::UploadBehaviorTask >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"deleteCharacterTask") ) { deleteCharacterTask=ioValue.Cast<  ::account::services::DeleteCharacterTask >(); return true; }
		if (HX_FIELD_EQ(inName,"registerAccountTask") ) { registerAccountTask=ioValue.Cast<  ::account::services::RegisterAccountTask >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"buyCharacterSlotTask") ) { buyCharacterSlotTask=ioValue.Cast<  ::account::services::BuyCharacterSlotTask >(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"currentInteractiveTarget") ) { currentInteractiveTarget=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"sendPasswordReminderTask") ) { sendPasswordReminderTask=ioValue.Cast<  ::account::services::SendPasswordReminderTask >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Global_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Global_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Global_obj::currentInteractiveTarget,HX_("currentInteractiveTarget",5a,0e,ec,d7)},
	{::hx::fsObject /*  ::game::GameSprite */ ,(void *) &Global_obj::gameSprite,HX_("gameSprite",97,c5,0b,06)},
	{::hx::fsObject /*  ::core::Layers */ ,(void *) &Global_obj::layers,HX_("layers",82,15,b1,58)},
	{::hx::fsObject /*  ::mapeditor::MapEditor */ ,(void *) &Global_obj::currentEditor,HX_("currentEditor",c6,c2,39,1f)},
	{::hx::fsObject /*  ::lime::utils::ObjectPool_objects_Projectile */ ,(void *) &Global_obj::projPool,HX_("projPool",19,07,ed,29)},
	{::hx::fsObject /*  ::servers::ServerModel */ ,(void *) &Global_obj::serverModel,HX_("serverModel",e6,65,39,aa)},
	{::hx::fsObject /*  ::classes::model::ClassModel */ ,(void *) &Global_obj::classModel,HX_("classModel",51,50,76,4f)},
	{::hx::fsObject /*  ::core::PlayerModel */ ,(void *) &Global_obj::playerModel,HX_("playerModel",88,c8,36,13)},
	{::hx::fsObject /*  ::characters::CharacterModel */ ,(void *) &Global_obj::charModel,HX_("charModel",f3,ac,b0,c5)},
	{::hx::fsObject /*  ::ui::model::TabStripModel */ ,(void *) &Global_obj::tabStripModel,HX_("tabStripModel",66,6c,b1,b5)},
	{::hx::fsObject /*  ::account::services::LoadAccountTask */ ,(void *) &Global_obj::loadTask,HX_("loadTask",8b,90,96,bd)},
	{::hx::fsObject /*  ::account::services::LoginTask */ ,(void *) &Global_obj::loginTask,HX_("loginTask",4e,2d,37,0f)},
	{::hx::fsObject /*  ::account::services::GetCharListTask */ ,(void *) &Global_obj::charListTask,HX_("charListTask",b9,6f,b8,99)},
	{::hx::fsObject /*  ::account::services::DeleteCharacterTask */ ,(void *) &Global_obj::deleteCharacterTask,HX_("deleteCharacterTask",63,e0,9f,ed)},
	{::hx::fsObject /*  ::account::services::BuyCharacterSlotTask */ ,(void *) &Global_obj::buyCharacterSlotTask,HX_("buyCharacterSlotTask",06,77,97,0f)},
	{::hx::fsObject /*  ::account::services::RegisterAccountTask */ ,(void *) &Global_obj::registerAccountTask,HX_("registerAccountTask",ef,58,3a,48)},
	{::hx::fsObject /*  ::account::services::ChangePasswordTask */ ,(void *) &Global_obj::changePasswordTask,HX_("changePasswordTask",90,7d,90,28)},
	{::hx::fsObject /*  ::account::services::SendPasswordReminderTask */ ,(void *) &Global_obj::sendPasswordReminderTask,HX_("sendPasswordReminderTask",fa,a0,0e,30)},
	{::hx::fsObject /*  ::account::services::BuySkinTask */ ,(void *) &Global_obj::buySkinTask,HX_("buySkinTask",c8,b9,78,61)},
	{::hx::fsObject /*  ::account::services::UploadBehaviorTask */ ,(void *) &Global_obj::uploadBehaviorTask,HX_("uploadBehaviorTask",98,c0,1e,d6)},
	{::hx::fsObject /*  ::account::services::UploadXmlTask */ ,(void *) &Global_obj::uploadXmlTask,HX_("uploadXmlTask",bb,a0,63,ef)},
	{::hx::fsObject /*  ::util::EmptySignal */ ,(void *) &Global_obj::updateAccount,HX_("updateAccount",a4,61,c8,6c)},
	{::hx::fsObject /*  ::util::Signal */ ,(void *) &Global_obj::focusCharSkin,HX_("focusCharSkin",6b,78,97,47)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Global_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Global_obj::currentInteractiveTarget,"currentInteractiveTarget");
	HX_MARK_MEMBER_NAME(Global_obj::gameSprite,"gameSprite");
	HX_MARK_MEMBER_NAME(Global_obj::layers,"layers");
	HX_MARK_MEMBER_NAME(Global_obj::currentEditor,"currentEditor");
	HX_MARK_MEMBER_NAME(Global_obj::projPool,"projPool");
	HX_MARK_MEMBER_NAME(Global_obj::serverModel,"serverModel");
	HX_MARK_MEMBER_NAME(Global_obj::classModel,"classModel");
	HX_MARK_MEMBER_NAME(Global_obj::playerModel,"playerModel");
	HX_MARK_MEMBER_NAME(Global_obj::charModel,"charModel");
	HX_MARK_MEMBER_NAME(Global_obj::tabStripModel,"tabStripModel");
	HX_MARK_MEMBER_NAME(Global_obj::loadTask,"loadTask");
	HX_MARK_MEMBER_NAME(Global_obj::loginTask,"loginTask");
	HX_MARK_MEMBER_NAME(Global_obj::charListTask,"charListTask");
	HX_MARK_MEMBER_NAME(Global_obj::deleteCharacterTask,"deleteCharacterTask");
	HX_MARK_MEMBER_NAME(Global_obj::buyCharacterSlotTask,"buyCharacterSlotTask");
	HX_MARK_MEMBER_NAME(Global_obj::registerAccountTask,"registerAccountTask");
	HX_MARK_MEMBER_NAME(Global_obj::changePasswordTask,"changePasswordTask");
	HX_MARK_MEMBER_NAME(Global_obj::sendPasswordReminderTask,"sendPasswordReminderTask");
	HX_MARK_MEMBER_NAME(Global_obj::buySkinTask,"buySkinTask");
	HX_MARK_MEMBER_NAME(Global_obj::uploadBehaviorTask,"uploadBehaviorTask");
	HX_MARK_MEMBER_NAME(Global_obj::uploadXmlTask,"uploadXmlTask");
	HX_MARK_MEMBER_NAME(Global_obj::updateAccount,"updateAccount");
	HX_MARK_MEMBER_NAME(Global_obj::focusCharSkin,"focusCharSkin");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Global_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Global_obj::currentInteractiveTarget,"currentInteractiveTarget");
	HX_VISIT_MEMBER_NAME(Global_obj::gameSprite,"gameSprite");
	HX_VISIT_MEMBER_NAME(Global_obj::layers,"layers");
	HX_VISIT_MEMBER_NAME(Global_obj::currentEditor,"currentEditor");
	HX_VISIT_MEMBER_NAME(Global_obj::projPool,"projPool");
	HX_VISIT_MEMBER_NAME(Global_obj::serverModel,"serverModel");
	HX_VISIT_MEMBER_NAME(Global_obj::classModel,"classModel");
	HX_VISIT_MEMBER_NAME(Global_obj::playerModel,"playerModel");
	HX_VISIT_MEMBER_NAME(Global_obj::charModel,"charModel");
	HX_VISIT_MEMBER_NAME(Global_obj::tabStripModel,"tabStripModel");
	HX_VISIT_MEMBER_NAME(Global_obj::loadTask,"loadTask");
	HX_VISIT_MEMBER_NAME(Global_obj::loginTask,"loginTask");
	HX_VISIT_MEMBER_NAME(Global_obj::charListTask,"charListTask");
	HX_VISIT_MEMBER_NAME(Global_obj::deleteCharacterTask,"deleteCharacterTask");
	HX_VISIT_MEMBER_NAME(Global_obj::buyCharacterSlotTask,"buyCharacterSlotTask");
	HX_VISIT_MEMBER_NAME(Global_obj::registerAccountTask,"registerAccountTask");
	HX_VISIT_MEMBER_NAME(Global_obj::changePasswordTask,"changePasswordTask");
	HX_VISIT_MEMBER_NAME(Global_obj::sendPasswordReminderTask,"sendPasswordReminderTask");
	HX_VISIT_MEMBER_NAME(Global_obj::buySkinTask,"buySkinTask");
	HX_VISIT_MEMBER_NAME(Global_obj::uploadBehaviorTask,"uploadBehaviorTask");
	HX_VISIT_MEMBER_NAME(Global_obj::uploadXmlTask,"uploadXmlTask");
	HX_VISIT_MEMBER_NAME(Global_obj::updateAccount,"updateAccount");
	HX_VISIT_MEMBER_NAME(Global_obj::focusCharSkin,"focusCharSkin");
};

#endif

::hx::Class Global_obj::__mClass;

static ::String Global_obj_sStaticFields[] = {
	HX_("currentInteractiveTarget",5a,0e,ec,d7),
	HX_("gameSprite",97,c5,0b,06),
	HX_("layers",82,15,b1,58),
	HX_("currentEditor",c6,c2,39,1f),
	HX_("projPool",19,07,ed,29),
	HX_("serverModel",e6,65,39,aa),
	HX_("classModel",51,50,76,4f),
	HX_("playerModel",88,c8,36,13),
	HX_("charModel",f3,ac,b0,c5),
	HX_("tabStripModel",66,6c,b1,b5),
	HX_("loadTask",8b,90,96,bd),
	HX_("loginTask",4e,2d,37,0f),
	HX_("charListTask",b9,6f,b8,99),
	HX_("deleteCharacterTask",63,e0,9f,ed),
	HX_("buyCharacterSlotTask",06,77,97,0f),
	HX_("registerAccountTask",ef,58,3a,48),
	HX_("changePasswordTask",90,7d,90,28),
	HX_("sendPasswordReminderTask",fa,a0,0e,30),
	HX_("buySkinTask",c8,b9,78,61),
	HX_("uploadBehaviorTask",98,c0,1e,d6),
	HX_("uploadXmlTask",bb,a0,63,ef),
	HX_("updateAccount",a4,61,c8,6c),
	HX_("focusCharSkin",6b,78,97,47),
	HX_("init",10,3b,bb,45),
	HX_("makeDefaultSkin",90,f8,10,4d),
	HX_("playGame",06,58,72,34),
	HX_("useVial",c5,b6,fa,5c),
	HX_("parseCharList",a7,01,42,e7),
	HX_("deleteChar",a1,3c,0c,95),
	HX_("buyCharSlot",5a,c1,af,6b),
	HX_("invalidate",7b,19,2a,87),
	HX_("setScreenValid",6e,fd,fb,90),
	::String(null())
};

void Global_obj::__register()
{
	Global_obj _hx_dummy;
	Global_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Global",83,a5,46,dc);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Global_obj::__GetStatic;
	__mClass->mSetStaticField = &Global_obj::__SetStatic;
	__mClass->mMarkFunc = Global_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Global_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Global_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Global_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Global_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Global_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Global_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_babd1827f55eb107_53_boot)
HXDLIN(  53)		currentInteractiveTarget = 0;
            	}
}

