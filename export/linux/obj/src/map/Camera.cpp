// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_map_Camera
#include <map/Camera.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_util_MathUtil
#include <util/MathUtil.h>
#endif
#ifndef INCLUDED_util_RenderUtils
#include <util/RenderUtils.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_38_init,"map.Camera","init",0x8ee13c87,"map.Camera.init","map/Camera.hx",38,0x2762b8a6)
static const int _hx_array_data_383bd257_1[] = {
	(int)0,(int)0,(int)0,(int)0,(int)0,(int)0,(int)-1,(int)0,(int)0,(int)0,(int)-1,(int)0,(int)0,(int)0,(int)0,(int)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_48_configureCamera,"map.Camera","configureCamera",0x8b89b914,"map.Camera.configureCamera","map/Camera.hx",48,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_93_update,"map.Camera","update",0xe6c81340,"map.Camera.update","map/Camera.hx",93,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_16_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",16,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_17_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",17,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_20_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",20,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_21_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",21,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_22_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",22,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_23_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",23,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_24_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",24,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_25_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",25,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_26_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",26,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_27_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",27,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_29_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",29,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_31_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",31,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_32_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",32,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_35_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",35,0x2762b8a6)
HX_LOCAL_STACK_FRAME(_hx_pos_ec57ea696cc3d6ae_36_boot,"map.Camera","boot",0x8a4185a9,"map.Camera.boot","map/Camera.hx",36,0x2762b8a6)
namespace map{

void Camera_obj::__construct() { }

Dynamic Camera_obj::__CreateEmpty() { return new Camera_obj; }

void *Camera_obj::_hx_vtable = 0;

Dynamic Camera_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Camera_obj > _hx_result = new Camera_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Camera_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x04efc961;
}

float Camera_obj::mapX;

float Camera_obj::mapY;

float Camera_obj::cos;

float Camera_obj::sin;

float Camera_obj::xScaledCos;

float Camera_obj::yScaledCos;

float Camera_obj::xScaledSin;

float Camera_obj::yScaledSin;

float Camera_obj::csX;

float Camera_obj::csY;

float Camera_obj::angleRad;

 ::openfl::geom::Rectangle Camera_obj::clipRect;

float Camera_obj::maxDist;

float Camera_obj::maxDistSq;

 ::lime::utils::ArrayBufferView Camera_obj::viewMatrix;

bool Camera_obj::isJittering;

float Camera_obj::jitter;

void Camera_obj::init(){
            	HX_GC_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_38_init)
HXLINE(  39)		::map::Camera_obj::clipRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(( (Float)(-(::Main_obj::stageWidth)) ) * ((Float)0.5)),(( (Float)(-(::Main_obj::stageHeight)) ) * ((Float)0.5)),::Main_obj::stageWidth,::Main_obj::stageHeight);
HXLINE(  40)		::cpp::VirtualArray array = ::Array_obj< int >::fromData( _hx_array_data_383bd257_1,16);
HXDLIN(  40)		 ::lime::utils::ArrayBufferView this1;
HXDLIN(  40)		if (::hx::IsNotNull( array )) {
HXLINE(  40)			 ::lime::utils::ArrayBufferView _this =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,0,8);
HXDLIN(  40)			_this->byteOffset = 0;
HXDLIN(  40)			_this->length = array->get_length();
HXDLIN(  40)			_this->byteLength = (_this->length * _this->bytesPerElement);
HXDLIN(  40)			_this->buffer = ::haxe::io::Bytes_obj::alloc(_this->byteLength);
HXDLIN(  40)			_this->copyFromArray(array,null());
HXDLIN(  40)			this1 = _this;
            		}
            		else {
HXLINE(  40)			HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            		}
HXDLIN(  40)		::map::Camera_obj::viewMatrix = this1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Camera_obj,init,(void))

void Camera_obj::configureCamera(float x,float y){
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_48_configureCamera)
HXLINE(  49)		if (::map::Camera_obj::isJittering) {
HXLINE(  50)			float range = ::map::Camera_obj::jitter;
HXDLIN(  50)			x = (x + (((::Math_obj::random() * ( (Float)(range) )) * ( (Float)(2) )) - ( (Float)(range) )));
HXLINE(  51)			float range1 = ::map::Camera_obj::jitter;
HXDLIN(  51)			y = (y + (((::Math_obj::random() * ( (Float)(range1) )) * ( (Float)(2) )) - ( (Float)(range1) )));
            		}
HXLINE(  54)		::map::Camera_obj::mapX = x;
HXLINE(  55)		::map::Camera_obj::mapY = y;
HXLINE(  58)		float cosAngle = ::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round(((::map::Camera_obj::angleRad + ((Float)1.57079632679489656)) * ((Float)10430.3783504704534))) & 65535)];
HXDLIN(  58)		float sinAngle = ::util::MathUtil_obj::SIN_TABLE[(::Math_obj::round((( (Float)(::map::Camera_obj::angleRad) ) * ((Float)10430.3783504704534))) & 65535)];
HXLINE(  60)		::map::Camera_obj::cos = ( (float)((( (Float)(cosAngle) ) * ( (Float)(( (signed char)(88) )) ))) );
HXLINE(  61)		::map::Camera_obj::sin = ( (float)((( (Float)(sinAngle) ) * ( (Float)(( (signed char)(88) )) ))) );
HXLINE(  62)		::map::Camera_obj::xScaledCos = ( (float)((( (Float)((::map::Camera_obj::cos * ::util::RenderUtils_obj::clipSpaceScaleX)) ) * ((Float)0.5))) );
HXLINE(  63)		::map::Camera_obj::yScaledCos = ( (float)((( (Float)((::map::Camera_obj::cos * ::util::RenderUtils_obj::clipSpaceScaleY)) ) * ((Float)0.5))) );
HXLINE(  64)		::map::Camera_obj::xScaledSin = ( (float)((( (Float)((::map::Camera_obj::sin * ::util::RenderUtils_obj::clipSpaceScaleX)) ) * ((Float)0.5))) );
HXLINE(  65)		::map::Camera_obj::yScaledSin = ( (float)((( (Float)((::map::Camera_obj::sin * ::util::RenderUtils_obj::clipSpaceScaleY)) ) * ((Float)0.5))) );
HXLINE(  66)		::map::Camera_obj::csX = ( (float)((( (Float)(((x * cosAngle) + (y * sinAngle))) ) * ( (Float)(-(( (signed char)(88) ))) ))) );
HXLINE(  67)		::map::Camera_obj::csY = ( (float)((( (Float)(((x * -(sinAngle)) + (y * cosAngle))) ) * ( (Float)(-(( (signed char)(88) ))) ))) );
HXLINE(  69)		{
HXLINE(  69)			 ::lime::utils::ArrayBufferView this1 = ::map::Camera_obj::viewMatrix;
HXDLIN(  69)			 ::lime::utils::ArrayBufferView this2 = ::map::Camera_obj::viewMatrix;
HXDLIN(  69)			Float val = ( (Float)(::map::Camera_obj::cos) );
HXDLIN(  69)			 ::__hxcpp_memory_set_float(this2->buffer->b,(this2->byteOffset + 20),val);
HXDLIN(  69)			 ::__hxcpp_memory_set_float(this1->buffer->b,this1->byteOffset,val);
            		}
HXLINE(  70)		{
HXLINE(  70)			 ::lime::utils::ArrayBufferView this3 = ::map::Camera_obj::viewMatrix;
HXDLIN(  70)			 ::__hxcpp_memory_set_float(this3->buffer->b,(this3->byteOffset + 16),( (Float)(-(::map::Camera_obj::sin)) ));
            		}
HXLINE(  71)		{
HXLINE(  71)			 ::lime::utils::ArrayBufferView this4 = ::map::Camera_obj::viewMatrix;
HXDLIN(  71)			 ::__hxcpp_memory_set_float(this4->buffer->b,(this4->byteOffset + 4),( (Float)(::map::Camera_obj::sin) ));
            		}
HXLINE(  72)		{
HXLINE(  72)			 ::lime::utils::ArrayBufferView this5 = ::map::Camera_obj::viewMatrix;
HXDLIN(  72)			 ::__hxcpp_memory_set_float(this5->buffer->b,(this5->byteOffset + 12),( (Float)(::map::Camera_obj::csX) ));
            		}
HXLINE(  73)		{
HXLINE(  73)			 ::lime::utils::ArrayBufferView this6 = ::map::Camera_obj::viewMatrix;
HXDLIN(  73)			 ::__hxcpp_memory_set_float(this6->buffer->b,(this6->byteOffset + 28),( (Float)(::map::Camera_obj::csY) ));
            		}
HXLINE(  75)		::map::Camera_obj::clipRect->x = (( (Float)(-(::Main_obj::stageWidth)) ) * ((Float)0.5));
HXLINE(  76)		::map::Camera_obj::clipRect->y = (( (Float)(-(::Main_obj::stageHeight)) ) * ((Float)0.5));
HXLINE(  77)		::map::Camera_obj::clipRect->width = ( (Float)(::Main_obj::stageWidth) );
HXLINE(  78)		::map::Camera_obj::clipRect->height = ( (Float)(::Main_obj::stageHeight) );
HXLINE(  80)		Float w = (::map::Camera_obj::clipRect->width / ( (Float)((( (signed char)(2) ) * ( (signed char)(88) ))) ));
HXLINE(  81)		Float h = (::map::Camera_obj::clipRect->height / ( (Float)((( (signed char)(2) ) * ( (signed char)(88) ))) ));
HXLINE(  83)		::map::Camera_obj::maxDist = ( (float)((::Math_obj::ceil(::Math_obj::sqrt(((w * w) + (h * h)))) + 1)) );
HXLINE(  84)		::map::Camera_obj::maxDistSq = (::map::Camera_obj::maxDist * ::map::Camera_obj::maxDist);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Camera_obj,configureCamera,(void))

void Camera_obj::update(short dt){
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_93_update)
HXDLIN(  93)		bool _hx_tmp;
HXDLIN(  93)		if (::map::Camera_obj::isJittering) {
HXDLIN(  93)			_hx_tmp = (::map::Camera_obj::jitter < ( (float)(((Float)0.5)) ));
            		}
            		else {
HXDLIN(  93)			_hx_tmp = false;
            		}
HXDLIN(  93)		if (_hx_tmp) {
HXLINE(  94)			::map::Camera_obj::jitter = ( (float)((::map::Camera_obj::jitter + ((( (Float)(dt) ) * ( (Float)(( (float)(((Float)0.5)) )) )) / ( (Float)(( (short)(10000) )) )))) );
HXLINE(  95)			if ((::map::Camera_obj::jitter > ( (float)(((Float)0.5)) ))) {
HXLINE(  96)				::map::Camera_obj::jitter = ( (float)(((Float)0.5)) );
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Camera_obj,update,(void))


Camera_obj::Camera_obj()
{
}

bool Camera_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"cos") ) { outValue = ( cos ); return true; }
		if (HX_FIELD_EQ(inName,"sin") ) { outValue = ( sin ); return true; }
		if (HX_FIELD_EQ(inName,"csX") ) { outValue = ( csX ); return true; }
		if (HX_FIELD_EQ(inName,"csY") ) { outValue = ( csY ); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mapX") ) { outValue = ( mapX ); return true; }
		if (HX_FIELD_EQ(inName,"mapY") ) { outValue = ( mapY ); return true; }
		if (HX_FIELD_EQ(inName,"init") ) { outValue = init_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"jitter") ) { outValue = ( jitter ); return true; }
		if (HX_FIELD_EQ(inName,"update") ) { outValue = update_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"maxDist") ) { outValue = ( maxDist ); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"angleRad") ) { outValue = ( angleRad ); return true; }
		if (HX_FIELD_EQ(inName,"clipRect") ) { outValue = ( clipRect ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"maxDistSq") ) { outValue = ( maxDistSq ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"xScaledCos") ) { outValue = ( xScaledCos ); return true; }
		if (HX_FIELD_EQ(inName,"yScaledCos") ) { outValue = ( yScaledCos ); return true; }
		if (HX_FIELD_EQ(inName,"xScaledSin") ) { outValue = ( xScaledSin ); return true; }
		if (HX_FIELD_EQ(inName,"yScaledSin") ) { outValue = ( yScaledSin ); return true; }
		if (HX_FIELD_EQ(inName,"viewMatrix") ) { outValue = ( viewMatrix ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"isJittering") ) { outValue = ( isJittering ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"configureCamera") ) { outValue = configureCamera_dyn(); return true; }
	}
	return false;
}

bool Camera_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"cos") ) { cos=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"sin") ) { sin=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"csX") ) { csX=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"csY") ) { csY=ioValue.Cast< float >(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mapX") ) { mapX=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"mapY") ) { mapY=ioValue.Cast< float >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"jitter") ) { jitter=ioValue.Cast< float >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"maxDist") ) { maxDist=ioValue.Cast< float >(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"angleRad") ) { angleRad=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"clipRect") ) { clipRect=ioValue.Cast<  ::openfl::geom::Rectangle >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"maxDistSq") ) { maxDistSq=ioValue.Cast< float >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"xScaledCos") ) { xScaledCos=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"yScaledCos") ) { yScaledCos=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"xScaledSin") ) { xScaledSin=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"yScaledSin") ) { yScaledSin=ioValue.Cast< float >(); return true; }
		if (HX_FIELD_EQ(inName,"viewMatrix") ) { viewMatrix=ioValue.Cast<  ::lime::utils::ArrayBufferView >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"isJittering") ) { isJittering=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Camera_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Camera_obj_sStaticStorageInfo[] = {
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::mapX,HX_("mapX",3c,3e,56,48)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::mapY,HX_("mapY",3d,3e,56,48)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::cos,HX_("cos",47,80,4b,00)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::sin,HX_("sin",18,9f,57,00)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::xScaledCos,HX_("xScaledCos",35,7a,a1,ff)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::yScaledCos,HX_("yScaledCos",14,f2,eb,bf)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::xScaledSin,HX_("xScaledSin",06,99,ad,ff)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::yScaledSin,HX_("yScaledSin",e5,10,f8,bf)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::csX,HX_("csX",a8,83,4b,00)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::csY,HX_("csY",a9,83,4b,00)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::angleRad,HX_("angleRad",c2,2f,60,2b)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(void *) &Camera_obj::clipRect,HX_("clipRect",14,90,6a,58)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::maxDist,HX_("maxDist",2a,c0,99,c2)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::maxDistSq,HX_("maxDistSq",68,e7,a9,ec)},
	{::hx::fsObject /*  ::lime::utils::ArrayBufferView */ ,(void *) &Camera_obj::viewMatrix,HX_("viewMatrix",86,36,15,fd)},
	{::hx::fsBool,(void *) &Camera_obj::isJittering,HX_("isJittering",ec,a0,69,58)},
	{::hx::fsUnknown /* float */ ,(void *) &Camera_obj::jitter,HX_("jitter",2c,46,ec,23)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Camera_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Camera_obj::mapX,"mapX");
	HX_MARK_MEMBER_NAME(Camera_obj::mapY,"mapY");
	HX_MARK_MEMBER_NAME(Camera_obj::cos,"cos");
	HX_MARK_MEMBER_NAME(Camera_obj::sin,"sin");
	HX_MARK_MEMBER_NAME(Camera_obj::xScaledCos,"xScaledCos");
	HX_MARK_MEMBER_NAME(Camera_obj::yScaledCos,"yScaledCos");
	HX_MARK_MEMBER_NAME(Camera_obj::xScaledSin,"xScaledSin");
	HX_MARK_MEMBER_NAME(Camera_obj::yScaledSin,"yScaledSin");
	HX_MARK_MEMBER_NAME(Camera_obj::csX,"csX");
	HX_MARK_MEMBER_NAME(Camera_obj::csY,"csY");
	HX_MARK_MEMBER_NAME(Camera_obj::angleRad,"angleRad");
	HX_MARK_MEMBER_NAME(Camera_obj::clipRect,"clipRect");
	HX_MARK_MEMBER_NAME(Camera_obj::maxDist,"maxDist");
	HX_MARK_MEMBER_NAME(Camera_obj::maxDistSq,"maxDistSq");
	HX_MARK_MEMBER_NAME(Camera_obj::viewMatrix,"viewMatrix");
	HX_MARK_MEMBER_NAME(Camera_obj::isJittering,"isJittering");
	HX_MARK_MEMBER_NAME(Camera_obj::jitter,"jitter");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Camera_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Camera_obj::mapX,"mapX");
	HX_VISIT_MEMBER_NAME(Camera_obj::mapY,"mapY");
	HX_VISIT_MEMBER_NAME(Camera_obj::cos,"cos");
	HX_VISIT_MEMBER_NAME(Camera_obj::sin,"sin");
	HX_VISIT_MEMBER_NAME(Camera_obj::xScaledCos,"xScaledCos");
	HX_VISIT_MEMBER_NAME(Camera_obj::yScaledCos,"yScaledCos");
	HX_VISIT_MEMBER_NAME(Camera_obj::xScaledSin,"xScaledSin");
	HX_VISIT_MEMBER_NAME(Camera_obj::yScaledSin,"yScaledSin");
	HX_VISIT_MEMBER_NAME(Camera_obj::csX,"csX");
	HX_VISIT_MEMBER_NAME(Camera_obj::csY,"csY");
	HX_VISIT_MEMBER_NAME(Camera_obj::angleRad,"angleRad");
	HX_VISIT_MEMBER_NAME(Camera_obj::clipRect,"clipRect");
	HX_VISIT_MEMBER_NAME(Camera_obj::maxDist,"maxDist");
	HX_VISIT_MEMBER_NAME(Camera_obj::maxDistSq,"maxDistSq");
	HX_VISIT_MEMBER_NAME(Camera_obj::viewMatrix,"viewMatrix");
	HX_VISIT_MEMBER_NAME(Camera_obj::isJittering,"isJittering");
	HX_VISIT_MEMBER_NAME(Camera_obj::jitter,"jitter");
};

#endif

::hx::Class Camera_obj::__mClass;

static ::String Camera_obj_sStaticFields[] = {
	HX_("mapX",3c,3e,56,48),
	HX_("mapY",3d,3e,56,48),
	HX_("cos",47,80,4b,00),
	HX_("sin",18,9f,57,00),
	HX_("xScaledCos",35,7a,a1,ff),
	HX_("yScaledCos",14,f2,eb,bf),
	HX_("xScaledSin",06,99,ad,ff),
	HX_("yScaledSin",e5,10,f8,bf),
	HX_("csX",a8,83,4b,00),
	HX_("csY",a9,83,4b,00),
	HX_("angleRad",c2,2f,60,2b),
	HX_("clipRect",14,90,6a,58),
	HX_("maxDist",2a,c0,99,c2),
	HX_("maxDistSq",68,e7,a9,ec),
	HX_("viewMatrix",86,36,15,fd),
	HX_("isJittering",ec,a0,69,58),
	HX_("jitter",2c,46,ec,23),
	HX_("init",10,3b,bb,45),
	HX_("configureCamera",2b,25,86,9f),
	HX_("update",09,86,05,87),
	::String(null())
};

void Camera_obj::__register()
{
	Camera_obj _hx_dummy;
	Camera_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("map.Camera",57,d2,3b,38);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Camera_obj::__GetStatic;
	__mClass->mSetStaticField = &Camera_obj::__SetStatic;
	__mClass->mMarkFunc = Camera_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Camera_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Camera_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Camera_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Camera_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Camera_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Camera_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_16_boot)
HXDLIN(  16)		mapX = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_17_boot)
HXDLIN(  17)		mapY = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_20_boot)
HXDLIN(  20)		cos = ( (float)(((Float)1.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_21_boot)
HXDLIN(  21)		sin = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_22_boot)
HXDLIN(  22)		xScaledCos = ( (float)(((Float)0.5)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_23_boot)
HXDLIN(  23)		yScaledCos = ( (float)(((Float)0.5)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_24_boot)
HXDLIN(  24)		xScaledSin = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_25_boot)
HXDLIN(  25)		yScaledSin = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_26_boot)
HXDLIN(  26)		csX = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_27_boot)
HXDLIN(  27)		csY = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_29_boot)
HXDLIN(  29)		angleRad = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_31_boot)
HXDLIN(  31)		maxDist = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_32_boot)
HXDLIN(  32)		maxDistSq = ( (float)(((Float)0.0)) );
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_35_boot)
HXDLIN(  35)		isJittering = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_ec57ea696cc3d6ae_36_boot)
HXDLIN(  36)		jitter = ( (float)(((Float)0.0)) );
            	}
}

} // end namespace map
