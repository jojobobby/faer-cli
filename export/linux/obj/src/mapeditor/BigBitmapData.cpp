// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_mapeditor_BigBitmapData
#include <mapeditor/BigBitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a5fd2b4802c9a7bc_19_new,"mapeditor.BigBitmapData","new",0xbae21f86,"mapeditor.BigBitmapData.new","mapeditor/BigBitmapData.hx",19,0x46f284ab)
HX_LOCAL_STACK_FRAME(_hx_pos_a5fd2b4802c9a7bc_34_copyTo,"mapeditor.BigBitmapData","copyTo",0xec5e492a,"mapeditor.BigBitmapData.copyTo","mapeditor/BigBitmapData.hx",34,0x46f284ab)
HX_LOCAL_STACK_FRAME(_hx_pos_a5fd2b4802c9a7bc_53_copyFrom,"mapeditor.BigBitmapData","copyFrom",0x6e2412d9,"mapeditor.BigBitmapData.copyFrom","mapeditor/BigBitmapData.hx",53,0x46f284ab)
HX_LOCAL_STACK_FRAME(_hx_pos_a5fd2b4802c9a7bc_71_erase,"mapeditor.BigBitmapData","erase",0xa939cd8c,"mapeditor.BigBitmapData.erase","mapeditor/BigBitmapData.hx",71,0x46f284ab)
HX_LOCAL_STACK_FRAME(_hx_pos_a5fd2b4802c9a7bc_88_dispose,"mapeditor.BigBitmapData","dispose",0x5de85ac5,"mapeditor.BigBitmapData.dispose","mapeditor/BigBitmapData.hx",88,0x46f284ab)
namespace mapeditor{

void BigBitmapData_obj::__construct(int width,int height,bool transparent,int fillColor){
            	HX_GC_STACKFRAME(&_hx_pos_a5fd2b4802c9a7bc_19_new)
HXLINE(  20)		this->width = width;
HXLINE(  21)		this->height = height;
HXLINE(  22)		this->fillColor = fillColor;
HXLINE(  23)		this->maxChunkX = ::Math_obj::ceil((( (Float)(this->width) ) / ( (Float)(256) )));
HXLINE(  24)		this->maxChunkY = ::Math_obj::ceil((( (Float)(this->height) ) / ( (Float)(256) )));
HXLINE(  25)		this->chunks = ::Array_obj< ::Dynamic>::__new((this->maxChunkX * this->maxChunkY));
HXLINE(  26)		{
HXLINE(  26)			int _g = 0;
HXDLIN(  26)			int _g1 = this->maxChunkX;
HXDLIN(  26)			while((_g < _g1)){
HXLINE(  26)				_g = (_g + 1);
HXDLIN(  26)				int cX = (_g - 1);
HXLINE(  27)				{
HXLINE(  27)					int _g2 = 0;
HXDLIN(  27)					int _g3 = this->maxChunkY;
HXDLIN(  27)					while((_g2 < _g3)){
HXLINE(  27)						_g2 = (_g2 + 1);
HXDLIN(  27)						int cY = (_g2 - 1);
HXLINE(  28)						int sizeX = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(256) ),( (Float)((this->width - (cX * 256))) )));
HXLINE(  29)						int sizeY = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(256) ),( (Float)((this->height - (cY * 256))) )));
HXLINE(  30)						{
HXLINE(  30)							::Array< ::Dynamic> this1 = this->chunks;
HXDLIN(  30)							int index = (cX + (cY * this->maxChunkX));
HXDLIN(  30)							 ::openfl::display::BitmapData val =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,sizeX,sizeY,transparent,this->fillColor);
HXDLIN(  30)							this1->__unsafe_set(index,val);
            						}
            					}
            				}
            			}
            		}
            	}

Dynamic BigBitmapData_obj::__CreateEmpty() { return new BigBitmapData_obj; }

void *BigBitmapData_obj::_hx_vtable = 0;

Dynamic BigBitmapData_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BigBitmapData_obj > _hx_result = new BigBitmapData_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool BigBitmapData_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x48766b50;
}

void BigBitmapData_obj::copyTo( ::openfl::display::BitmapData source, ::openfl::geom::Rectangle sourceRect, ::openfl::geom::Rectangle destRect){
            	HX_GC_STACKFRAME(&_hx_pos_a5fd2b4802c9a7bc_34_copyTo)
HXLINE(  35)		Float scaleX = (destRect->width / sourceRect->width);
HXLINE(  36)		Float scaleY = (destRect->height / sourceRect->height);
HXLINE(  37)		int startChunkX = ::Std_obj::_hx_int((destRect->x / ( (Float)(256) )));
HXLINE(  38)		int startChunkY = ::Std_obj::_hx_int((destRect->y / ( (Float)(256) )));
HXLINE(  39)		int endChunkX = ::Math_obj::ceil((destRect->get_right() / ( (Float)(256) )));
HXLINE(  40)		int endChunkY = ::Math_obj::ceil((destRect->get_bottom() / ( (Float)(256) )));
HXLINE(  41)		 ::openfl::geom::Matrix m =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  42)		{
HXLINE(  42)			int _g = startChunkX;
HXDLIN(  42)			while((_g < endChunkX)){
HXLINE(  42)				_g = (_g + 1);
HXDLIN(  42)				int cX = (_g - 1);
HXLINE(  43)				{
HXLINE(  43)					int _g1 = startChunkY;
HXDLIN(  43)					while((_g1 < endChunkY)){
HXLINE(  43)						_g1 = (_g1 + 1);
HXDLIN(  43)						int cY = (_g1 - 1);
HXLINE(  44)						 ::openfl::display::BitmapData chunk = ( ( ::openfl::display::BitmapData)(_hx_array_unsafe_get(this->chunks,(cX + (cY * this->maxChunkX)))) );
HXLINE(  45)						m->identity();
HXLINE(  46)						m->scale(scaleX,scaleY);
HXLINE(  47)						m->translate(((destRect->x - ( (Float)((cX * 256)) )) - (sourceRect->x * scaleX)),((destRect->y - ( (Float)((cY * 256)) )) - (sourceRect->x * scaleY)));
HXLINE(  49)						chunk->draw(source,m,null(),null(), ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,(destRect->x - ( (Float)((cX * 256)) )),(destRect->y - ( (Float)((cY * 256)) )),destRect->width,destRect->height),false);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(BigBitmapData_obj,copyTo,(void))

void BigBitmapData_obj::copyFrom( ::openfl::geom::Rectangle sourceRect, ::openfl::display::BitmapData dest, ::openfl::geom::Rectangle destRect){
            	HX_GC_STACKFRAME(&_hx_pos_a5fd2b4802c9a7bc_53_copyFrom)
HXLINE(  54)		Float scaleX = (destRect->width / sourceRect->width);
HXLINE(  55)		Float scaleY = (destRect->height / sourceRect->height);
HXLINE(  56)		int startChunkX = ::Math_obj::floor(::Math_obj::max(( (Float)(0) ),(sourceRect->x / ( (Float)(256) ))));
HXLINE(  57)		int startChunkY = ::Math_obj::floor(::Math_obj::max(( (Float)(0) ),(sourceRect->y / ( (Float)(256) ))));
HXLINE(  58)		int endChunkX = (this->maxChunkX - 1);
HXDLIN(  58)		int endChunkX1 = ::Math_obj::ceil(::Math_obj::min(( (Float)(endChunkX) ),(sourceRect->get_right() / ( (Float)(256) ))));
HXLINE(  59)		int endChunkY = (this->maxChunkY - 1);
HXDLIN(  59)		int endChunkY1 = ::Math_obj::ceil(::Math_obj::min(( (Float)(endChunkY) ),(sourceRect->get_bottom() / ( (Float)(256) ))));
HXLINE(  60)		 ::openfl::geom::Matrix m =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  61)		{
HXLINE(  61)			int _g = startChunkX;
HXDLIN(  61)			while((_g < endChunkX1)){
HXLINE(  61)				_g = (_g + 1);
HXDLIN(  61)				int cX = (_g - 1);
HXLINE(  62)				{
HXLINE(  62)					int _g1 = startChunkY;
HXDLIN(  62)					while((_g1 < endChunkY1)){
HXLINE(  62)						_g1 = (_g1 + 1);
HXDLIN(  62)						int cY = (_g1 - 1);
HXLINE(  63)						 ::openfl::display::BitmapData chunk = ( ( ::openfl::display::BitmapData)(_hx_array_unsafe_get(this->chunks,(cX + (cY * this->maxChunkX)))) );
HXLINE(  64)						m->identity();
HXLINE(  65)						m->translate((((destRect->x / scaleX) - sourceRect->x) + (cX * 256)),(((destRect->y / scaleY) - sourceRect->y) + (cY * 256)));
HXLINE(  66)						m->scale(scaleX,scaleY);
HXLINE(  67)						dest->draw(chunk,m,null(),null(),destRect,false);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(BigBitmapData_obj,copyFrom,(void))

void BigBitmapData_obj::erase( ::openfl::geom::Rectangle rect){
            	HX_GC_STACKFRAME(&_hx_pos_a5fd2b4802c9a7bc_71_erase)
HXLINE(  72)		int startChunkX = ::Math_obj::floor((rect->x / ( (Float)(256) )));
HXLINE(  73)		int startChunkY = ::Math_obj::floor((rect->y / ( (Float)(256) )));
HXLINE(  74)		int endChunkX = ::Math_obj::ceil((rect->get_right() / ( (Float)(256) )));
HXLINE(  75)		int endChunkY = ::Math_obj::ceil((rect->get_bottom() / ( (Float)(256) )));
HXLINE(  76)		 ::openfl::geom::Rectangle chunkRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  77)		{
HXLINE(  77)			int _g = startChunkX;
HXDLIN(  77)			while((_g < endChunkX)){
HXLINE(  77)				_g = (_g + 1);
HXDLIN(  77)				int cX = (_g - 1);
HXLINE(  78)				{
HXLINE(  78)					int _g1 = startChunkY;
HXDLIN(  78)					while((_g1 < endChunkY)){
HXLINE(  78)						_g1 = (_g1 + 1);
HXDLIN(  78)						int cY = (_g1 - 1);
HXLINE(  79)						 ::openfl::display::BitmapData chunk = ( ( ::openfl::display::BitmapData)(_hx_array_unsafe_get(this->chunks,(cX + (cY * this->maxChunkX)))) );
HXLINE(  80)						chunkRect->x = (rect->x - ( (Float)((cX * 256)) ));
HXLINE(  81)						chunkRect->y = (rect->y - ( (Float)((cY * 256)) ));
HXLINE(  82)						chunkRect->set_right((rect->get_right() - ( (Float)((cX * 256)) )));
HXLINE(  83)						chunkRect->set_bottom((rect->get_bottom() - ( (Float)((cY * 256)) )));
HXLINE(  84)						chunk->fillRect(chunkRect,this->fillColor);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BigBitmapData_obj,erase,(void))

void BigBitmapData_obj::dispose(){
            	HX_STACKFRAME(&_hx_pos_a5fd2b4802c9a7bc_88_dispose)
HXLINE(  89)		{
HXLINE(  89)			int _g = 0;
HXDLIN(  89)			::Array< ::Dynamic> _g1 = this->chunks;
HXDLIN(  89)			while((_g < _g1->length)){
HXLINE(  89)				 ::openfl::display::BitmapData tex = ( ( ::openfl::display::BitmapData)(_hx_array_unsafe_get(_g1,_g)) );
HXDLIN(  89)				_g = (_g + 1);
HXLINE(  90)				tex->dispose();
            			}
            		}
HXLINE(  91)		this->chunks = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(BigBitmapData_obj,dispose,(void))


::hx::ObjectPtr< BigBitmapData_obj > BigBitmapData_obj::__new(int width,int height,bool transparent,int fillColor) {
	::hx::ObjectPtr< BigBitmapData_obj > __this = new BigBitmapData_obj();
	__this->__construct(width,height,transparent,fillColor);
	return __this;
}

::hx::ObjectPtr< BigBitmapData_obj > BigBitmapData_obj::__alloc(::hx::Ctx *_hx_ctx,int width,int height,bool transparent,int fillColor) {
	BigBitmapData_obj *__this = (BigBitmapData_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(BigBitmapData_obj), true, "mapeditor.BigBitmapData"));
	*(void **)__this = BigBitmapData_obj::_hx_vtable;
	__this->__construct(width,height,transparent,fillColor);
	return __this;
}

BigBitmapData_obj::BigBitmapData_obj()
{
}

void BigBitmapData_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BigBitmapData);
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(fillColor,"fillColor");
	HX_MARK_MEMBER_NAME(maxChunkX,"maxChunkX");
	HX_MARK_MEMBER_NAME(maxChunkY,"maxChunkY");
	HX_MARK_MEMBER_NAME(chunks,"chunks");
	HX_MARK_END_CLASS();
}

void BigBitmapData_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(fillColor,"fillColor");
	HX_VISIT_MEMBER_NAME(maxChunkX,"maxChunkX");
	HX_VISIT_MEMBER_NAME(maxChunkY,"maxChunkY");
	HX_VISIT_MEMBER_NAME(chunks,"chunks");
}

::hx::Val BigBitmapData_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		if (HX_FIELD_EQ(inName,"erase") ) { return ::hx::Val( erase_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		if (HX_FIELD_EQ(inName,"chunks") ) { return ::hx::Val( chunks ); }
		if (HX_FIELD_EQ(inName,"copyTo") ) { return ::hx::Val( copyTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"dispose") ) { return ::hx::Val( dispose_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"copyFrom") ) { return ::hx::Val( copyFrom_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fillColor") ) { return ::hx::Val( fillColor ); }
		if (HX_FIELD_EQ(inName,"maxChunkX") ) { return ::hx::Val( maxChunkX ); }
		if (HX_FIELD_EQ(inName,"maxChunkY") ) { return ::hx::Val( maxChunkY ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val BigBitmapData_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"chunks") ) { chunks=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"fillColor") ) { fillColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxChunkX") ) { maxChunkX=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxChunkY") ) { maxChunkY=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BigBitmapData_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("fillColor",e0,97,03,19));
	outFields->push(HX_("maxChunkX",0f,eb,35,f4));
	outFields->push(HX_("maxChunkY",10,eb,35,f4));
	outFields->push(HX_("chunks",66,d9,aa,c4));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo BigBitmapData_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(BigBitmapData_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsInt,(int)offsetof(BigBitmapData_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsInt,(int)offsetof(BigBitmapData_obj,fillColor),HX_("fillColor",e0,97,03,19)},
	{::hx::fsInt,(int)offsetof(BigBitmapData_obj,maxChunkX),HX_("maxChunkX",0f,eb,35,f4)},
	{::hx::fsInt,(int)offsetof(BigBitmapData_obj,maxChunkY),HX_("maxChunkY",10,eb,35,f4)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(BigBitmapData_obj,chunks),HX_("chunks",66,d9,aa,c4)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *BigBitmapData_obj_sStaticStorageInfo = 0;
#endif

static ::String BigBitmapData_obj_sMemberFields[] = {
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("fillColor",e0,97,03,19),
	HX_("maxChunkX",0f,eb,35,f4),
	HX_("maxChunkY",10,eb,35,f4),
	HX_("chunks",66,d9,aa,c4),
	HX_("copyTo",90,1c,33,c9),
	HX_("copyFrom",bf,0b,61,c8),
	HX_("erase",e6,e8,1c,73),
	HX_("dispose",9f,80,4c,bb),
	::String(null()) };

::hx::Class BigBitmapData_obj::__mClass;

void BigBitmapData_obj::__register()
{
	BigBitmapData_obj _hx_dummy;
	BigBitmapData_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("mapeditor.BigBitmapData",94,a4,b6,1a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(BigBitmapData_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< BigBitmapData_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BigBitmapData_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BigBitmapData_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace mapeditor
