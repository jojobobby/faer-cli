// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_core_PlayerModel
#include <core/PlayerModel.h>
#endif
#ifndef INCLUDED_servers_LatLong
#include <servers/LatLong.h>
#endif
#ifndef INCLUDED_servers_Server
#include <servers/Server.h>
#endif
#ifndef INCLUDED_servers_ServerModel
#include <servers/ServerModel.h>
#endif
#ifndef INCLUDED_util_Settings
#include <util/Settings.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_65b3d8bdadaebc52_7_new,"servers.ServerModel","new",0xc8041d9a,"servers.ServerModel.new","servers/ServerModel.hx",7,0x5fecb2d7)
HX_LOCAL_STACK_FRAME(_hx_pos_65b3d8bdadaebc52_11_setServers,"servers.ServerModel","setServers",0x051a72d4,"servers.ServerModel.setServers","servers/ServerModel.hx",11,0x5fecb2d7)
HX_LOCAL_STACK_FRAME(_hx_pos_65b3d8bdadaebc52_18_getServers,"servers.ServerModel","getServers",0x019cd460,"servers.ServerModel.getServers","servers/ServerModel.hx",18,0x5fecb2d7)
HX_LOCAL_STACK_FRAME(_hx_pos_65b3d8bdadaebc52_21_getServer,"servers.ServerModel","getServer",0xf6d2c8b3,"servers.ServerModel.getServer","servers/ServerModel.hx",21,0x5fecb2d7)
HX_LOCAL_STACK_FRAME(_hx_pos_65b3d8bdadaebc52_48_isServerAvailable,"servers.ServerModel","isServerAvailable",0x888de076,"servers.ServerModel.isServerAvailable","servers/ServerModel.hx",48,0x5fecb2d7)
namespace servers{

void ServerModel_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_65b3d8bdadaebc52_7_new)
HXDLIN(   7)		this->servers = ::Array_obj< ::Dynamic>::__new();
            	}

Dynamic ServerModel_obj::__CreateEmpty() { return new ServerModel_obj; }

void *ServerModel_obj::_hx_vtable = 0;

Dynamic ServerModel_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ServerModel_obj > _hx_result = new ServerModel_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ServerModel_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0fd21a3e;
}

void ServerModel_obj::setServers(::Array< ::Dynamic> list){
            	HX_STACKFRAME(&_hx_pos_65b3d8bdadaebc52_11_setServers)
HXLINE(  12)		this->servers->removeRange(0,this->servers->length);
HXLINE(  13)		{
HXLINE(  13)			int _g = 0;
HXDLIN(  13)			while((_g < list->length)){
HXLINE(  13)				 ::servers::Server server = list->__get(_g).StaticCast<  ::servers::Server >();
HXDLIN(  13)				_g = (_g + 1);
HXLINE(  14)				this->servers->push(server);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ServerModel_obj,setServers,(void))

::Array< ::Dynamic> ServerModel_obj::getServers(){
            	HX_STACKFRAME(&_hx_pos_65b3d8bdadaebc52_18_getServers)
HXDLIN(  18)		return this->servers;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ServerModel_obj,getServers,return )

 ::servers::Server ServerModel_obj::getServer(){
            	HX_STACKFRAME(&_hx_pos_65b3d8bdadaebc52_21_getServer)
HXLINE(  22)		int priority = 0;
HXLINE(  23)		Float dist = ((Float)0.0);
HXLINE(  24)		bool isAdmin = ::Global_obj::playerModel->isAdmin();
HXLINE(  25)		 ::servers::LatLong myLocation = ::Global_obj::playerModel->getMyPos();
HXLINE(  26)		 ::servers::Server closestServer = null();
HXLINE(  27)		float minDist = ( (float)(((Float)3.4028235E+38)) );
HXLINE(  28)		int bestPriority = (int)2147483647;
HXLINE(  29)		{
HXLINE(  29)			int _g = 0;
HXDLIN(  29)			::Array< ::Dynamic> _g1 = this->servers;
HXDLIN(  29)			while((_g < _g1->length)){
HXLINE(  29)				 ::servers::Server server = _g1->__get(_g).StaticCast<  ::servers::Server >();
HXDLIN(  29)				_g = (_g + 1);
HXLINE(  30)				bool _hx_tmp;
HXDLIN(  30)				if (server->isFull()) {
HXLINE(  30)					_hx_tmp = !(isAdmin);
            				}
            				else {
HXLINE(  30)					_hx_tmp = false;
            				}
HXDLIN(  30)				if (!(_hx_tmp)) {
HXLINE(  31)					if ((server->name == ::util::Settings_obj::selectedServer)) {
HXLINE(  32)						return server;
            					}
HXLINE(  34)					priority = server->priority();
HXLINE(  35)					dist = ( (Float)(::servers::LatLong_obj::distance(myLocation,server->latLong)) );
HXLINE(  36)					bool _hx_tmp1;
HXDLIN(  36)					if ((priority >= bestPriority)) {
HXLINE(  36)						if ((priority == bestPriority)) {
HXLINE(  36)							_hx_tmp1 = (dist < minDist);
            						}
            						else {
HXLINE(  36)							_hx_tmp1 = false;
            						}
            					}
            					else {
HXLINE(  36)						_hx_tmp1 = true;
            					}
HXDLIN(  36)					if (_hx_tmp1) {
HXLINE(  37)						closestServer = server;
HXLINE(  38)						minDist = ( (float)(dist) );
HXLINE(  39)						bestPriority = priority;
            					}
            				}
            			}
            		}
HXLINE(  44)		return closestServer;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ServerModel_obj,getServer,return )

bool ServerModel_obj::isServerAvailable(){
            	HX_STACKFRAME(&_hx_pos_65b3d8bdadaebc52_48_isServerAvailable)
HXDLIN(  48)		return (this->servers->length > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ServerModel_obj,isServerAvailable,return )


::hx::ObjectPtr< ServerModel_obj > ServerModel_obj::__new() {
	::hx::ObjectPtr< ServerModel_obj > __this = new ServerModel_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< ServerModel_obj > ServerModel_obj::__alloc(::hx::Ctx *_hx_ctx) {
	ServerModel_obj *__this = (ServerModel_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ServerModel_obj), true, "servers.ServerModel"));
	*(void **)__this = ServerModel_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ServerModel_obj::ServerModel_obj()
{
}

void ServerModel_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ServerModel);
	HX_MARK_MEMBER_NAME(servers,"servers");
	HX_MARK_END_CLASS();
}

void ServerModel_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(servers,"servers");
}

::hx::Val ServerModel_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"servers") ) { return ::hx::Val( servers ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"getServer") ) { return ::hx::Val( getServer_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"setServers") ) { return ::hx::Val( setServers_dyn() ); }
		if (HX_FIELD_EQ(inName,"getServers") ) { return ::hx::Val( getServers_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"isServerAvailable") ) { return ::hx::Val( isServerAvailable_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ServerModel_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"servers") ) { servers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ServerModel_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("servers",50,20,2a,02));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ServerModel_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ServerModel_obj,servers),HX_("servers",50,20,2a,02)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ServerModel_obj_sStaticStorageInfo = 0;
#endif

static ::String ServerModel_obj_sMemberFields[] = {
	HX_("servers",50,20,2a,02),
	HX_("setServers",ce,44,09,55),
	HX_("getServers",5a,a6,8b,51),
	HX_("getServer",f9,d3,8d,ea),
	HX_("isServerAvailable",bc,a1,ce,3c),
	::String(null()) };

::hx::Class ServerModel_obj::__mClass;

void ServerModel_obj::__register()
{
	ServerModel_obj _hx_dummy;
	ServerModel_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("servers.ServerModel",a8,08,d3,d3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ServerModel_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ServerModel_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ServerModel_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ServerModel_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace servers
