// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_util_BinPacker
#include <util/BinPacker.h>
#endif
#ifndef INCLUDED_util_Rect
#include <util/Rect.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_acc4b15ecc0a4099_29_new,"util.BinPacker","new",0x42193193,"util.BinPacker.new","util/BinPacker.hx",29,0x7c00debe)
HX_LOCAL_STACK_FRAME(_hx_pos_acc4b15ecc0a4099_36_insert,"util.BinPacker","insert",0x44a063e6,"util.BinPacker.insert","util/BinPacker.hx",36,0x7c00debe)
HX_LOCAL_STACK_FRAME(_hx_pos_acc4b15ecc0a4099_78_splitFreeNode,"util.BinPacker","splitFreeNode",0xcdb5a8bb,"util.BinPacker.splitFreeNode","util/BinPacker.hx",78,0x7c00debe)
HX_LOCAL_STACK_FRAME(_hx_pos_acc4b15ecc0a4099_119_pruneFreeList,"util.BinPacker","pruneFreeList",0x6bbd1367,"util.BinPacker.pruneFreeList","util/BinPacker.hx",119,0x7c00debe)
namespace util{

void BinPacker_obj::__construct(float width,float height){
            	HX_GC_STACKFRAME(&_hx_pos_acc4b15ecc0a4099_29_new)
HXLINE(  30)		this->binWidth = width;
HXLINE(  31)		this->binHeight = height;
HXLINE(  32)		this->freeRectangles = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  33)		this->freeRectangles->push( ::util::Rect_obj::__alloc( HX_CTX ,0,0,width,height));
            	}

Dynamic BinPacker_obj::__CreateEmpty() { return new BinPacker_obj; }

void *BinPacker_obj::_hx_vtable = 0;

Dynamic BinPacker_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BinPacker_obj > _hx_result = new BinPacker_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool BinPacker_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x03fd914b;
}

 ::util::Rect BinPacker_obj::insert(float width,float height){
            	HX_GC_STACKFRAME(&_hx_pos_acc4b15ecc0a4099_36_insert)
HXLINE(  37)		float score = ( (float)(((Float)3.4028235E+38)) );
HXDLIN(  37)		float areaFit = ( (float)(((Float)0.0)) );
HXDLIN(  37)		 ::util::Rect bestNode =  ::util::Rect_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXDLIN(  37)		{
HXLINE(  37)			int _g = 0;
HXDLIN(  37)			::Array< ::Dynamic> _g1 = this->freeRectangles;
HXDLIN(  37)			while((_g < _g1->length)){
HXLINE(  37)				 ::util::Rect r = _g1->__get(_g).StaticCast<  ::util::Rect >();
HXDLIN(  37)				_g = (_g + 1);
HXDLIN(  37)				bool newNode;
HXDLIN(  37)				if ((r->width >= width)) {
HXLINE(  37)					newNode = (r->height >= height);
            				}
            				else {
HXLINE(  37)					newNode = false;
            				}
HXDLIN(  37)				if (newNode) {
HXLINE(  37)					areaFit = ( (float)(((r->width * r->height) - ( (Float)((width * height)) ))) );
HXDLIN(  37)					if ((areaFit < score)) {
HXLINE(  37)						bestNode->x = r->x;
HXDLIN(  37)						bestNode->y = r->y;
HXDLIN(  37)						bestNode->width = ( (Float)(width) );
HXDLIN(  37)						bestNode->height = ( (Float)(height) );
HXDLIN(  37)						score = areaFit;
            					}
            				}
            			}
            		}
HXDLIN(  37)		 ::util::Rect newNode1;
HXDLIN(  37)		if ((bestNode->height != 0)) {
HXLINE(  37)			newNode1 = bestNode;
            		}
            		else {
HXLINE(  37)			newNode1 = null();
            		}
HXDLIN(  37)		 ::util::Rect newNode2 = newNode1;
HXLINE(  39)		if (::hx::IsNull( newNode2 )) {
HXLINE(  40)			return newNode2;
            		}
HXLINE(  42)		int numRectanglesToProcess = this->freeRectangles->length;
HXLINE(  43)		int i = 0;
HXLINE(  44)		while((i < numRectanglesToProcess)){
HXLINE(  45)			if (this->splitFreeNode(this->freeRectangles->__get(i).StaticCast<  ::util::Rect >(),newNode2)) {
HXLINE(  46)				this->freeRectangles->removeRange(i,1);
HXLINE(  47)				numRectanglesToProcess = (numRectanglesToProcess - 1);
HXLINE(  48)				i = (i - 1);
            			}
HXLINE(  50)			i = (i + 1);
            		}
HXLINE(  53)		this->pruneFreeList();
HXLINE(  55)		return newNode2;
            	}


HX_DEFINE_DYNAMIC_FUNC2(BinPacker_obj,insert,return )

bool BinPacker_obj::splitFreeNode( ::util::Rect freeNode, ::util::Rect usedNode){
            	HX_GC_STACKFRAME(&_hx_pos_acc4b15ecc0a4099_78_splitFreeNode)
HXLINE(  79)		bool _hx_tmp;
HXDLIN(  79)		bool _hx_tmp1;
HXDLIN(  79)		bool _hx_tmp2;
HXDLIN(  79)		if (!((usedNode->x >= (freeNode->x + freeNode->width)))) {
HXLINE(  79)			_hx_tmp2 = ((usedNode->x + usedNode->width) <= freeNode->x);
            		}
            		else {
HXLINE(  79)			_hx_tmp2 = true;
            		}
HXDLIN(  79)		if (!(_hx_tmp2)) {
HXLINE(  79)			_hx_tmp1 = (usedNode->y >= (freeNode->y + freeNode->height));
            		}
            		else {
HXLINE(  79)			_hx_tmp1 = true;
            		}
HXDLIN(  79)		if (!(_hx_tmp1)) {
HXLINE(  79)			_hx_tmp = ((usedNode->y + usedNode->height) <= freeNode->y);
            		}
            		else {
HXLINE(  79)			_hx_tmp = true;
            		}
HXDLIN(  79)		if (_hx_tmp) {
HXLINE(  83)			return false;
            		}
HXLINE(  85)		 ::util::Rect newNode;
HXLINE(  86)		bool _hx_tmp3;
HXDLIN(  86)		if ((usedNode->x < (freeNode->x + freeNode->width))) {
HXLINE(  86)			_hx_tmp3 = ((usedNode->x + usedNode->width) > freeNode->x);
            		}
            		else {
HXLINE(  86)			_hx_tmp3 = false;
            		}
HXDLIN(  86)		if (_hx_tmp3) {
HXLINE(  87)			bool _hx_tmp4;
HXDLIN(  87)			if ((usedNode->y > freeNode->y)) {
HXLINE(  87)				_hx_tmp4 = (usedNode->y < (freeNode->y + freeNode->height));
            			}
            			else {
HXLINE(  87)				_hx_tmp4 = false;
            			}
HXDLIN(  87)			if (_hx_tmp4) {
HXLINE(  88)				newNode =  ::util::Rect_obj::__alloc( HX_CTX ,freeNode->x,freeNode->y,freeNode->width,freeNode->height);
HXLINE(  89)				newNode->height = (usedNode->y - newNode->y);
HXLINE(  90)				this->freeRectangles->push(newNode);
            			}
HXLINE(  93)			if (((usedNode->y + usedNode->height) < (freeNode->y + freeNode->height))) {
HXLINE(  94)				newNode =  ::util::Rect_obj::__alloc( HX_CTX ,freeNode->x,freeNode->y,freeNode->width,freeNode->height);
HXLINE(  95)				newNode->y = (usedNode->y + usedNode->height);
HXLINE(  96)				newNode->height = ((freeNode->y + freeNode->height) - (usedNode->y + usedNode->height));
HXLINE(  97)				this->freeRectangles->push(newNode);
            			}
            		}
HXLINE( 101)		bool _hx_tmp5;
HXDLIN( 101)		if ((usedNode->y < (freeNode->y + freeNode->height))) {
HXLINE( 101)			_hx_tmp5 = ((usedNode->y + usedNode->height) > freeNode->y);
            		}
            		else {
HXLINE( 101)			_hx_tmp5 = false;
            		}
HXDLIN( 101)		if (_hx_tmp5) {
HXLINE( 102)			bool _hx_tmp6;
HXDLIN( 102)			if ((usedNode->x > freeNode->x)) {
HXLINE( 102)				_hx_tmp6 = (usedNode->x < (freeNode->x + freeNode->width));
            			}
            			else {
HXLINE( 102)				_hx_tmp6 = false;
            			}
HXDLIN( 102)			if (_hx_tmp6) {
HXLINE( 103)				newNode =  ::util::Rect_obj::__alloc( HX_CTX ,freeNode->x,freeNode->y,freeNode->width,freeNode->height);
HXLINE( 104)				newNode->width = (usedNode->x - newNode->x);
HXLINE( 105)				this->freeRectangles->push(newNode);
            			}
HXLINE( 108)			if (((usedNode->x + usedNode->width) < (freeNode->x + freeNode->width))) {
HXLINE( 109)				newNode =  ::util::Rect_obj::__alloc( HX_CTX ,freeNode->x,freeNode->y,freeNode->width,freeNode->height);
HXLINE( 110)				newNode->x = (usedNode->x + usedNode->width);
HXLINE( 111)				newNode->width = ((freeNode->x + freeNode->width) - (usedNode->x + usedNode->width));
HXLINE( 112)				this->freeRectangles->push(newNode);
            			}
            		}
HXLINE( 116)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(BinPacker_obj,splitFreeNode,return )

void BinPacker_obj::pruneFreeList(){
            	HX_STACKFRAME(&_hx_pos_acc4b15ecc0a4099_119_pruneFreeList)
HXLINE( 120)		int i = 0;
HXLINE( 121)		int j = 0;
HXLINE( 122)		int len = this->freeRectangles->length;
HXLINE( 123)		while((i < len)){
HXLINE( 124)			j = (i + 1);
HXLINE( 125)			 ::util::Rect tmpRect = this->freeRectangles->__get(i).StaticCast<  ::util::Rect >();
HXLINE( 126)			while((j < len)){
HXLINE( 127)				 ::util::Rect tmpRect2 = this->freeRectangles->__get(j).StaticCast<  ::util::Rect >();
HXLINE( 128)				bool _hx_tmp;
HXDLIN( 128)				bool _hx_tmp1;
HXDLIN( 128)				bool _hx_tmp2;
HXDLIN( 128)				if ((tmpRect->x >= tmpRect2->x)) {
HXLINE( 128)					_hx_tmp2 = (tmpRect->y >= tmpRect2->y);
            				}
            				else {
HXLINE( 128)					_hx_tmp2 = false;
            				}
HXDLIN( 128)				if (_hx_tmp2) {
HXLINE( 128)					_hx_tmp1 = ((tmpRect->x + tmpRect->width) <= (tmpRect2->x + tmpRect2->width));
            				}
            				else {
HXLINE( 128)					_hx_tmp1 = false;
            				}
HXDLIN( 128)				if (_hx_tmp1) {
HXLINE( 128)					_hx_tmp = ((tmpRect->y + tmpRect->height) <= (tmpRect2->y + tmpRect2->height));
            				}
            				else {
HXLINE( 128)					_hx_tmp = false;
            				}
HXDLIN( 128)				if (_hx_tmp) {
HXLINE( 129)					this->freeRectangles->removeRange(i,1);
HXLINE( 130)					i = (i - 1);
HXLINE( 131)					len = (len - 1);
HXLINE( 132)					goto _hx_goto_6;
            				}
HXLINE( 134)				bool _hx_tmp3;
HXDLIN( 134)				bool _hx_tmp4;
HXDLIN( 134)				bool _hx_tmp5;
HXDLIN( 134)				if ((tmpRect2->x >= tmpRect->x)) {
HXLINE( 134)					_hx_tmp5 = (tmpRect2->y >= tmpRect->y);
            				}
            				else {
HXLINE( 134)					_hx_tmp5 = false;
            				}
HXDLIN( 134)				if (_hx_tmp5) {
HXLINE( 134)					_hx_tmp4 = ((tmpRect2->x + tmpRect2->width) <= (tmpRect->x + tmpRect->width));
            				}
            				else {
HXLINE( 134)					_hx_tmp4 = false;
            				}
HXDLIN( 134)				if (_hx_tmp4) {
HXLINE( 134)					_hx_tmp3 = ((tmpRect2->y + tmpRect2->height) <= (tmpRect->y + tmpRect->height));
            				}
            				else {
HXLINE( 134)					_hx_tmp3 = false;
            				}
HXDLIN( 134)				if (_hx_tmp3) {
HXLINE( 135)					this->freeRectangles->removeRange(j,1);
HXLINE( 136)					len = (len - 1);
HXLINE( 137)					j = (j - 1);
            				}
HXLINE( 139)				j = (j + 1);
            			}
            			_hx_goto_6:;
HXLINE( 141)			i = (i + 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BinPacker_obj,pruneFreeList,(void))


::hx::ObjectPtr< BinPacker_obj > BinPacker_obj::__new(float width,float height) {
	::hx::ObjectPtr< BinPacker_obj > __this = new BinPacker_obj();
	__this->__construct(width,height);
	return __this;
}

::hx::ObjectPtr< BinPacker_obj > BinPacker_obj::__alloc(::hx::Ctx *_hx_ctx,float width,float height) {
	BinPacker_obj *__this = (BinPacker_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(BinPacker_obj), true, "util.BinPacker"));
	*(void **)__this = BinPacker_obj::_hx_vtable;
	__this->__construct(width,height);
	return __this;
}

BinPacker_obj::BinPacker_obj()
{
}

void BinPacker_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BinPacker);
	HX_MARK_MEMBER_NAME(binWidth,"binWidth");
	HX_MARK_MEMBER_NAME(binHeight,"binHeight");
	HX_MARK_MEMBER_NAME(freeRectangles,"freeRectangles");
	HX_MARK_END_CLASS();
}

void BinPacker_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(binWidth,"binWidth");
	HX_VISIT_MEMBER_NAME(binHeight,"binHeight");
	HX_VISIT_MEMBER_NAME(freeRectangles,"freeRectangles");
}

::hx::Val BinPacker_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"insert") ) { return ::hx::Val( insert_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"binWidth") ) { return ::hx::Val( binWidth ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"binHeight") ) { return ::hx::Val( binHeight ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"splitFreeNode") ) { return ::hx::Val( splitFreeNode_dyn() ); }
		if (HX_FIELD_EQ(inName,"pruneFreeList") ) { return ::hx::Val( pruneFreeList_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"freeRectangles") ) { return ::hx::Val( freeRectangles ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val BinPacker_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"binWidth") ) { binWidth=inValue.Cast< float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"binHeight") ) { binHeight=inValue.Cast< float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"freeRectangles") ) { freeRectangles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BinPacker_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("binWidth",bf,3b,6f,4c));
	outFields->push(HX_("binHeight",0e,84,34,4b));
	outFields->push(HX_("freeRectangles",30,85,7b,93));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo BinPacker_obj_sMemberStorageInfo[] = {
	{::hx::fsUnknown /* float */ ,(int)offsetof(BinPacker_obj,binWidth),HX_("binWidth",bf,3b,6f,4c)},
	{::hx::fsUnknown /* float */ ,(int)offsetof(BinPacker_obj,binHeight),HX_("binHeight",0e,84,34,4b)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(BinPacker_obj,freeRectangles),HX_("freeRectangles",30,85,7b,93)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *BinPacker_obj_sStaticStorageInfo = 0;
#endif

static ::String BinPacker_obj_sMemberFields[] = {
	HX_("binWidth",bf,3b,6f,4c),
	HX_("binHeight",0e,84,34,4b),
	HX_("freeRectangles",30,85,7b,93),
	HX_("insert",39,43,dd,9d),
	HX_("splitFreeNode",c8,a9,bd,d0),
	HX_("pruneFreeList",74,14,c5,6e),
	::String(null()) };

::hx::Class BinPacker_obj::__mClass;

void BinPacker_obj::__register()
{
	BinPacker_obj _hx_dummy;
	BinPacker_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("util.BinPacker",21,6c,7e,45);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(BinPacker_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< BinPacker_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BinPacker_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BinPacker_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace util
