// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_util_AssetLibrary
#include <util/AssetLibrary.h>
#endif
#ifndef INCLUDED_util_BitmapUtil
#include <util/BitmapUtil.h>
#endif
#ifndef INCLUDED_util_ImageSet
#include <util/ImageSet.h>
#endif
#ifndef INCLUDED_util_Rect
#include <util/Rect.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_300264f6594009e8_11_addImageSet,"util.AssetLibrary","addImageSet",0x6f4c2a51,"util.AssetLibrary.addImageSet","util/AssetLibrary.hx",11,0x258d3546)
HX_LOCAL_STACK_FRAME(_hx_pos_300264f6594009e8_28_getImageFromSet,"util.AssetLibrary","getImageFromSet",0x9710687c,"util.AssetLibrary.getImageFromSet","util/AssetLibrary.hx",28,0x258d3546)
HX_LOCAL_STACK_FRAME(_hx_pos_300264f6594009e8_43_getRectFromSet,"util.AssetLibrary","getRectFromSet",0x3f03be35,"util.AssetLibrary.getRectFromSet","util/AssetLibrary.hx",43,0x258d3546)
HX_LOCAL_STACK_FRAME(_hx_pos_300264f6594009e8_8_boot,"util.AssetLibrary","boot",0x74d7e909,"util.AssetLibrary.boot","util/AssetLibrary.hx",8,0x258d3546)
HX_LOCAL_STACK_FRAME(_hx_pos_300264f6594009e8_9_boot,"util.AssetLibrary","boot",0x74d7e909,"util.AssetLibrary.boot","util/AssetLibrary.hx",9,0x258d3546)
namespace util{

void AssetLibrary_obj::__construct() { }

Dynamic AssetLibrary_obj::__CreateEmpty() { return new AssetLibrary_obj; }

void *AssetLibrary_obj::_hx_vtable = 0;

Dynamic AssetLibrary_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AssetLibrary_obj > _hx_result = new AssetLibrary_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool AssetLibrary_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1a7d2671;
}

 ::haxe::ds::StringMap AssetLibrary_obj::images;

 ::haxe::ds::StringMap AssetLibrary_obj::imageSets;

void AssetLibrary_obj::addImageSet(::String name, ::openfl::display::BitmapData data,int width,int height,::hx::Null< bool >  __o_ignoreAtlas){
            		bool ignoreAtlas = __o_ignoreAtlas.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_300264f6594009e8_11_addImageSet)
HXLINE(  12)		::util::AssetLibrary_obj::images->set(name,data);
HXLINE(  13)		 ::util::ImageSet imageSet =  ::util::ImageSet_obj::__alloc( HX_CTX );
HXLINE(  14)		imageSet->addFromBitmapData(data,width,height,ignoreAtlas,null());
HXLINE(  15)		::util::AssetLibrary_obj::imageSets->set(name,imageSet);
HXLINE(  16)		data->dispose();
HXLINE(  17)		data = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(AssetLibrary_obj,addImageSet,(void))

 ::openfl::display::BitmapData AssetLibrary_obj::getImageFromSet(::String name,int id){
            	HX_STACKFRAME(&_hx_pos_300264f6594009e8_28_getImageFromSet)
HXDLIN(  28)		while(true){
HXLINE(  29)			bool _hx_tmp;
HXDLIN(  29)			bool _hx_tmp1;
HXDLIN(  29)			if ((id >= 0)) {
HXLINE(  29)				_hx_tmp1 = !(::util::AssetLibrary_obj::imageSets->exists(name));
            			}
            			else {
HXLINE(  29)				_hx_tmp1 = true;
            			}
HXDLIN(  29)			if (!(_hx_tmp1)) {
HXLINE(  29)				_hx_tmp = (id >= ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) )->images->length);
            			}
            			else {
HXLINE(  29)				_hx_tmp = true;
            			}
HXDLIN(  29)			if (_hx_tmp) {
HXLINE(  30)				 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  30)				::String _hx_tmp3 = ((((((HX_("Could not parse image: ",08,99,36,24) + name) + HX_(" (id: ",49,3b,26,19)) + id) + HX_(", exists: ",f6,39,82,f9)) + ::Std_obj::string(::util::AssetLibrary_obj::imageSets->exists(name))) + HX_(", imagesLen: ",ef,a7,43,49));
HXDLIN(  30)				 ::util::ImageSet tmp = ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) );
HXDLIN(  30)				 ::Dynamic _hx_tmp4;
HXDLIN(  30)				if (::hx::IsNotNull( tmp )) {
HXLINE(  30)					_hx_tmp4 = tmp->images->length;
            				}
            				else {
HXLINE(  30)					_hx_tmp4 = null();
            				}
HXDLIN(  30)				_hx_tmp2(((_hx_tmp3 + _hx_tmp4) + HX_(")",29,00,00,00)),::hx::SourceInfo(HX_("src/util/AssetLibrary.hx",91,dd,41,24),30,HX_("util.AssetLibrary",f7,2a,00,08),HX_("getImageFromSet",f3,3b,b5,6a)));
HXLINE(  31)				name = HX_("errorTexture",f3,ad,10,50);
HXDLIN(  31)				id = 0;
HXLINE(   1)				continue;
            			}
HXLINE(  34)			 ::openfl::display::BitmapData tex = ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) )->images->__get(id).StaticCast<  ::openfl::display::BitmapData >();
HXLINE(  35)			bool _hx_tmp5;
HXDLIN(  35)			if ((name != HX_("invisible",2d,93,d5,bb))) {
HXLINE(  35)				_hx_tmp5 = (::util::BitmapUtil_obj::amountTransparent(tex) >= 1);
            			}
            			else {
HXLINE(  35)				_hx_tmp5 = false;
            			}
HXDLIN(  35)			if (_hx_tmp5) {
HXLINE(  36)				 ::Dynamic _hx_tmp6 = ::haxe::Log_obj::trace;
HXDLIN(  36)				::String _hx_tmp7 = ((((((HX_("Image: ",a1,46,c5,8e) + name) + HX_(" was completely empty (id: ",33,26,eb,96)) + id) + HX_(", exists: ",f6,39,82,f9)) + ::Std_obj::string(::util::AssetLibrary_obj::imageSets->exists(name))) + HX_(", imagesLen: ",ef,a7,43,49));
HXDLIN(  36)				 ::util::ImageSet tmp1 = ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) );
HXDLIN(  36)				 ::Dynamic _hx_tmp8;
HXDLIN(  36)				if (::hx::IsNotNull( tmp1 )) {
HXLINE(  36)					_hx_tmp8 = tmp1->images->length;
            				}
            				else {
HXLINE(  36)					_hx_tmp8 = null();
            				}
HXDLIN(  36)				_hx_tmp6(((_hx_tmp7 + _hx_tmp8) + HX_(")",29,00,00,00)),::hx::SourceInfo(HX_("src/util/AssetLibrary.hx",91,dd,41,24),36,HX_("util.AssetLibrary",f7,2a,00,08),HX_("getImageFromSet",f3,3b,b5,6a)));
HXLINE(  37)				name = HX_("errorTexture",f3,ad,10,50);
HXDLIN(  37)				id = 0;
HXLINE(   1)				continue;
            			}
HXLINE(  40)			return tex;
            		}
HXLINE(  28)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(AssetLibrary_obj,getImageFromSet,return )

 ::util::Rect AssetLibrary_obj::getRectFromSet(::String name,int id){
            	HX_STACKFRAME(&_hx_pos_300264f6594009e8_43_getRectFromSet)
HXDLIN(  43)		while(true){
HXLINE(  44)			bool _hx_tmp;
HXDLIN(  44)			bool _hx_tmp1;
HXDLIN(  44)			if ((id >= 0)) {
HXLINE(  44)				_hx_tmp1 = !(::util::AssetLibrary_obj::imageSets->exists(name));
            			}
            			else {
HXLINE(  44)				_hx_tmp1 = true;
            			}
HXDLIN(  44)			if (!(_hx_tmp1)) {
HXLINE(  44)				_hx_tmp = (id >= ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) )->rects->length);
            			}
            			else {
HXLINE(  44)				_hx_tmp = true;
            			}
HXDLIN(  44)			if (_hx_tmp) {
HXLINE(  45)				 ::Dynamic _hx_tmp2 = ::haxe::Log_obj::trace;
HXDLIN(  45)				::String _hx_tmp3 = ((((((HX_("Could not parse rect: ",63,bc,63,c0) + name) + HX_(" (id: ",49,3b,26,19)) + id) + HX_(", exists: ",f6,39,82,f9)) + ::Std_obj::string(::util::AssetLibrary_obj::imageSets->exists(name))) + HX_(", rectsLen: ",e0,cb,ec,39));
HXDLIN(  45)				 ::util::ImageSet tmp = ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) );
HXDLIN(  45)				 ::Dynamic _hx_tmp4;
HXDLIN(  45)				if (::hx::IsNotNull( tmp )) {
HXLINE(  45)					_hx_tmp4 = tmp->rects->length;
            				}
            				else {
HXLINE(  45)					_hx_tmp4 = null();
            				}
HXDLIN(  45)				_hx_tmp2(((_hx_tmp3 + _hx_tmp4) + HX_(")",29,00,00,00)),::hx::SourceInfo(HX_("src/util/AssetLibrary.hx",91,dd,41,24),45,HX_("util.AssetLibrary",f7,2a,00,08),HX_("getRectFromSet",9e,46,96,6b)));
HXLINE(  46)				name = HX_("errorTexture",f3,ad,10,50);
HXDLIN(  46)				id = 0;
HXLINE(   1)				continue;
            			}
HXLINE(  49)			return ( ( ::util::ImageSet)(::util::AssetLibrary_obj::imageSets->get(name)) )->rects->__get(id).StaticCast<  ::util::Rect >();
            		}
HXLINE(  43)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(AssetLibrary_obj,getRectFromSet,return )


AssetLibrary_obj::AssetLibrary_obj()
{
}

bool AssetLibrary_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"images") ) { outValue = ( images ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"imageSets") ) { outValue = ( imageSets ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"addImageSet") ) { outValue = addImageSet_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getRectFromSet") ) { outValue = getRectFromSet_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"getImageFromSet") ) { outValue = getImageFromSet_dyn(); return true; }
	}
	return false;
}

bool AssetLibrary_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"images") ) { images=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"imageSets") ) { imageSets=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *AssetLibrary_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo AssetLibrary_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &AssetLibrary_obj::images,HX_("images",b8,50,92,fe)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &AssetLibrary_obj::imageSets,HX_("imageSets",8c,27,85,2e)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void AssetLibrary_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(AssetLibrary_obj::images,"images");
	HX_MARK_MEMBER_NAME(AssetLibrary_obj::imageSets,"imageSets");
};

#ifdef HXCPP_VISIT_ALLOCS
static void AssetLibrary_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(AssetLibrary_obj::images,"images");
	HX_VISIT_MEMBER_NAME(AssetLibrary_obj::imageSets,"imageSets");
};

#endif

::hx::Class AssetLibrary_obj::__mClass;

static ::String AssetLibrary_obj_sStaticFields[] = {
	HX_("images",b8,50,92,fe),
	HX_("imageSets",8c,27,85,2e),
	HX_("addImageSet",48,36,96,b5),
	HX_("getImageFromSet",f3,3b,b5,6a),
	HX_("getRectFromSet",9e,46,96,6b),
	::String(null())
};

void AssetLibrary_obj::__register()
{
	AssetLibrary_obj _hx_dummy;
	AssetLibrary_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("util.AssetLibrary",f7,2a,00,08);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &AssetLibrary_obj::__GetStatic;
	__mClass->mSetStaticField = &AssetLibrary_obj::__SetStatic;
	__mClass->mMarkFunc = AssetLibrary_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(AssetLibrary_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< AssetLibrary_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = AssetLibrary_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AssetLibrary_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AssetLibrary_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void AssetLibrary_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_300264f6594009e8_8_boot)
HXDLIN(   8)		images =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_300264f6594009e8_9_boot)
HXDLIN(   9)		imageSets =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace util
