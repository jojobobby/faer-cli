// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_openfl_display_Bitmap
#include <openfl/display/Bitmap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_filters_GlowFilter
#include <openfl/filters/GlowFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_util_GlowRedrawer
#include <util/GlowRedrawer.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_15_outlineGlow,"util.GlowRedrawer","outlineGlow",0x0890265e,"util.GlowRedrawer.outlineGlow","util/GlowRedrawer.hx",15,0x7f6bfae0)
HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_48_cache,"util.GlowRedrawer","cache",0x93e5a831,"util.GlowRedrawer.cache","util/GlowRedrawer.hx",48,0x7f6bfae0)
HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_59_isCached,"util.GlowRedrawer","isCached",0xc4eb0cdd,"util.GlowRedrawer.isCached","util/GlowRedrawer.hx",59,0x7f6bfae0)
HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_65_getHash,"util.GlowRedrawer","getHash",0x8b2e8733,"util.GlowRedrawer.getHash","util/GlowRedrawer.hx",65,0x7f6bfae0)
HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_10_boot,"util.GlowRedrawer","boot",0x1826c923,"util.GlowRedrawer.boot","util/GlowRedrawer.hx",10,0x7f6bfae0)
HX_LOCAL_STACK_FRAME(_hx_pos_d276e28ea2e28404_12_boot,"util.GlowRedrawer","boot",0x1826c923,"util.GlowRedrawer.boot","util/GlowRedrawer.hx",12,0x7f6bfae0)
namespace util{

void GlowRedrawer_obj::__construct() { }

Dynamic GlowRedrawer_obj::__CreateEmpty() { return new GlowRedrawer_obj; }

void *GlowRedrawer_obj::_hx_vtable = 0;

Dynamic GlowRedrawer_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GlowRedrawer_obj > _hx_result = new GlowRedrawer_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GlowRedrawer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2e1a3233;
}

 ::openfl::filters::GlowFilter GlowRedrawer_obj::GLOW_FILTER;

 ::haxe::ds::ObjectMap GlowRedrawer_obj::glowHashes;

 ::openfl::display::BitmapData GlowRedrawer_obj::outlineGlow( ::openfl::display::BitmapData texture,int glowColor,::hx::Null< Float >  __o_outlineSize,::hx::Null< bool >  __o_caching,::hx::Null< int >  __o_outlineColor){
            		Float outlineSize = __o_outlineSize.Default(((Float)1.4));
            		bool caching = __o_caching.Default(true);
            		int outlineColor = __o_outlineColor.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_d276e28ea2e28404_15_outlineGlow)
HXLINE(  16)		int hash = ::util::GlowRedrawer_obj::getHash(glowColor,outlineSize,outlineColor);
HXLINE(  17)		bool _hx_tmp;
HXDLIN(  17)		if (caching) {
HXLINE(  17)			_hx_tmp = ::util::GlowRedrawer_obj::isCached(texture,hash);
            		}
            		else {
HXLINE(  17)			_hx_tmp = false;
            		}
HXDLIN(  17)		if (_hx_tmp) {
HXLINE(  18)			return ( ( ::openfl::display::BitmapData)(( ( ::haxe::ds::IntMap)(::util::GlowRedrawer_obj::glowHashes->get(texture)) )->get(hash)) );
            		}
HXLINE(  20)		 ::openfl::display::BitmapData newTexture = texture->clone();
HXLINE(  22)		newTexture->draw( ::openfl::display::Bitmap_obj::__alloc( HX_CTX ,texture,null(),null()),null(),null(),1,null(),null());
HXLINE(  23)		{
HXLINE(  23)			int _g = 0;
HXDLIN(  23)			int _g1 = newTexture->width;
HXDLIN(  23)			while((_g < _g1)){
HXLINE(  23)				_g = (_g + 1);
HXDLIN(  23)				int x = (_g - 1);
HXLINE(  24)				{
HXLINE(  24)					int _g2 = 0;
HXDLIN(  24)					int _g3 = newTexture->height;
HXDLIN(  24)					while((_g2 < _g3)){
HXLINE(  24)						_g2 = (_g2 + 1);
HXDLIN(  24)						int y = (_g2 - 1);
HXLINE(  25)						bool _hx_tmp1;
HXDLIN(  25)						if (((( (Float)(((newTexture->getPixel32(x,y) >> 24) & 255)) ) / ( (Float)(255) )) == 0)) {
HXLINE(  26)							bool _hx_tmp2;
HXDLIN(  26)							bool _hx_tmp3;
HXDLIN(  26)							bool _hx_tmp4;
HXDLIN(  26)							if (((( (Float)(((newTexture->getPixel32((x - 1),(y - 1)) >> 24) & 255)) ) / ( (Float)(255) )) != 0)) {
HXLINE(  26)								_hx_tmp4 = (newTexture->getPixel((x - 1),(y - 1)) != 0);
            							}
            							else {
HXLINE(  26)								_hx_tmp4 = false;
            							}
HXDLIN(  26)							if (!(_hx_tmp4)) {
HXLINE(  28)								if (((( (Float)(((newTexture->getPixel32((x - 1),(y + 1)) >> 24) & 255)) ) / ( (Float)(255) )) != 0)) {
HXLINE(  26)									_hx_tmp3 = (newTexture->getPixel((x - 1),(y + 1)) != 0);
            								}
            								else {
HXLINE(  26)									_hx_tmp3 = false;
            								}
            							}
            							else {
HXLINE(  26)								_hx_tmp3 = true;
            							}
HXDLIN(  26)							if (!(_hx_tmp3)) {
HXLINE(  30)								if (((( (Float)(((newTexture->getPixel32((x + 1),(y - 1)) >> 24) & 255)) ) / ( (Float)(255) )) != 0)) {
HXLINE(  26)									_hx_tmp2 = (newTexture->getPixel((x + 1),(y - 1)) != 0);
            								}
            								else {
HXLINE(  26)									_hx_tmp2 = false;
            								}
            							}
            							else {
HXLINE(  26)								_hx_tmp2 = true;
            							}
HXLINE(  25)							if (!(_hx_tmp2)) {
HXLINE(  32)								if (((( (Float)(((newTexture->getPixel32((x + 1),(y + 1)) >> 24) & 255)) ) / ( (Float)(255) )) != 0)) {
HXLINE(  25)									_hx_tmp1 = (newTexture->getPixel((x + 1),(y + 1)) != 0);
            								}
            								else {
HXLINE(  25)									_hx_tmp1 = false;
            								}
            							}
            							else {
HXLINE(  25)								_hx_tmp1 = true;
            							}
            						}
            						else {
HXLINE(  25)							_hx_tmp1 = false;
            						}
HXDLIN(  25)						if (_hx_tmp1) {
HXLINE(  34)							newTexture->setPixel32(x,y,-16777216);
            						}
            					}
            				}
            			}
            		}
HXLINE(  37)		if ((glowColor != -1)) {
HXLINE(  38)			::util::GlowRedrawer_obj::GLOW_FILTER->set_color(glowColor);
HXLINE(  39)			newTexture->applyFilter(newTexture,newTexture->rect, ::openfl::geom::Point_obj::__alloc( HX_CTX ,0,0),::util::GlowRedrawer_obj::GLOW_FILTER);
            		}
HXLINE(  42)		if (caching) {
HXLINE(  43)			::util::GlowRedrawer_obj::cache(texture,glowColor,outlineSize,newTexture,outlineColor);
            		}
HXLINE(  45)		return newTexture;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(GlowRedrawer_obj,outlineGlow,return )

void GlowRedrawer_obj::cache( ::openfl::display::BitmapData texture,int glowColor,Float outlineSize, ::openfl::display::BitmapData newTexture,int outlineColor){
            	HX_GC_STACKFRAME(&_hx_pos_d276e28ea2e28404_48_cache)
HXLINE(  49)		int hash = ::util::GlowRedrawer_obj::getHash(glowColor,outlineSize,outlineColor);
HXLINE(  50)		if (::hx::IsNotNull( ::util::GlowRedrawer_obj::glowHashes->get(texture) )) {
HXLINE(  51)			( ( ::haxe::ds::IntMap)(::util::GlowRedrawer_obj::glowHashes->get(texture)) )->set(hash,newTexture);
            		}
            		else {
HXLINE(  53)			 ::haxe::ds::IntMap glowHash =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  54)			glowHash->set(hash,newTexture);
HXLINE(  55)			::util::GlowRedrawer_obj::glowHashes->set(texture,glowHash);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(GlowRedrawer_obj,cache,(void))

bool GlowRedrawer_obj::isCached( ::openfl::display::BitmapData texture,int hash){
            	HX_STACKFRAME(&_hx_pos_d276e28ea2e28404_59_isCached)
HXLINE(  60)		 ::haxe::ds::IntMap outlineHash = ( ( ::haxe::ds::IntMap)(::util::GlowRedrawer_obj::glowHashes->get(texture)) );
HXLINE(  61)		if (::hx::IsNotNull( outlineHash )) {
HXLINE(  61)			return outlineHash->exists(hash);
            		}
            		else {
HXLINE(  61)			return false;
            		}
HXDLIN(  61)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GlowRedrawer_obj,isCached,return )

int GlowRedrawer_obj::getHash(int glowColor,Float outlineSize,int outlineColor){
            	HX_STACKFRAME(&_hx_pos_d276e28ea2e28404_65_getHash)
HXDLIN(  65)		return ::Std_obj::_hx_int((((outlineSize * ( (Float)(10) )) + glowColor) + outlineColor));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(GlowRedrawer_obj,getHash,return )


GlowRedrawer_obj::GlowRedrawer_obj()
{
}

bool GlowRedrawer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"cache") ) { outValue = cache_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"getHash") ) { outValue = getHash_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isCached") ) { outValue = isCached_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"glowHashes") ) { outValue = ( glowHashes ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"GLOW_FILTER") ) { outValue = ( GLOW_FILTER ); return true; }
		if (HX_FIELD_EQ(inName,"outlineGlow") ) { outValue = outlineGlow_dyn(); return true; }
	}
	return false;
}

bool GlowRedrawer_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"glowHashes") ) { glowHashes=ioValue.Cast<  ::haxe::ds::ObjectMap >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"GLOW_FILTER") ) { GLOW_FILTER=ioValue.Cast<  ::openfl::filters::GlowFilter >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *GlowRedrawer_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo GlowRedrawer_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::openfl::filters::GlowFilter */ ,(void *) &GlowRedrawer_obj::GLOW_FILTER,HX_("GLOW_FILTER",6a,62,9e,02)},
	{::hx::fsObject /*  ::haxe::ds::ObjectMap */ ,(void *) &GlowRedrawer_obj::glowHashes,HX_("glowHashes",29,42,0b,6d)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void GlowRedrawer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GlowRedrawer_obj::GLOW_FILTER,"GLOW_FILTER");
	HX_MARK_MEMBER_NAME(GlowRedrawer_obj::glowHashes,"glowHashes");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GlowRedrawer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GlowRedrawer_obj::GLOW_FILTER,"GLOW_FILTER");
	HX_VISIT_MEMBER_NAME(GlowRedrawer_obj::glowHashes,"glowHashes");
};

#endif

::hx::Class GlowRedrawer_obj::__mClass;

static ::String GlowRedrawer_obj_sStaticFields[] = {
	HX_("GLOW_FILTER",6a,62,9e,02),
	HX_("glowHashes",29,42,0b,6d),
	HX_("outlineGlow",2f,7b,6d,d9),
	HX_("cache",42,9a,14,41),
	HX_("isCached",6c,fb,5b,09),
	HX_("getHash",84,df,8a,17),
	::String(null())
};

void GlowRedrawer_obj::__register()
{
	GlowRedrawer_obj _hx_dummy;
	GlowRedrawer_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("util.GlowRedrawer",1d,41,91,82);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GlowRedrawer_obj::__GetStatic;
	__mClass->mSetStaticField = &GlowRedrawer_obj::__SetStatic;
	__mClass->mMarkFunc = GlowRedrawer_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GlowRedrawer_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< GlowRedrawer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GlowRedrawer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GlowRedrawer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GlowRedrawer_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GlowRedrawer_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_d276e28ea2e28404_10_boot)
HXDLIN(  10)		GLOW_FILTER =  ::openfl::filters::GlowFilter_obj::__alloc( HX_CTX ,0,1,4,4,255,3,false,false);
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_d276e28ea2e28404_12_boot)
HXDLIN(  12)		glowHashes =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace util
