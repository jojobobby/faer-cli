// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_util_BitmapUtil
#include <util/BitmapUtil.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_24681c7afebf7591_11_trimAlpha,"util.BitmapUtil","trimAlpha",0x3c9c5c0b,"util.BitmapUtil.trimAlpha","util/BitmapUtil.hx",11,0x20ae11a0)
HX_LOCAL_STACK_FRAME(_hx_pos_24681c7afebf7591_24_mirror,"util.BitmapUtil","mirror",0x95bac1f0,"util.BitmapUtil.mirror","util/BitmapUtil.hx",24,0x20ae11a0)
HX_LOCAL_STACK_FRAME(_hx_pos_24681c7afebf7591_46_cropToBitmapData,"util.BitmapUtil","cropToBitmapData",0x9bae83b5,"util.BitmapUtil.cropToBitmapData","util/BitmapUtil.hx",46,0x20ae11a0)
HX_LOCAL_STACK_FRAME(_hx_pos_24681c7afebf7591_52_amountTransparent,"util.BitmapUtil","amountTransparent",0xecb4ac49,"util.BitmapUtil.amountTransparent","util/BitmapUtil.hx",52,0x20ae11a0)
HX_LOCAL_STACK_FRAME(_hx_pos_24681c7afebf7591_65_mostCommonColor,"util.BitmapUtil","mostCommonColor",0x4b4952a4,"util.BitmapUtil.mostCommonColor","util/BitmapUtil.hx",65,0x20ae11a0)
namespace util{

void BitmapUtil_obj::__construct() { }

Dynamic BitmapUtil_obj::__CreateEmpty() { return new BitmapUtil_obj; }

void *BitmapUtil_obj::_hx_vtable = 0;

Dynamic BitmapUtil_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BitmapUtil_obj > _hx_result = new BitmapUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool BitmapUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7f8f63d7;
}

 ::openfl::display::BitmapData BitmapUtil_obj::trimAlpha( ::openfl::display::BitmapData tex){
            	HX_GC_STACKFRAME(&_hx_pos_24681c7afebf7591_11_trimAlpha)
HXLINE(  12)		bool _hx_tmp;
HXDLIN(  12)		if ((tex->width != 0)) {
HXLINE(  12)			_hx_tmp = (tex->height == 0);
            		}
            		else {
HXLINE(  12)			_hx_tmp = true;
            		}
HXDLIN(  12)		if (_hx_tmp) {
HXLINE(  13)			return tex;
            		}
HXLINE(  15)		 ::openfl::geom::Rectangle colorBounds = tex->getColorBoundsRect(-16777216,0,false);
HXLINE(  16)		bool _hx_tmp1;
HXDLIN(  16)		if ((colorBounds->width != 0)) {
HXLINE(  16)			_hx_tmp1 = (colorBounds->height == 0);
            		}
            		else {
HXLINE(  16)			_hx_tmp1 = true;
            		}
HXDLIN(  16)		if (_hx_tmp1) {
HXLINE(  17)			return tex;
            		}
HXLINE(  19)		int modTex = ::Std_obj::_hx_int(colorBounds->width);
HXDLIN(  19)		 ::openfl::display::BitmapData modTex1 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,modTex,::Std_obj::_hx_int(colorBounds->height),true,0);
HXLINE(  20)		modTex1->copyPixels(tex,colorBounds, ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null()),null(),null(),null());
HXLINE(  21)		return modTex1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(BitmapUtil_obj,trimAlpha,return )

 ::openfl::display::BitmapData BitmapUtil_obj::mirror( ::openfl::display::BitmapData bitmapData,::hx::Null< int >  __o_width){
            		int width = __o_width.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_24681c7afebf7591_24_mirror)
HXLINE(  25)		if ((width == 0)) {
HXLINE(  26)			width = bitmapData->width;
            		}
HXLINE(  28)		 ::openfl::display::BitmapData mirrored =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,bitmapData->width,bitmapData->height,true,0);
HXLINE(  29)		{
HXLINE(  29)			int _g = 0;
HXDLIN(  29)			int _g1 = bitmapData->width;
HXDLIN(  29)			while((_g < _g1)){
HXLINE(  29)				_g = (_g + 1);
HXDLIN(  29)				int x = (_g - 1);
HXLINE(  30)				{
HXLINE(  30)					int _g2 = 0;
HXDLIN(  30)					int _g3 = bitmapData->height;
HXDLIN(  30)					while((_g2 < _g3)){
HXLINE(  30)						_g2 = (_g2 + 1);
HXDLIN(  30)						int y = (_g2 - 1);
HXLINE(  31)						mirrored->setPixel32(((width - x) - 1),y,bitmapData->getPixel32(x,y));
            					}
            				}
            			}
            		}
HXLINE(  33)		return mirrored;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(BitmapUtil_obj,mirror,return )

 ::openfl::display::BitmapData BitmapUtil_obj::cropToBitmapData( ::openfl::display::BitmapData bitmapData,int x,int y,int width,int height){
            	HX_GC_STACKFRAME(&_hx_pos_24681c7afebf7591_46_cropToBitmapData)
HXLINE(  47)		 ::openfl::display::BitmapData cropped =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,null(),null());
HXLINE(  48)		cropped->copyPixels(bitmapData, ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,x,y,width,height), ::openfl::geom::Point_obj::__alloc( HX_CTX ,0,0),null(),null(),null());
HXLINE(  49)		return cropped;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(BitmapUtil_obj,cropToBitmapData,return )

Float BitmapUtil_obj::amountTransparent( ::openfl::display::BitmapData bitmapData){
            	HX_STACKFRAME(&_hx_pos_24681c7afebf7591_52_amountTransparent)
HXLINE(  53)		int alpha = 0;
HXLINE(  54)		int trans = 0;
HXLINE(  55)		{
HXLINE(  55)			int _g = 0;
HXDLIN(  55)			int _g1 = bitmapData->width;
HXDLIN(  55)			while((_g < _g1)){
HXLINE(  55)				_g = (_g + 1);
HXDLIN(  55)				int x = (_g - 1);
HXLINE(  56)				{
HXLINE(  56)					int _g2 = 0;
HXDLIN(  56)					int _g3 = bitmapData->height;
HXDLIN(  56)					while((_g2 < _g3)){
HXLINE(  56)						_g2 = (_g2 + 1);
HXLINE(  57)						alpha = (bitmapData->getPixel32(x,(_g2 - 1)) & -16777216);
HXLINE(  58)						if ((alpha == 0)) {
HXLINE(  59)							trans = (trans + 1);
            						}
            					}
            				}
            			}
            		}
HXLINE(  62)		return (( (Float)(trans) ) / ( (Float)((bitmapData->width * bitmapData->height)) ));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(BitmapUtil_obj,amountTransparent,return )

int BitmapUtil_obj::mostCommonColor( ::openfl::display::BitmapData bitmapData){
            	HX_GC_STACKFRAME(&_hx_pos_24681c7afebf7591_65_mostCommonColor)
HXLINE(  66)		if (::hx::IsNull( bitmapData )) {
HXLINE(  67)			return 0;
            		}
HXLINE(  69)		int color = 0;
HXLINE(  70)		 ::haxe::ds::IntMap colors =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  71)		{
HXLINE(  71)			int _g = 0;
HXDLIN(  71)			int _g1 = bitmapData->width;
HXDLIN(  71)			while((_g < _g1)){
HXLINE(  71)				_g = (_g + 1);
HXDLIN(  71)				int x = (_g - 1);
HXLINE(  72)				{
HXLINE(  72)					int _g2 = 0;
HXDLIN(  72)					int _g3 = bitmapData->height;
HXDLIN(  72)					while((_g2 < _g3)){
HXLINE(  72)						_g2 = (_g2 + 1);
HXLINE(  73)						color = bitmapData->getPixel32(x,(_g2 - 1));
HXLINE(  74)						if (((color & -16777216) != 0)) {
HXLINE(  75)							if (!(colors->exists(color))) {
HXLINE(  76)								colors->set(color,1);
            							}
            							else {
HXLINE(  78)								colors->set(color,(colors->get(color) + 1));
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  82)		int bestColor = 0;
HXLINE(  83)		int bestCount = 0;
HXLINE(  84)		{
HXLINE(  84)			 ::Dynamic color1 = colors->keys();
HXDLIN(  84)			while(( (bool)(color1->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  84)				int color2 = ( (int)(color1->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE(  85)				 ::Dynamic count = colors->get(color2);
HXLINE(  86)				bool _hx_tmp;
HXDLIN(  86)				if (::hx::IsLessEq( count,bestCount )) {
HXLINE(  86)					if (::hx::IsEq( count,bestCount )) {
HXLINE(  86)						_hx_tmp = (color2 > bestColor);
            					}
            					else {
HXLINE(  86)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE(  86)					_hx_tmp = true;
            				}
HXDLIN(  86)				if (_hx_tmp) {
HXLINE(  87)					bestColor = color2;
HXLINE(  88)					bestCount = ( (int)(count) );
            				}
            			}
            		}
HXLINE(  92)		return bestColor;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(BitmapUtil_obj,mostCommonColor,return )


BitmapUtil_obj::BitmapUtil_obj()
{
}

bool BitmapUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"mirror") ) { outValue = mirror_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"trimAlpha") ) { outValue = trimAlpha_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"mostCommonColor") ) { outValue = mostCommonColor_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"cropToBitmapData") ) { outValue = cropToBitmapData_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"amountTransparent") ) { outValue = amountTransparent_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *BitmapUtil_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *BitmapUtil_obj_sStaticStorageInfo = 0;
#endif

::hx::Class BitmapUtil_obj::__mClass;

static ::String BitmapUtil_obj_sStaticFields[] = {
	HX_("trimAlpha",1c,87,d2,65),
	HX_("mirror",3f,72,aa,55),
	HX_("cropToBitmapData",c4,4c,bd,ea),
	HX_("amountTransparent",5a,d0,95,ca),
	HX_("mostCommonColor",75,a0,de,1e),
	::String(null())
};

void BitmapUtil_obj::__register()
{
	BitmapUtil_obj _hx_dummy;
	BitmapUtil_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("util.BitmapUtil",9d,84,f3,03);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &BitmapUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(BitmapUtil_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< BitmapUtil_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BitmapUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BitmapUtil_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace util
