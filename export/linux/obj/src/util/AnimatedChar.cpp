// Generated by Haxe 4.3.0+731dcd7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_map_Camera
#include <map/Camera.h>
#endif
#ifndef INCLUDED_util_AnimatedChar
#include <util/AnimatedChar.h>
#endif
#ifndef INCLUDED_util_MaskedImage
#include <util/MaskedImage.h>
#endif
#ifndef INCLUDED_util_MaskedImageSet
#include <util/MaskedImageSet.h>
#endif
#ifndef INCLUDED_util_MathUtil
#include <util/MathUtil.h>
#endif
#ifndef INCLUDED_util_Rect
#include <util/Rect.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_12_new,"util.AnimatedChar","new",0x929f4a97,"util.AnimatedChar.new","util/AnimatedChar.hx",12,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_68_imageFromDir,"util.AnimatedChar","imageFromDir",0x61348ed1,"util.AnimatedChar.imageFromDir","util/AnimatedChar.hx",68,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_82_imageFromAngle,"util.AnimatedChar","imageFromAngle",0xcba4fe57,"util.AnimatedChar.imageFromAngle","util/AnimatedChar.hx",82,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_130_facingToDir,"util.AnimatedChar","facingToDir",0xa54c2a4f,"util.AnimatedChar.facingToDir","util/AnimatedChar.hx",130,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_141_rectFromFacing,"util.AnimatedChar","rectFromFacing",0x4bde3d91,"util.AnimatedChar.rectFromFacing","util/AnimatedChar.hx",141,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_157_loadImageDir,"util.AnimatedChar","loadImageDir",0x570c93e1,"util.AnimatedChar.loadImageDir","util/AnimatedChar.hx",157,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_165_loadRectDir,"util.AnimatedChar","loadRectDir",0xb7f73e3a,"util.AnimatedChar.loadRectDir","util/AnimatedChar.hx",165,0xa9ff7dd8)
HX_LOCAL_STACK_FRAME(_hx_pos_bc1c7d3fbb23586d_22_boot,"util.AnimatedChar","boot",0xb0dafa1b,"util.AnimatedChar.boot","util/AnimatedChar.hx",22,0xa9ff7dd8)
static const int _hx_array_data_473ab325_8[] = {
	(int)1,(int)3,(int)2,
};
static const int _hx_array_data_473ab325_9[] = {
	(int)3,(int)1,(int)2,
};
static const int _hx_array_data_473ab325_10[] = {
	(int)3,(int)0,(int)2,
};
static const int _hx_array_data_473ab325_11[] = {
	(int)0,(int)3,(int)2,
};
static const int _hx_array_data_473ab325_12[] = {
	(int)0,(int)2,
};
static const int _hx_array_data_473ab325_13[] = {
	(int)2,(int)0,
};
static const int _hx_array_data_473ab325_14[] = {
	(int)2,(int)1,
};
static const int _hx_array_data_473ab325_15[] = {
	(int)1,(int)2,
};
namespace util{

void AnimatedChar_obj::__construct( ::util::MaskedImage image,int width,int height,::hx::Null< int >  __o_padding){
            		int padding = __o_padding.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_12_new)
HXLINE(  37)		this->height = 0;
HXLINE(  36)		this->width = 0;
HXLINE(  42)		this->imageDict =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  43)		this->rectDict =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  44)		this->origImage = image;
HXLINE(  45)		this->width = width;
HXLINE(  46)		this->height = height;
HXLINE(  48)		 ::util::MaskedImageSet frames =  ::util::MaskedImageSet_obj::__alloc( HX_CTX );
HXLINE(  49)		frames->addFromMaskedImage(image,width,height);
HXLINE(  51)		 ::haxe::ds::IntMap _hx_tmp = this->imageDict;
HXDLIN(  51)		_hx_tmp->set(0,this->loadImageDir(0,frames));
HXLINE(  52)		 ::haxe::ds::IntMap _hx_tmp1 = this->imageDict;
HXDLIN(  52)		_hx_tmp1->set(1,this->loadImageDir(5,frames));
HXLINE(  53)		if ((frames->images->length >= 15)) {
HXLINE(  54)			 ::haxe::ds::IntMap _hx_tmp2 = this->imageDict;
HXDLIN(  54)			_hx_tmp2->set(2,this->loadImageDir(10,frames));
HXLINE(  55)			if ((frames->images->length >= 20)) {
HXLINE(  56)				 ::haxe::ds::IntMap _hx_tmp3 = this->imageDict;
HXDLIN(  56)				_hx_tmp3->set(3,this->loadImageDir(15,frames));
            			}
            		}
HXLINE(  59)		 ::haxe::ds::IntMap _hx_tmp4 = this->rectDict;
HXDLIN(  59)		_hx_tmp4->set(0,this->loadRectDir(0,frames));
HXLINE(  60)		 ::haxe::ds::IntMap _hx_tmp5 = this->rectDict;
HXDLIN(  60)		_hx_tmp5->set(1,this->loadRectDir(5,frames));
HXLINE(  61)		if ((frames->images->length >= 15)) {
HXLINE(  62)			 ::haxe::ds::IntMap _hx_tmp6 = this->rectDict;
HXDLIN(  62)			_hx_tmp6->set(2,this->loadRectDir(10,frames));
HXLINE(  63)			if ((frames->images->length >= 20)) {
HXLINE(  64)				 ::haxe::ds::IntMap _hx_tmp7 = this->rectDict;
HXDLIN(  64)				_hx_tmp7->set(3,this->loadRectDir(15,frames));
            			}
            		}
            	}

Dynamic AnimatedChar_obj::__CreateEmpty() { return new AnimatedChar_obj; }

void *AnimatedChar_obj::_hx_vtable = 0;

Dynamic AnimatedChar_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< AnimatedChar_obj > _hx_result = new AnimatedChar_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool AnimatedChar_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x59b7ae9f;
}

 ::util::MaskedImage AnimatedChar_obj::imageFromDir(int dir,int action,Float p){
            	HX_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_68_imageFromDir)
HXLINE(  69)		::Array< ::Dynamic> texVec = ( (::Array< ::Dynamic>)(( ( ::haxe::ds::IntMap)(this->imageDict->get(dir)) )->get(action)) );
HXLINE(  70)		p = ::Math_obj::max(( (Float)(0) ),::Math_obj::min(((Float)0.99999),p));
HXLINE(  71)		int i = ::Std_obj::_hx_int((p * ( (Float)(texVec->length) )));
HXLINE(  72)		return texVec->__get(i).StaticCast<  ::util::MaskedImage >();
            	}


HX_DEFINE_DYNAMIC_FUNC3(AnimatedChar_obj,imageFromDir,return )

 ::util::MaskedImage AnimatedChar_obj::imageFromAngle(Float angle,int action,Float p){
            	HX_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_82_imageFromAngle)
HXLINE(  83)		int sec = ::hx::Mod(::Std_obj::_hx_int(((angle / ((Float)0.785398163397448279)) + 4)),8);
HXLINE(  84)		::Array< int > dirs = ::util::AnimatedChar_obj::SEC_TO_DIRS->__get(sec).StaticCast< ::Array< int > >();
HXLINE(  85)		 ::haxe::ds::IntMap actionDict = ( ( ::haxe::ds::IntMap)(this->imageDict->get(dirs->__get(0))) );
HXLINE(  86)		if (::hx::IsNull( actionDict )) {
HXLINE(  87)			actionDict = ( ( ::haxe::ds::IntMap)(this->imageDict->get(dirs->__get(1))) );
HXLINE(  88)			if (::hx::IsNull( actionDict )) {
HXLINE(  89)				actionDict = ( ( ::haxe::ds::IntMap)(this->imageDict->get(dirs->__get(2))) );
            			}
            		}
HXLINE(  92)		::Array< ::Dynamic> texVec = ( (::Array< ::Dynamic>)(actionDict->get(action)) );
HXLINE(  93)		p = ::Math_obj::max(( (Float)(0) ),::Math_obj::min(((Float)0.99999),p));
HXLINE(  94)		int i = ::Std_obj::_hx_int((p * ( (Float)(texVec->length) )));
HXLINE(  95)		return texVec->__get(i).StaticCast<  ::util::MaskedImage >();
            	}


HX_DEFINE_DYNAMIC_FUNC3(AnimatedChar_obj,imageFromAngle,return )

int AnimatedChar_obj::facingToDir(float facing){
            	HX_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_130_facingToDir)
HXLINE( 132)		int sec = ::Std_obj::_hx_int(::Math_obj::abs(( (Float)(::hx::Mod(::Std_obj::_hx_int(((( (Float)(::util::MathUtil_obj::halfBound((facing - ::map::Camera_obj::angleRad))) ) / ((Float)0.785398163397448279)) + 4)),8)) )));
HXLINE( 133)		::Array< int > dirs = ::util::AnimatedChar_obj::SEC_TO_DIRS->__get(sec).StaticCast< ::Array< int > >();
HXLINE( 134)		if (!(this->rectDict->exists(dirs->__get(0)))) {
HXLINE( 135)			if (!(this->rectDict->exists(dirs->__get(1)))) {
HXLINE( 136)				return dirs->__get(2);
            			}
            			else {
HXLINE( 137)				return dirs->__get(1);
            			}
            		}
            		else {
HXLINE( 138)			return dirs->__get(0);
            		}
HXLINE( 134)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC1(AnimatedChar_obj,facingToDir,return )

 ::util::Rect AnimatedChar_obj::rectFromFacing(float facing,int action,float p){
            	HX_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_141_rectFromFacing)
HXLINE( 143)		int sec = ::Std_obj::_hx_int(::Math_obj::abs(( (Float)(::hx::Mod(::Std_obj::_hx_int(((( (Float)(::util::MathUtil_obj::halfBound((facing - ::map::Camera_obj::angleRad))) ) / ((Float)0.785398163397448279)) + 4)),8)) )));
HXLINE( 144)		::Array< int > dirs = ::util::AnimatedChar_obj::SEC_TO_DIRS->__get(sec).StaticCast< ::Array< int > >();
HXLINE( 145)		 ::haxe::ds::IntMap actionDict = ( ( ::haxe::ds::IntMap)(this->rectDict->get(dirs->__get(0))) );
HXLINE( 146)		if (::hx::IsNull( actionDict )) {
HXLINE( 147)			actionDict = ( ( ::haxe::ds::IntMap)(this->rectDict->get(dirs->__get(1))) );
HXLINE( 148)			if (::hx::IsNull( actionDict )) {
HXLINE( 149)				actionDict = ( ( ::haxe::ds::IntMap)(this->rectDict->get(dirs->__get(2))) );
            			}
            		}
HXLINE( 152)		::Array< ::Dynamic> texVec = ( (::Array< ::Dynamic>)(actionDict->get(action)) );
HXLINE( 153)		p = ( (float)(::Math_obj::max(( (Float)(0) ),::Math_obj::min(((Float)0.99999),( (Float)(p) )))) );
HXLINE( 154)		return texVec->__get(::Std_obj::_hx_int(( (Float)((p * ( (float)(texVec->length) ))) ))).StaticCast<  ::util::Rect >();
            	}


HX_DEFINE_DYNAMIC_FUNC3(AnimatedChar_obj,rectFromFacing,return )

 ::haxe::ds::IntMap AnimatedChar_obj::loadImageDir(int offset, ::util::MaskedImageSet frames){
            	HX_GC_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_157_loadImageDir)
HXLINE( 158)		 ::haxe::ds::IntMap imageDict =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 159)		imageDict->set(0,::Array_obj< ::Dynamic>::__new(1)->init(0,frames->images->__get(offset).StaticCast<  ::util::MaskedImage >()));
HXLINE( 160)		imageDict->set(1,::Array_obj< ::Dynamic>::__new(2)->init(0,frames->images->__get((offset + 1)).StaticCast<  ::util::MaskedImage >())->init(1,frames->images->__get((offset + 2)).StaticCast<  ::util::MaskedImage >()));
HXLINE( 161)		imageDict->set(2,::Array_obj< ::Dynamic>::__new(2)->init(0,frames->images->__get((offset + 3)).StaticCast<  ::util::MaskedImage >())->init(1,frames->images->__get((offset + 4)).StaticCast<  ::util::MaskedImage >()));
HXLINE( 162)		return imageDict;
            	}


HX_DEFINE_DYNAMIC_FUNC2(AnimatedChar_obj,loadImageDir,return )

 ::haxe::ds::IntMap AnimatedChar_obj::loadRectDir(int offset, ::util::MaskedImageSet frames){
            	HX_GC_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_165_loadRectDir)
HXLINE( 166)		 ::haxe::ds::IntMap rectDict =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 167)		rectDict->set(0,::Array_obj< ::Dynamic>::__new(1)->init(0,frames->imageRects->__get(offset).StaticCast<  ::util::Rect >()));
HXLINE( 168)		rectDict->set(1,::Array_obj< ::Dynamic>::__new(2)->init(0,frames->imageRects->__get((offset + 1)).StaticCast<  ::util::Rect >())->init(1,frames->imageRects->__get((offset + 2)).StaticCast<  ::util::Rect >()));
HXLINE( 169)		rectDict->set(2,::Array_obj< ::Dynamic>::__new(2)->init(0,frames->imageRects->__get((offset + 3)).StaticCast<  ::util::Rect >())->init(1,frames->imageRects->__get((offset + 4)).StaticCast<  ::util::Rect >()));
HXLINE( 170)		return rectDict;
            	}


HX_DEFINE_DYNAMIC_FUNC2(AnimatedChar_obj,loadRectDir,return )

::Array< ::Dynamic> AnimatedChar_obj::SEC_TO_DIRS;


::hx::ObjectPtr< AnimatedChar_obj > AnimatedChar_obj::__new( ::util::MaskedImage image,int width,int height,::hx::Null< int >  __o_padding) {
	::hx::ObjectPtr< AnimatedChar_obj > __this = new AnimatedChar_obj();
	__this->__construct(image,width,height,__o_padding);
	return __this;
}

::hx::ObjectPtr< AnimatedChar_obj > AnimatedChar_obj::__alloc(::hx::Ctx *_hx_ctx, ::util::MaskedImage image,int width,int height,::hx::Null< int >  __o_padding) {
	AnimatedChar_obj *__this = (AnimatedChar_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(AnimatedChar_obj), true, "util.AnimatedChar"));
	*(void **)__this = AnimatedChar_obj::_hx_vtable;
	__this->__construct(image,width,height,__o_padding);
	return __this;
}

AnimatedChar_obj::AnimatedChar_obj()
{
}

void AnimatedChar_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(AnimatedChar);
	HX_MARK_MEMBER_NAME(origImage,"origImage");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(imageDict,"imageDict");
	HX_MARK_MEMBER_NAME(rectDict,"rectDict");
	HX_MARK_END_CLASS();
}

void AnimatedChar_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(origImage,"origImage");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(imageDict,"imageDict");
	HX_VISIT_MEMBER_NAME(rectDict,"rectDict");
}

::hx::Val AnimatedChar_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( width ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( height ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"rectDict") ) { return ::hx::Val( rectDict ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"origImage") ) { return ::hx::Val( origImage ); }
		if (HX_FIELD_EQ(inName,"imageDict") ) { return ::hx::Val( imageDict ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"facingToDir") ) { return ::hx::Val( facingToDir_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadRectDir") ) { return ::hx::Val( loadRectDir_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"imageFromDir") ) { return ::hx::Val( imageFromDir_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadImageDir") ) { return ::hx::Val( loadImageDir_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"imageFromAngle") ) { return ::hx::Val( imageFromAngle_dyn() ); }
		if (HX_FIELD_EQ(inName,"rectFromFacing") ) { return ::hx::Val( rectFromFacing_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool AnimatedChar_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"SEC_TO_DIRS") ) { outValue = ( SEC_TO_DIRS ); return true; }
	}
	return false;
}

::hx::Val AnimatedChar_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { width=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { height=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"rectDict") ) { rectDict=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"origImage") ) { origImage=inValue.Cast<  ::util::MaskedImage >(); return inValue; }
		if (HX_FIELD_EQ(inName,"imageDict") ) { imageDict=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool AnimatedChar_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"SEC_TO_DIRS") ) { SEC_TO_DIRS=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
	}
	return false;
}

void AnimatedChar_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("origImage",da,c7,c9,7c));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("imageDict",71,ee,9d,24));
	outFields->push(HX_("rectDict",ba,34,81,6d));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo AnimatedChar_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::util::MaskedImage */ ,(int)offsetof(AnimatedChar_obj,origImage),HX_("origImage",da,c7,c9,7c)},
	{::hx::fsInt,(int)offsetof(AnimatedChar_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsInt,(int)offsetof(AnimatedChar_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(AnimatedChar_obj,imageDict),HX_("imageDict",71,ee,9d,24)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(AnimatedChar_obj,rectDict),HX_("rectDict",ba,34,81,6d)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo AnimatedChar_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(void *) &AnimatedChar_obj::SEC_TO_DIRS,HX_("SEC_TO_DIRS",fc,ac,8d,26)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String AnimatedChar_obj_sMemberFields[] = {
	HX_("origImage",da,c7,c9,7c),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("imageDict",71,ee,9d,24),
	HX_("rectDict",ba,34,81,6d),
	HX_("imageFromDir",e8,87,bf,47),
	HX_("imageFromAngle",2e,ab,b1,a5),
	HX_("facingToDir",18,21,19,f2),
	HX_("rectFromFacing",68,ea,ea,25),
	HX_("loadImageDir",f8,8c,97,3d),
	HX_("loadRectDir",03,35,c4,04),
	::String(null()) };

static void AnimatedChar_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(AnimatedChar_obj::SEC_TO_DIRS,"SEC_TO_DIRS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void AnimatedChar_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(AnimatedChar_obj::SEC_TO_DIRS,"SEC_TO_DIRS");
};

#endif

::hx::Class AnimatedChar_obj::__mClass;

static ::String AnimatedChar_obj_sStaticFields[] = {
	HX_("SEC_TO_DIRS",fc,ac,8d,26),
	::String(null())
};

void AnimatedChar_obj::__register()
{
	AnimatedChar_obj _hx_dummy;
	AnimatedChar_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("util.AnimatedChar",25,b3,3a,47);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &AnimatedChar_obj::__GetStatic;
	__mClass->mSetStaticField = &AnimatedChar_obj::__SetStatic;
	__mClass->mMarkFunc = AnimatedChar_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(AnimatedChar_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(AnimatedChar_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< AnimatedChar_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = AnimatedChar_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = AnimatedChar_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = AnimatedChar_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void AnimatedChar_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_bc1c7d3fbb23586d_22_boot)
HXDLIN(  22)		SEC_TO_DIRS = ::Array_obj< ::Dynamic>::__new(8)->init(0,::Array_obj< int >::fromData( _hx_array_data_473ab325_8,3))->init(1,::Array_obj< int >::fromData( _hx_array_data_473ab325_9,3))->init(2,::Array_obj< int >::fromData( _hx_array_data_473ab325_10,3))->init(3,::Array_obj< int >::fromData( _hx_array_data_473ab325_11,3))->init(4,::Array_obj< int >::fromData( _hx_array_data_473ab325_12,2))->init(5,::Array_obj< int >::fromData( _hx_array_data_473ab325_13,2))->init(6,::Array_obj< int >::fromData( _hx_array_data_473ab325_14,2))->init(7,::Array_obj< int >::fromData( _hx_array_data_473ab325_15,2));
            	}
}

} // end namespace util
